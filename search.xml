<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/oi-notes/MTT/</url>
    <content><![CDATA[<hr />
<p>title: '任意模数NTT(MTT)' date: 'Sat Aug 12 11:05:23 2023 categories:
- oi-notes'</p>
<h1 id="任意模数nttmtt">任意模数NTT(MTT)</h1>
<p><a href="https://www.luogu.com.cn/problem/P4245">模板题传送门</a></p>
<p>问题的简单描述为，求解两个值域为 <span class="math inline">\(\leq
10^9\)</span> 的多项式卷积对于 <span class="math inline">\(P\leq
10^9\)</span> 取模的结果。</p>
<p><br></p>
<p>问题不能直接用NTT/FFT求解，因为均超过了值域范围（double值域承受不了）。</p>
<p><br></p>
<h3 id="solution13模数ntt">Solution1：3模数NTT</h3>
<p>取几个互质的模数分别做一次，然后用中国剩余定理合并。</p>
<p>由于值域大，通常需要多次 NTT，且中国剩余定理合并常数也不小。</p>
<p>实际代码实现也复杂，因此笔者认为不可取。</p>
<p><br></p>
<h3 id="solution2拆系数fft">Solution2：拆系数FFT</h3>
<p>设 <span class="math inline">\(f(x)=\sum a_ix^i\)</span>。</p>
<p>核心：将系数 <span class="math inline">\(a_i\)</span> 分解成 <span
class="math inline">\(a_i=A_i\cdot S+C_i,b_i=B_i\cdot
S+D_i\)</span>。</p>
<p>(其中 <span class="math inline">\(S\ge \sqrt{P}\)</span> 是一个常数，
<span class="math inline">\(0 \leq A_i,B_i,C_i,D_i&lt;S\)</span> )。</p>
<p>目的是转化后使系数值域变小，double 精度可以承受。</p>
<p>则最后的答案转化为求解 <span
class="math inline">\(A_iB_jS^2+(C_iB_j+A_iD_j)S+C_iD_j\)</span>。</p>
<p>即求解 <span
class="math inline">\(A_iB_j,C_iB_j,A_iD_j,C_iD_j\)</span>
，此时值域已经大大缩小。</p>
<p>如果直接求解，可以看出要求解4次卷积，需要进行 <span
class="math inline">\(12\)</span> 次<strong>FFT</strong>，不可接受。</p>
<p>利用复数的一些性质，有些东西我们可以一起算。</p>
<p>构造：</p>
<ol type="1">
<li><p><span class="math inline">\(f(x)=\sum
(A_i,C_i)x^i\)</span>，</p></li>
<li><p><span
class="math inline">\(g(x)=\sum(B_i,D_i)x^i\)</span>，</p></li>
<li><p><span class="math inline">\(f(x)g(x)=\sum \sum (A_iB_j-C_iD_j,
A_iD_j+C_iB_j)x^{i+j}\)</span>。</p></li>
</ol>
<p>此时已经得到大部分值了，再构造：</p>
<ol type="1">
<li><p><span class="math inline">\(h(x)=\sum B_ix^i\)</span>，</p></li>
<li><p><span class="math inline">\(f(x)h(x)=\sum \sum
(A_iB_j,C_iB_j)x^{i+j}\)</span>。</p></li>
</ol>
<p>取一部分即可。</p>
<p>最终一共有 5 次 FFT。</p>
<p>Tips:</p>
<p>1.这里的负数取整一定要注意，因为 C++ 默认是向 0
取整，而不是向下取整。</p>
<p>2.实际运行表明，这样写用 double 很难保证精度，应该要用 long
double</p>
<p>附:</p>
<p>4次FFT做MTT，但是具体证明比较反人类，而代码非常好看且好写，所以建议直接背板子</p>
<p>Tips:
只要使用了上面提到的最适合FFT的板子，就可以用double，甚至可以开O2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MTT&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>((<span class="type">double</span>)<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> rev[N];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Cp</span>&#123;</span><br><span class="line">		<span class="type">double</span> x,y;</span><br><span class="line">		<span class="built_in">Cp</span>()&#123; ; &#125;</span><br><span class="line">		<span class="built_in">Cp</span>(<span class="type">double</span> _x,<span class="type">double</span> _y): <span class="built_in">x</span>(_x),<span class="built_in">y</span>(_y)&#123; &#125; </span><br><span class="line">		<span class="keyword">inline</span> Cp <span class="keyword">operator</span> + (<span class="type">const</span> Cp &amp;t) <span class="type">const</span> &#123; <span class="keyword">return</span> (Cp)&#123;x+t.x,y+t.y&#125;; &#125;</span><br><span class="line">		<span class="keyword">inline</span> Cp <span class="keyword">operator</span> - (<span class="type">const</span> Cp &amp;t) <span class="type">const</span> &#123; <span class="keyword">return</span> (Cp)&#123;x-t.x,y-t.y&#125;; &#125;</span><br><span class="line">		<span class="keyword">inline</span> Cp <span class="keyword">operator</span> * (<span class="type">const</span> Cp &amp;t) <span class="type">const</span> &#123; <span class="keyword">return</span> (Cp)&#123;x*t.x-y*t.y,x*t.y+y*t.x&#125;; &#125;</span><br><span class="line">	&#125;A[N],B[N],C[N],w[N/<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> E(x) ll(x+0.5)%P</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(<span class="type">int</span> n,Cp *a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(rev[i]&lt;i) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">		w[<span class="number">0</span>]=<span class="built_in">Cp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(reg <span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">			Cp t=<span class="built_in">Cp</span>(<span class="built_in">cos</span>(PI/i),f*<span class="built_in">sin</span>(PI/i));</span><br><span class="line">			<span class="keyword">for</span>(reg <span class="type">int</span> j=i<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j-=<span class="number">2</span>) w[j+<span class="number">1</span>]=t*(w[j]=w[j&gt;&gt;<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 上面提到的最优板子</span></span><br><span class="line">			<span class="keyword">for</span>(reg <span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=<span class="number">2</span>*i) &#123;</span><br><span class="line">				<span class="keyword">for</span>(reg <span class="type">int</span> j=l;j&lt;l+i;j++) &#123;</span><br><span class="line">					Cp t=a[j+i]*w[j-l];</span><br><span class="line">					a[j+i]=a[j]-t;</span><br><span class="line">					a[j]=a[j]+t;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f==<span class="number">-1</span>) <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i].x/=n,a[i].y/=n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,<span class="type">int</span> *a,<span class="type">int</span> *b,<span class="type">int</span> *res,<span class="type">int</span> P)</span></span>&#123;</span><br><span class="line">		<span class="comment">// [0,n-1]*[0,m-1]-&gt;[0,n+m-2]</span></span><br><span class="line">		<span class="type">int</span> S=(<span class="number">1</span>&lt;&lt;<span class="number">15</span>)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> R=<span class="number">1</span>,cc=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(R&lt;=n+m<span class="number">-1</span>) R&lt;&lt;=<span class="number">1</span>,cc++;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,R) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;cc);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=<span class="built_in">Cp</span>((a[i]&amp;S),(a[i]&gt;&gt;<span class="number">15</span>));</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) B[i]=<span class="built_in">Cp</span>((b[i]&amp;S),(b[i]&gt;&gt;<span class="number">15</span>));</span><br><span class="line">		<span class="built_in">rep</span>(i,n,R<span class="number">-1</span>) A[i]=<span class="built_in">Cp</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,m,R<span class="number">-1</span>) B[i]=<span class="built_in">Cp</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">FFT</span>(R,A,<span class="number">1</span>),<span class="built_in">FFT</span>(R,B,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> j=(R-i)%R;</span><br><span class="line">			C[i]=<span class="built_in">Cp</span>((A[i].x+A[j].x)/<span class="number">2</span>,(A[i].y-A[j].y)/<span class="number">2</span>)*B[i];</span><br><span class="line">			B[i]=<span class="built_in">Cp</span>((A[i].y+A[j].y)/<span class="number">2</span>,(A[j].x-A[i].x)/<span class="number">2</span>)*B[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">FFT</span>(R,C,<span class="number">-1</span>),<span class="built_in">FFT</span>(R,B,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n+m<span class="number">-2</span>) &#123;</span><br><span class="line">			ll a=<span class="built_in">E</span>(C[i].x),b=<span class="built_in">E</span>(C[i].y),c=<span class="built_in">E</span>(B[i].x),d=<span class="built_in">E</span>(B[i].y);</span><br><span class="line">			res[i]=(a+((b+c)&lt;&lt;<span class="number">15</span>)+(d&lt;&lt;<span class="number">30</span>))%P;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> E</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/Montgomery/</url>
    <content><![CDATA[<hr />
<p>title: 'Montgomery Reduction 算法流程与实际实现' date: 'Sat Aug 12
11:05:23 2023 categories: - oi-notes'</p>
<h1 id="montgomery-reduction-算法流程与实际实现">Montgomery Reduction
算法流程与实际实现</h1>
<p>下面默认对于模数 <span class="math inline">\(m\)</span>
取模，由于这篇文章的重点是实现<del>(其实就是我自己存一下板子)</del>，因此没有证明。</p>
<h3 id="使用注意">使用注意：</h3>
<p>Montgomery Reduction 相较于 Barret Reduction 来说，不需要使用
__int128。</p>
<p>但是有着更高的封装程度，因为<strong>涉及到普通数与 Montgomery
Reduction 运算中间量的转化</strong>。</p>
<p>另外，常见的 Montgomery Reduction 在编程竞赛中的应用
<strong>要求模数为奇数</strong>。</p>
<p>但是在 Min25 博客上来看，<strong>Montgomery
似乎有着更高的效率</strong>。</p>
<p>在工程领域， Montgomery 用于处理大二进制数的取模问题。</p>
<span id="more"></span>
<h3 id="montgomery-reduction算法思想简介">Montgomery
Reduction算法思想简介</h3>
<p>在计算取模运算的过程中，将每一个元素 <span
class="math inline">\(T\)</span> 都乘上一个特定的值 <span
class="math inline">\(R(R&gt;m,\gcd(R,m)=1)\)</span>。</p>
<p>用特殊的方法处理相乘时除掉一个 <span class="math inline">\(R\)</span>
的过程，从而避免取模运算。</p>
<p>在使用的模数为常量时，编译器通常会自动加入 Barrett reduction
的优化，因此实际上这个算法对于动态模数的情形更为适用。</p>
<p><del>(你自己真不一定写得过STL，但是确实可以比STL块)</del></p>
<p><br></p>
<h3 id="编程上的应用简介">编程上的应用简介</h3>
<p>对于 <span class="math inline">\(m\)</span> 为奇数的情况，取 <span
class="math inline">\(R=2^{32}\)</span>，用
<strong>自然溢出来代替取模/位运算位移代替除法</strong> 来加速运算。</p>
<p>我们还需要令 <span class="math inline">\(m&#39; = -m^{-1} \mod
R\)</span>，有结论：</p>
<p>对于某一个数 <span class="math inline">\(T,0 \leq T &lt;
mR\)</span>，若令 <span class="math inline">\(U = Tm’ \mod
R\)</span>，则 <span class="math inline">\(\frac{T+Um}{R}\)</span>
为整数，且 <span class="math inline">\(\frac{T+Um}{R}=TR^{-1} \mod
m\)</span>。</p>
<p>那么我们在计算 <span class="math inline">\(\frac{T}{R}\)</span>
时，实际上只需要计算 <span
class="math inline">\(\frac{T+Um}{R}\)</span>，可以预处理 <span
class="math inline">\(m&#39;\)</span>，溢出计算 <span
class="math inline">\(Tm&#39;\)</span>，位运算左移计算 <span
class="math inline">\(\frac{T+Um}{R}\)</span>。</p>
<p>实际使用时的实现，可以用一个类实现以下方法</p>
<p>在实现时需要尤其注意不要出现溢出</p>
<h4 id="预处理m">1. 预处理<span
class="math inline">\(m&#39;\)</span></h4>
<p><span class="math inline">\((R-\lfloor \frac{R}{m}\rfloor )\cdot
(R\mod m)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> u32=<span class="type">unsigned</span>;</span><br><span class="line"><span class="keyword">using</span> i32=<span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> u64=<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> i64=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="comment">// inv=m&#x27;</span></span><br><span class="line">u32 m;</span><br><span class="line"><span class="function">u32 <span class="title">getinv</span><span class="params">()</span></span>&#123;</span><br><span class="line">	u32 inv=m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i) inv*=<span class="number">2</span>-inv*m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reduce方法">2. reduce方法</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">u32 <span class="title">reduce</span><span class="params">(u64 x)</span> </span>&#123;</span><br><span class="line">    u32 y = <span class="built_in">u32</span>(x &gt;&gt; <span class="number">32</span>) - <span class="built_in">u32</span>((<span class="built_in">u64</span>(<span class="built_in">u32</span>(x)*inv)*m) &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    <span class="comment">// 先取u32(x)得到x mod R ，然后再转成u64进行乘法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">i32</span>(y) &lt; <span class="number">0</span> ? y + m : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="普通数转montgomery-reduction">3. 普通数转Montgomery
Reduction</h4>
<p>我们要计算<span class="math inline">\(x\rightarrow xR=x\cdot
2^{32}\)</span>，但是如果直接用取模就失去了意义。。。</p>
<p>方法是快速计算<span class="math inline">\(x\cdot
R^2\)</span>，然后reduce一次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">u32 R2=-<span class="built_in">u64</span>(m)%m;</span><br><span class="line"><span class="function">u32 <span class="title">intToMont</span><span class="params">(i32 x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduce</span>(<span class="built_in">u64</span>(x)*R2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[ \ \]</span></p>
<h4 id="montomery运算">4. Montomery运算</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">u32 <span class="title">Add</span><span class="params">(u32 x,u32 y)</span> </span>&#123;</span><br><span class="line">    x+=y-m;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">i32</span>(x&lt;<span class="number">0</span>)?x+m:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u32 <span class="title">Dec</span><span class="params">(u32 x,u32 y)</span></span>&#123;</span><br><span class="line">    x-=y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">i32</span>(x&lt;<span class="number">0</span>)?x+m:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">u32 <span class="title">Mul</span><span class="params">(u32 x,u32 y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduce</span>(<span class="built_in">u64</span>(x)*y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[ \ \]</span></p>
<h4 id="montomery-reduction转普通数">5. Montomery Reduction转普通数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">i32 <span class="title">get</span><span class="params">(u32 x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduce</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装之后，得到板子一号，这个是动态模数的。。。</p>
<p>实现上可能的误区：</p>
<p>为什么不用 -inv? 避免加法，原因是加法取模要和 m 比较</p>
<p>同样的，下面的 i32(y)&lt;0 语句可以被替换为 y&gt;=m
(负数溢出)，看似减少一次类型转换，但是实际上0作为常量比较快得多</p>
<p>加法运算时也是类似的原因，x&gt;=m 比较实在太慢，因此强制减去一个
m，然后和 0 比</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> u32=<span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">using</span> i32=<span class="type">int32_t</span>;</span><br><span class="line"><span class="keyword">using</span> u64=<span class="type">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> i64=<span class="type">int64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32 m,inv,r2,P;</span><br><span class="line"><span class="function">u32 <span class="title">getinv</span><span class="params">()</span></span>&#123;</span><br><span class="line">    u32 inv=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i) inv*=<span class="number">2</span>-inv*m;</span><br><span class="line">    <span class="keyword">return</span> inv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mont</span>&#123;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    u32 x;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">static</span> u32 <span class="title">reduce</span><span class="params">(u64 x)</span></span>&#123; </span><br><span class="line">        u32 y=<span class="built_in">u32</span>(x&gt;&gt;<span class="number">32</span>)-<span class="built_in">u32</span>((<span class="built_in">u64</span>(<span class="built_in">u32</span>(x)*inv)*m)&gt;&gt;<span class="number">32</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">i32</span>(y)&lt;<span class="number">0</span>?y+m:y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Mont</span>()&#123; ; &#125;</span><br><span class="line">    <span class="built_in">Mont</span>(i32 x):<span class="built_in">x</span>(<span class="built_in">reduce</span>(<span class="built_in">u64</span>(x)*r2)) &#123; &#125;</span><br><span class="line">    Mont&amp; <span class="keyword">operator</span> += (<span class="type">const</span> Mont &amp;rhs) &#123; <span class="keyword">return</span> x+=rhs.x-m,<span class="built_in">is32</span>(x)&lt;<span class="number">0</span>&amp;&amp;(x+=m),*<span class="keyword">this</span>; &#125;</span><br><span class="line">    Mont&amp; <span class="keyword">operator</span> -= (<span class="type">const</span> Mont &amp;rhs) &#123; <span class="keyword">return</span> x-=rhs.x,<span class="built_in">i32</span>(x)&lt;<span class="number">0</span>&amp;&amp;(x+=m),*<span class="keyword">this</span>; &#125;</span><br><span class="line">    Mont&amp; <span class="keyword">operator</span> *= (<span class="type">const</span> Mont &amp;rhs) &#123; <span class="keyword">return</span> x=<span class="built_in">reduce</span>(<span class="built_in">u64</span>(x)*rhs.x),*<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mont <span class="keyword">operator</span> + (Mont x,<span class="type">const</span> Mont &amp;y) &#123; <span class="keyword">return</span> x+=y; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mont <span class="keyword">operator</span> - (Mont x,<span class="type">const</span> Mont &amp;y) &#123; <span class="keyword">return</span> x-=y; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mont <span class="keyword">operator</span> * (Mont x,<span class="type">const</span> Mont &amp;y) &#123; <span class="keyword">return</span> x*=y; &#125;</span><br><span class="line">    <span class="function">i32 <span class="title">get</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">reduce</span>(x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123; </span><br><span class="line">    ::m=m;</span><br><span class="line">    inv=-<span class="built_in">getinv</span>();</span><br><span class="line">    r2=-<span class="built_in">u64</span>(m)%m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态模数的方法，计算 <span class="math inline">\(5\cdot 10^7!\mod
998244353\)</span> 在 duck.ac 上评测结果，时间单位是微秒<span
class="math inline">\(\mu s\)</span>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Naive Mod     : 213689172  Time: 518352</span><br><span class="line">My Montgomery : 213689172  Time: 192195</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p>这个是我自己写的静态模数的，因为模数是静态的，所以不需要一定和0比较大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">uint32_t</span> m&gt; <span class="keyword">struct</span> <span class="title class_">Mont</span>&#123;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">using</span> u32=<span class="type">uint32_t</span>;</span><br><span class="line">    <span class="keyword">using</span> i32=<span class="type">int32_t</span>;</span><br><span class="line">    <span class="keyword">using</span> u64=<span class="type">uint64_t</span>;</span><br><span class="line">    <span class="keyword">using</span> i64=<span class="type">int64_t</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> u32 <span class="title">getinv</span><span class="params">()</span></span>&#123;</span><br><span class="line">        u32 inv=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i) inv*=<span class="number">2</span>-inv*m;</span><br><span class="line">        <span class="keyword">return</span> inv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> u32 inv=-<span class="built_in">getinv</span>(),r2=-<span class="built_in">u64</span>(m)%m;</span><br><span class="line">    u32 x;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> u32 <span class="title">reduce</span><span class="params">(u64 x)</span></span>&#123; </span><br><span class="line">        u32 y=(x+<span class="built_in">u64</span>(<span class="built_in">u32</span>(x)*inv)*m)&gt;&gt;<span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> y&gt;=m?y-m:y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Mont</span>()&#123; ; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Mont</span><span class="params">(i32 x)</span>:x(reduce(u64(x)*r2)) &#123;</span> &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> Mont&amp; <span class="keyword">operator</span> += (<span class="type">const</span> Mont &amp;rhs) &#123; <span class="keyword">return</span> x+=rhs.x-m,x&gt;=m&amp;&amp;(x+=m),*<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> Mont&amp; <span class="keyword">operator</span> -= (<span class="type">const</span> Mont &amp;rhs) &#123; <span class="keyword">return</span> x-=rhs.x,x&gt;=m&amp;&amp;(x+=m),*<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> Mont&amp; <span class="keyword">operator</span> *= (<span class="type">const</span> Mont &amp;rhs) &#123; <span class="keyword">return</span> x=<span class="built_in">reduce</span>(<span class="built_in">u64</span>(x)*rhs.x),*<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Mont <span class="keyword">operator</span> + (Mont x,<span class="type">const</span> Mont &amp;y) &#123; <span class="keyword">return</span> x+=y; &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Mont <span class="keyword">operator</span> - (Mont x,<span class="type">const</span> Mont &amp;y) &#123; <span class="keyword">return</span> x-=y; &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Mont <span class="keyword">operator</span> * (Mont x,<span class="type">const</span> Mont &amp;y) &#123; <span class="keyword">return</span> x*=y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i32 <span class="title">get</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">reduce</span>(x); &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个是摘自 <a href="https://loj.ac/s/864511">LOJ多项式乘法
hly1204的提交记录</a></p>
<p>个人解读：实际上每次存储的是 <span class="math inline">\(x \mod
2m\)</span> 的值，避免了reduce时的加减取模。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from https://min-25.hatenablog.com/entry/2017/08/20/171214</span></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">uint32_t</span> P&gt; <span class="keyword">struct</span> <span class="title class_">MontgomeryModInt32</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> i32 = std::<span class="type">int32_t</span>;</span><br><span class="line">  <span class="keyword">using</span> u32 = std::<span class="type">uint32_t</span>;</span><br><span class="line">  <span class="keyword">using</span> i64 = std::<span class="type">int64_t</span>;</span><br><span class="line">  <span class="keyword">using</span> u64 = std::<span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  u32 v;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> u32 <span class="title">get_r</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    u32 iv = P;</span><br><span class="line">    <span class="keyword">for</span> (u32 i = <span class="number">0</span>; i != <span class="number">4</span>; ++i) iv *= <span class="number">2</span> - P * iv;</span><br><span class="line">    <span class="keyword">return</span> iv;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> u32 r = -<span class="built_in">get_r</span>(), r2 = -<span class="built_in">u64</span>(P) % P;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">static_assert</span>((P &amp; <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(r * P == <span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(P &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> u32 <span class="title">pow_mod</span><span class="params">(u32 x, u64 y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((y %= P - <span class="number">1</span>) &lt; <span class="number">0</span>) y += P - <span class="number">1</span>;</span><br><span class="line">    u32 res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y != <span class="number">0</span>; y &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">u64</span>(x) * x % P)</span><br><span class="line">      <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="built_in">u64</span>(res) * x % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> u32 <span class="title">get_pr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    u32 tmp[<span class="number">32</span>] = &#123;&#125;, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> u64 phi = P - <span class="number">1</span>;</span><br><span class="line">    u64 m = phi;</span><br><span class="line">    <span class="keyword">for</span> (u64 i = <span class="number">2</span>; i * i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (m % i == <span class="number">0</span>) &#123;</span><br><span class="line">        tmp[cnt++] = i;</span><br><span class="line">        <span class="keyword">while</span> (m % i == <span class="number">0</span>) m /= i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">1</span>) tmp[cnt++] = m;</span><br><span class="line">    <span class="keyword">for</span> (u64 res = <span class="number">2</span>; res &lt;= phi; ++res) &#123;</span><br><span class="line">      <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (u32 i = <span class="number">0</span>; i != cnt &amp;&amp; flag; ++i) flag &amp;= <span class="built_in">pow_mod</span>(res, phi / tmp[i]) != <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (flag) <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MontgomeryModInt32</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">MontgomeryModInt32</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">MontgomeryModInt32</span><span class="params">(u32 v)</span> : v(reduce(u64(v) * r2)) &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">MontgomeryModInt32</span><span class="params">(<span class="type">const</span> MontgomeryModInt32 &amp;rhs)</span> : v(rhs.v) &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> u32 <span class="title">reduce</span><span class="params">(u64 x)</span> </span>&#123; <span class="keyword">return</span> x + (<span class="built_in">u64</span>(<span class="built_in">u32</span>(x) * r) * P) &gt;&gt; <span class="number">32</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> u32 <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    u32 res = <span class="built_in">reduce</span>(v);</span><br><span class="line">    <span class="keyword">return</span> res - (P &amp; -(res &gt;= P));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">u32</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">get</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">i32</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">i32</span>(<span class="built_in">get</span>()); &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> MontgomeryModInt32 &amp;<span class="keyword">operator</span>=(<span class="type">const</span> MontgomeryModInt32 &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> v = rhs.v, *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> MontgomeryModInt32 <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">    MontgomeryModInt32 res;</span><br><span class="line">    <span class="keyword">return</span> res.v = (P &lt;&lt; <span class="number">1</span> &amp; -(v != <span class="number">0</span>)) - v, res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> MontgomeryModInt32 <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> MontgomeryModInt32 &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> MontgomeryModInt32 &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> v += rhs.v - (P &lt;&lt; <span class="number">1</span>), v += P &lt;&lt; <span class="number">1</span> &amp; -(<span class="built_in">i32</span>(v) &lt; <span class="number">0</span>), *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> MontgomeryModInt32 &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> MontgomeryModInt32 &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> v -= rhs.v, v += P &lt;&lt; <span class="number">1</span> &amp; -(<span class="built_in">i32</span>(v) &lt; <span class="number">0</span>), *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> MontgomeryModInt32 &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> MontgomeryModInt32 &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> v = <span class="built_in">reduce</span>(<span class="built_in">u64</span>(v) * rhs.v), *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> MontgomeryModInt32 &amp;<span class="keyword">operator</span>/=(<span class="type">const</span> MontgomeryModInt32 &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*=(rhs.<span class="built_in">inv</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> MontgomeryModInt32 <span class="keyword">operator</span>+(<span class="type">const</span> MontgomeryModInt32 &amp;lhs,</span><br><span class="line">                                      <span class="type">const</span> MontgomeryModInt32 &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MontgomeryModInt32</span>(lhs) += rhs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> MontgomeryModInt32 <span class="keyword">operator</span>-(<span class="type">const</span> MontgomeryModInt32 &amp;lhs,</span><br><span class="line">                                      <span class="type">const</span> MontgomeryModInt32 &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MontgomeryModInt32</span>(lhs) -= rhs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> MontgomeryModInt32 <span class="keyword">operator</span>*(<span class="type">const</span> MontgomeryModInt32 &amp;lhs,</span><br><span class="line">                                      <span class="type">const</span> MontgomeryModInt32 &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MontgomeryModInt32</span>(lhs) *= rhs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> MontgomeryModInt32 <span class="keyword">operator</span>/(<span class="type">const</span> MontgomeryModInt32 &amp;lhs,</span><br><span class="line">                                      <span class="type">const</span> MontgomeryModInt32 &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MontgomeryModInt32</span>(lhs) /= rhs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, MontgomeryModInt32 &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> is &gt;&gt; rhs.v, rhs.v = <span class="built_in">reduce</span>(<span class="built_in">u64</span>(rhs.v) * r2), is;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> MontgomeryModInt32 &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; rhs.<span class="built_in">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> MontgomeryModInt32 <span class="title">pow</span><span class="params">(i64 y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((y %= P - <span class="number">1</span>) &lt; <span class="number">0</span>) y += P - <span class="number">1</span>; <span class="comment">// phi(P) = P - 1, assume P is a prime number</span></span><br><span class="line">    <span class="function">MontgomeryModInt32 <span class="title">res</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">x</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (; y != <span class="number">0</span>; y &gt;&gt;= <span class="number">1</span>, x *= x)</span><br><span class="line">      <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个是计算 <span class="math inline">\(5\cdot 10^7!\mod
998244353\)</span> 在 duck.ac 上的测试结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Naive Mod      : 213689172  Time: 180649</span><br><span class="line">My Montgomery  : 213689172  Time: 178217</span><br><span class="line">His Montgomery : 213689172  Time: 152847</span><br></pre></td></tr></table></figure>
<p>这个是计算 <span class="math inline">\(7\cdot 10^7!\mod
998244353\)</span> 在 duck.ac 上的测试结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Naive Mod      : 939830261  Time: 252908</span><br><span class="line">My Montgomery  : 939830261  Time: 249476</span><br><span class="line">His Montgomery : 939830261  Time: 213986</span><br></pre></td></tr></table></figure>
<p>还可以看Min25博客里下面的ModInt64板本</p>
<p><a
href="https://min-25.hatenablog.com/entry/2017/08/20/171214">传送门</a></p>
<p>下面自己实现的<span class="math inline">\(\mod 2m\)</span>
版本，差不多也是最终版本了，跑起来和hly1204差不多</p>
<p>静态版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">uint32_t</span> m&gt; <span class="keyword">struct</span> <span class="title class_">Mont2</span>&#123;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="keyword">using</span> u32=<span class="type">uint32_t</span>;</span><br><span class="line">    <span class="keyword">using</span> i32=<span class="type">int32_t</span>;</span><br><span class="line">    <span class="keyword">using</span> u64=<span class="type">uint64_t</span>;</span><br><span class="line">    <span class="keyword">using</span> i64=<span class="type">int64_t</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> u32 m2=m&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> u32 <span class="title">getinv</span><span class="params">()</span></span>&#123;</span><br><span class="line">        u32 inv=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i) inv*=<span class="number">2</span>-inv*m;</span><br><span class="line">        <span class="keyword">return</span> inv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> u32 inv=-<span class="built_in">getinv</span>(),r2=-<span class="built_in">u64</span>(m)%m;</span><br><span class="line">    u32 x;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> u32 <span class="title">reduce</span><span class="params">(u64 x)</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> (x+<span class="built_in">u64</span>(<span class="built_in">u32</span>(x)*inv)*m)&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Mont2</span>()&#123; ; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Mont2</span><span class="params">(i32 x)</span>:x(reduce(u64(x)*r2)) &#123;</span> &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> Mont2&amp; <span class="keyword">operator</span> += (<span class="type">const</span> Mont2 &amp;rhs) &#123; <span class="keyword">return</span> x+=rhs.x-m2,x&gt;=m2&amp;&amp;(x+=m2),*<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> Mont2&amp; <span class="keyword">operator</span> -= (<span class="type">const</span> Mont2 &amp;rhs) &#123; <span class="keyword">return</span> x-=rhs.x,x&gt;=m2&amp;&amp;(x+=m2),*<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> Mont2&amp; <span class="keyword">operator</span> *= (<span class="type">const</span> Mont2 &amp;rhs) &#123; <span class="keyword">return</span> x=<span class="built_in">reduce</span>(<span class="built_in">u64</span>(x)*rhs.x),*<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Mont2 <span class="keyword">operator</span> + (Mont2 x,<span class="type">const</span> Mont2 &amp;y) &#123; <span class="keyword">return</span> x+=y; &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Mont2 <span class="keyword">operator</span> - (Mont2 x,<span class="type">const</span> Mont2 &amp;y) &#123; <span class="keyword">return</span> x-=y; &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> Mont2 <span class="keyword">operator</span> * (Mont2 x,<span class="type">const</span> Mont2 &amp;y) &#123; <span class="keyword">return</span> x*=y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i32 <span class="title">get</span><span class="params">()</span></span>&#123; </span><br><span class="line">        u32 res=<span class="built_in">reduce</span>(x); </span><br><span class="line">        <span class="keyword">return</span> res&gt;=m?res-m:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<p>板子各有优劣.jpg</p>
<p>另外这是 Int_To_Montgomery 加法的速度，<span
class="math inline">\(7\cdot 10^7\)</span> 次加法与类型转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Naive :        : 305907824 80074</span><br><span class="line">My Montgomery  : 305907824 109479</span><br><span class="line">My Montgomery2 : 305907824 99896</span><br><span class="line">His Montgomery : 305907824 117449</span><br></pre></td></tr></table></figure>
<p>动态版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> u32=<span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">using</span> i32=<span class="type">int32_t</span>;</span><br><span class="line"><span class="keyword">using</span> u64=<span class="type">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> i64=<span class="type">int64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32 m,m2,inv,r2,P;</span><br><span class="line"><span class="function">u32 <span class="title">getinv</span><span class="params">()</span></span>&#123;</span><br><span class="line">    u32 inv=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i) inv*=<span class="number">2</span>-inv*m;</span><br><span class="line">    <span class="keyword">return</span> inv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mont</span>&#123;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    u32 x;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">static</span> u32 <span class="title">reduce</span><span class="params">(u64 x)</span></span>&#123; </span><br><span class="line">        u32 y=(x+<span class="built_in">u64</span>(<span class="built_in">u32</span>(x)*inv)*m)&gt;&gt;<span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">i32</span>(y)&lt;<span class="number">0</span>?y+m:y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Mont</span>()&#123; ; &#125;</span><br><span class="line">    <span class="built_in">Mont</span>(i32 x):<span class="built_in">x</span>(<span class="built_in">reduce</span>(<span class="built_in">u64</span>(x)*r2)) &#123; &#125;</span><br><span class="line">    Mont&amp; <span class="keyword">operator</span> += (<span class="type">const</span> Mont &amp;rhs) &#123; <span class="keyword">return</span> x+=rhs.x-m2,<span class="built_in">i32</span>(x)&lt;<span class="number">0</span>&amp;&amp;(x+=m2),*<span class="keyword">this</span>; &#125;</span><br><span class="line">    Mont&amp; <span class="keyword">operator</span> -= (<span class="type">const</span> Mont &amp;rhs) &#123; <span class="keyword">return</span> x-=rhs.x,<span class="built_in">i32</span>(x)&lt;<span class="number">0</span>&amp;&amp;(x+=m2),*<span class="keyword">this</span>; &#125;</span><br><span class="line">    Mont&amp; <span class="keyword">operator</span> *= (<span class="type">const</span> Mont &amp;rhs) &#123; <span class="keyword">return</span> x=<span class="built_in">reduce</span>(<span class="built_in">u64</span>(x)*rhs.x),*<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mont <span class="keyword">operator</span> + (Mont x,<span class="type">const</span> Mont &amp;y) &#123; <span class="keyword">return</span> x+=y; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mont <span class="keyword">operator</span> - (Mont x,<span class="type">const</span> Mont &amp;y) &#123; <span class="keyword">return</span> x-=y; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mont <span class="keyword">operator</span> * (Mont x,<span class="type">const</span> Mont &amp;y) &#123; <span class="keyword">return</span> x*=y; &#125;</span><br><span class="line">    <span class="function">i32 <span class="title">get</span><span class="params">()</span></span>&#123; </span><br><span class="line">        u32 res=<span class="built_in">reduce</span>(x);</span><br><span class="line">        <span class="keyword">return</span> res&gt;=m?res-m:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123; </span><br><span class="line">    ::m=m,m2=m*<span class="number">2</span>;</span><br><span class="line">    inv=-<span class="built_in">getinv</span>();</span><br><span class="line">    r2=-<span class="built_in">u64</span>(m)%m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个动态模板计算 <span class="math inline">\(5\cdot 10^7!\mod
998244353\)</span>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Naive Mod      : 213689172 494061 (稍微修改了一下暴力的细节。。)</span><br><span class="line">My Montgomery2 : 213689172 152849</span><br></pre></td></tr></table></figure>
<p>不得不说 duck.ac 真的很 nb。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/NTT/</url>
    <content><![CDATA[<hr />
<p>title: 'FFT&amp;NTT（以及扩展）' date: 'Sat Aug 12 11:05:23 2023
categories: - oi-notes'</p>
<h1 id="fftntt以及扩展">FFT&amp;NTT（以及扩展）</h1>
<p>预备知识：<a
href="https://www.cnblogs.com/chasedeath/p/13092822.html">用于NTT</a></p>
<p>NTT/FFT其实本质相同，用途是快速求解 <strong>多项式乘积</strong></p>
<h3 id="前言">前言</h3>
<p>FT: 傅里叶变换:</p>
<p>这是一个工程上的概念，可以简述为：一个周期性的信号波段可以用
若干个<strong>正弦曲线</strong> 的带权和表示</p>
<p>DFT: 离散傅里叶变换，这是傅里叶变换在离散情况下的变种</p>
<p>FFT: 快速傅里叶变换</p>
<p>NTT: 快速数论变换</p>
<span id="more"></span>
<h2 id="谈及核心思想">谈及核心思想</h2>
<ol type="1">
<li><strong>单位根</strong>:</li>
</ol>
<p>构造 <span class="math inline">\(\omega_n\)</span> 为 <span
class="math inline">\(n\)</span> 阶单位根(不知道 <span
class="math inline">\(\omega_n\)</span> 的值域)，满足性质 <span
class="math inline">\(\omega_n^n=\omega_n^0=1\)</span>，即在幂次上呈现
<span class="math inline">\(n\)</span> 元循环。</p>
<p>对于 <span class="math inline">\(2|n\)</span> , <span
class="math inline">\(\omega _n^{\frac{n}{2}}=-1\)</span>，</p>
<p>显然 <span class="math inline">\(\omega_n\)</span>
满足一个非常简单的性质：<strong>折半引理</strong> <span
class="math inline">\(\begin{aligned} \forall 2|i\and 2|n ,
\omega_n^i=\omega_{\frac{n}{2}}^{\frac{i}{2}}\end{aligned}\)</span>。</p>
<ol start="2" type="1">
<li><strong>多项式</strong>与<strong>点值式</strong>的转化：</li>
</ol>
<p>一个 <span class="math inline">\(n\)</span> 阶多项式一般的表示就是
<span class="math inline">\(F(x)=\sum_{i=0}^{n-1} a_ix^i\)</span>。</p>
<p>然而，多项式也可以用 <span class="math inline">\(n\)</span>
个<strong>互不相关的</strong>点表示，即 <span
class="math inline">\((x_0,y_0),(x_1,y_1),\cdots,(x_{n-1},y_{n-1})\)</span>，两者可以互相转化。</p>
<p>对于点形式的多项式，在两个多项式求乘积时，同一个 <span
class="math inline">\(x_i\)</span> 对应的 <span
class="math inline">\(y_i\)</span> 可以直接相乘。</p>
<p>FFT / NTT 做多项式卷积的核心过程是：</p>
<p>多项式 <span
class="math inline">\(\stackrel{\text{DFT}}{\Longrightarrow}\)</span>
点值式 <span class="math display">\[\Longrightarrow\]</span>
点值式对应相乘 <span
class="math display">\[\stackrel{\text{IDFT}}{\Longrightarrow}\]</span>
多项式。</p>
<p>而用单位根来构造快速的多项式与点值式的转化，即 <span
class="math inline">\(\text{DFT}/\text{IDFT}\)</span>。</p>
<ol start="3" type="1">
<li><strong>分治思想</strong></li>
</ol>
<p>用于降低多项式与点值式转换的复杂度。</p>
<p><br></p>
<h2 id="fft的单位根">FFT的单位根</h2>
<p><span class="math inline">\((x,y)\)</span> 指复数 <span
class="math inline">\(i=\sqrt{-1},(x,y)=x+yi\)</span>。</p>
<p>基本运算 <span class="math inline">\((x,y)+(a,b)=(x+a,y+b),(x,y)\cdot
(a,b)=(ax-by,ay+bx)\)</span>。</p>
<p>FFT的单位根是: <span class="math inline">\(\omega_n\)</span> = <span
class="math inline">\((cos(\frac{2\pi}{n}),sin(\frac{2\pi}{n}))\)</span>。</p>
<p>而 <span class="math inline">\(\omega _n^i=(cos(\frac{2\pi}{n}\cdot
i),sin(\frac{2\pi}{n}\cdot i))\)</span>
(展开发现就是三角函数求和公式)。</p>
<p>显然满足单位根的性质。</p>
<p>（实际上可以发现，这个说是点值其实就是信号序列的三角函数表示）。</p>
<p><br></p>
<h2 id="ntt">NTT</h2>
<p>相信您已经了解了原根的一些性质， <span
class="math inline">\(\text{NTT}\)</span> 的单位根常用原根构造。</p>
<p><span class="math inline">\(\text{NTT}\)</span>
的单位根实际有较大的局限性，对于质数 <span
class="math inline">\(P\)</span> 只能构造出 <span
class="math inline">\(n|P-1,\omega_n=g^{\frac{P-1}{n}}\)</span>。</p>
<p>计算在模意义下就能满足单位根的性质。</p>
<p>通常我们 <span class="math inline">\(P\)</span> 取 <span
class="math inline">\(998244353\)</span> ， <span
class="math inline">\(2^{23}|(P-1)\)</span> ，它的一个原根是 <span
class="math inline">\(3\)</span>。</p>
<p>实际上，为了满足下面分治需要，构造的模数通常满足 <span
class="math inline">\(P-1=s\cdot 2^t\)</span> 的 <span
class="math inline">\(t\)</span> 较大，这类模数我们常称作 <span
class="math inline">\(\text{NTT}\)</span> 模数。</p>
<p><br></p>
<h2 id="多项式转点值式">多项式转点值式</h2>
<p>接下来我们考虑如何将多项式转化为点值式。</p>
<p>对于点值式，我们构造的点横坐标为 <span
class="math inline">\(x_i=\omega_n^i\)</span>。</p>
<p>具体目标是对于函数 <span class="math inline">\(F(x)\)</span> ，求出在
<span class="math inline">\(x_0,x_1,\cdots ,x_{n-1}\)</span>
上的函数值。</p>
<p>即求出 <span
class="math inline">\(F(x_i)=a_0\omega_n^0+a_1\omega_n^{i}+a_2\omega_n^{2i}+\cdots\)</span>。</p>
<p>接下来就是核心的<strong>分治思想</strong>，注意，这里的分治是子问题<strong>严格等大</strong>的。</p>
<p>对于当前问题，分成两部分子问题求解(实际是可以分成多部分的，但是这个是特殊情况暂时不予讨论)，即求解。</p>
<p>令 <span class="math inline">\(m=\frac{n}{2}\)</span>。</p>
<p><span class="math inline">\(\displaystyle
2|i,G(x_i)=a_0\omega_{m}^0+a_2\omega_{m}^{\frac{i}{2}}+a_4\omega_{m}^{\frac{i}{2}\cdot
2}+\cdots\)</span>。</p>
<p><span class="math inline">\(\displaystyle
2|i,H(x_i)=a_1\omega_{m}^0+a_3\omega_{m}^{\frac{i}{2}}+a_5\omega_{m}^{\frac{i}{2}\cdot
2}+\cdots\)</span>。</p>
<p>更简洁的描述为。</p>
<p><span
class="math inline">\(i&lt;m,G(x_i&#39;)=a_0\omega_{m}^0+a_2\omega_{m}^{i}+a_4\omega_{m}^{2i}+\cdots\)</span></p>
<p><span
class="math inline">\(i&lt;m,H(x_i&#39;)=a_1\omega_{m}^0+a_3\omega_{m}^{i}+a_5\omega_{m}^{2i}+\cdots\)</span></p>
<p>由于 <span class="math inline">\(G(x&#39;_i),H(x&#39;_i)\)</span>
计算的是 <span class="math inline">\([0,m-1]\)</span> 项，而求 <span
class="math inline">\(F(x_i)\)</span> 时用到的是 <span
class="math inline">\(0,2,4,\cdots\)</span> 项，实际需要访问 <span
class="math inline">\(G(x^2_i),H(x^2_i)\)</span></p>
<p>和 <span class="math inline">\(F(x_i)\)</span>
的式子比较，我们得到合并的式子为：</p>
<p><span class="math display">\[
F(x_i)=G(x^2_i)+x_i H(x^2_i)
\]</span> 带入折半引理，实际等价于：</p>
<p><span class="math display">\[
F(x_i)=G(x&#39;_i)+x_i H(x&#39;_i)
\]</span> 注意 <span class="math inline">\(x_i=x&#39;_{i\mod
m}\)</span>。</p>
<p>为了保证复杂度，尽量使得每次分治的子问题都分为两部分，这样的复杂度为
<span class="math inline">\(O(n\log n)\)</span>。</p>
<p>附：实际上，分为 <span class="math inline">\(d\)</span>
个子问题时，每次合并的复杂度为 <span class="math inline">\(O(n\cdot
d)\)</span> ，因此复杂度为 <span class="math inline">\(nd \log_d
n\)</span>。</p>
<p>保证每次分治为两个严格等大的子问题，可以从一开始就把 <span
class="math inline">\(n\)</span> 扩充为 <span
class="math inline">\(2\)</span> 的幂次：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> N=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(N&lt;=n+m) N&lt;&lt;=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>附: <span class="math inline">\(d\)</span> 个子问题时，设子问题答案为
<span class="math inline">\(G_j(x_i)\)</span> ，则合并的式子为：</p>
<p><span class="math display">\[
\begin{aligned}
F(x_i)=\sum_{j=0}^{d-1}x_i^jG_j(x_i^d)=\sum_{i=0}^{d-1}x_i^jG_j(x&#39;_{i\mod
\frac{n}{d}})\end{aligned}
\]</span></p>
<h2 id="点值式转多项式">点值式转多项式</h2>
<p>核心性质：单位根反演 <span
class="math inline">\(\sum_{j=0}^{n-1}\omega_n^{ij}=
\left\{\begin{aligned} \frac{\omega_n^{in}-1}{\omega_n^i-1}=0 &amp;&amp;
i\ne 0\\ n &amp;&amp; i=0\end{aligned} \right.\)</span>。</p>
<p>设点值式对应 <span class="math inline">\(y_i\)</span> 的序列为 <span
class="math inline">\(b_i\)</span>，则 <span
class="math inline">\(n\cdot a_i=\sum_{j=0}^{n-1}\omega_n^{-ij}
b_j\)</span>。</p>
<p>证明如下：</p>
<p><span class="math inline">\(\begin{aligned}
\sum_{j=0}^{n-1}\omega_n^{-ij}b_j=\sum_{j=0}^{n-1}
\omega_n^{-ij}(\sum_{k=0}^{n-1}a_k\omega_n^{jk})\end{aligned}\)</span></p>
<p><span class="math inline">\(\begin{aligned}
\sum_{j=0}^{n-1}\omega_n^{-ij}b_j=
\sum_{k=0}^{n-1}a_k\sum_{j=0}^{n-1}\omega_n^{j(k-i)}
\end{aligned}\)</span></p>
<p>由上面的式子，发现只有 <span class="math inline">\(k-i=0\)</span>
时右边的求和式有值，故上式成立。</p>
<p>因此点值式转多项式直接把系数改为 <span
class="math inline">\(\omega_n^{-i}\)</span> 即可。</p>
<p><br></p>
<p><br></p>
<h2 id="tips">Tips:</h2>
<ol type="1">
<li>由于单位根的循环特性，溢出会直接溢出到本来的式子里</li>
</ol>
<p>因此，如果乘法过后的多项式产生了超过 <span
class="math inline">\(&gt;n\)</span> 的项 <span
class="math inline">\(x^i\)</span> ，会溢出到 <span
class="math inline">\(x^{i\mod n}\)</span>。</p>
<ol start="2" type="1">
<li>点值式并不是不满足除法，只是除法得到的多项式并不一定是一个 <span
class="math inline">\(n\)</span>
元以内的多项式，除了恰好整除的情况，得到的通常是一个无穷级数的式子，如
<span class="math inline">\(\begin{aligned}
\frac{1}{1-x}=\frac{1-x^{\infty}}{1-x}=\sum_{i=0}^{\infty}x^i\end{aligned}\)</span>。</li>
</ol>
<p>真正要求除法，通常是求前 <span class="math inline">\(n\)</span>
项的结果，即需要用到<strong>多项式乘法逆</strong>。</p>
<p><br></p>
<h2 id="代码实现与优化">代码实现与优化</h2>
<p><a href="http://uoj.ac/problem/34">模板题传送门</a></p>
<p>然后我们得到一份优美的代码 （FFT）。</p>
<p>（ <code>Complex</code> 是 C++ 库自带的复数，<code>M_PI</code> 是 C++
自带 <span class="math inline">\(\pi\)</span> 常量）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(<span class="type">int</span> n,Complex *a,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	Complex tmp[N];</span><br><span class="line">	<span class="type">int</span> m=n/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) tmp[i]=a[i&lt;&lt;<span class="number">1</span>],tmp[i+m]=a[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]; <span class="comment">// 按照奇偶分类</span></span><br><span class="line">	<span class="built_in">memcpy</span>(a,tmp,<span class="built_in">sizeof</span>(Complex) * n);</span><br><span class="line">	<span class="built_in">FFT</span>(m,a,f),<span class="built_in">FFT</span>(m,a+m,f); <span class="comment">// 分两半，算g(x),h(x)</span></span><br><span class="line">	<span class="function">Complex <span class="title">w</span><span class="params">(cos(<span class="number">2</span>*M_PI/n),f*sin(<span class="number">2</span>*M_PI/n))</span>,<span class="title">e</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>; <span class="comment">// w=x^1,e=x^i</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) &#123;</span><br><span class="line">		tmp[i]=a[i]+e*a[i+m]; <span class="comment">// f(x_i)=g(x_i)+e*h(x_i)</span></span><br><span class="line">		e=e*w; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,m,n<span class="number">-1</span>) &#123;</span><br><span class="line">		tmp[i]=a[i-m]+e*a[i];</span><br><span class="line">		e=e*w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(a,tmp,<span class="built_in">sizeof</span>(T)*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <span class="math inline">\((\omega_n)^{\frac{n}{2}}=-1\)</span>
，所以还可以简化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">w</span><span class="params">(cos(<span class="number">2</span>*M_PI/n),f*sin(<span class="number">2</span>*M_PI/n))</span>,<span class="title">e</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) &#123;</span><br><span class="line">	tmp[i]=a[i]+e*a[i+m];</span><br><span class="line">	tmp[i+m]=a[i]-e*a[i+m];</span><br><span class="line">	e=e*w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于用了 double，最后输出要取整。</p>
<h3 id="蝴蝶优化">蝴蝶优化</h3>
<p>我们加一点优化，取代递归的分治过程。</p>
<p>可以看到，分治时我们按照 <span class="math inline">\(i \mod
2\)</span> 分成两组，然后继续分。</p>
<p>这个过程中，实际上我们就是将 <span class="math inline">\(i\)</span>
的二进制位前后翻转。</p>
<p>所以我们可以暴力处理出 <span class="math inline">\(i\)</span>
分治底层的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="type">int</span> x=i,s=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;(j&lt;&lt;c)&lt;=n;++j) &#123;</span><br><span class="line">		s=(s&lt;&lt;<span class="number">1</span>)|(x&amp;<span class="number">1</span>);</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125; <span class="comment">// s就是最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也是有 <span class="math inline">\(O(n)\)</span> 处理方法的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> N=<span class="number">1</span>,c=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(N&lt;=n+m) N&lt;&lt;=<span class="number">1</span>,c++;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;c);</span><br></pre></td></tr></table></figure>
<p>（建议自己模拟一下）。</p>
<p>有了这个翻转数组，我们可以直接从分治底层开始解决整个问题，每次合并操作完全相同。</p>
<p>每次分治问题的大小，依次合并每一个子问题区间即可。</p>
<p>为了在一个数组上完成操作，还需要注意合并顺序。</p>
<p>代码解释 <span class="math inline">\(i\)</span> ：分治子问题大小为
<span class="math inline">\(2i\)</span> ， <span
class="math inline">\(l\)</span> :合并区间的左端点为 <span
class="math inline">\(l\)</span> ，右端点为 <span
class="math inline">\(l+2i\)</span> ， <span
class="math inline">\(j\)</span> 枚举合并位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(<span class="type">int</span> n,Complex *a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">Complex <span class="title">w</span><span class="params">(cos(<span class="number">2</span>*M_PI/n),f*sin(<span class="number">2</span>*M_PI/n))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">e</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j,e=e*w) &#123;</span><br><span class="line">                Complex t=a[j+m]*e;   <span class="comment">// a&#x27;[j]=a[j]+e*a[j+m]</span></span><br><span class="line">                                      <span class="comment">// a&#x27;[j+i]=a[j]-e*a[j+m]</span></span><br><span class="line">                a[j+m]=a[j]-t;</span><br><span class="line">                a[j]=a[j]+t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上我们还有更快的写法，就是将 <span
class="math inline">\(\omega_n^i\)</span> 预处理出来。</p>
<p>（注意这个 <span class="math inline">\(\text{FFT}\)</span>
的预处理很考验double精度，不能每次都直接累乘上去，隔几个就要重新调用依次三角函数）。</p>
<p>当然如果自己写复数会更快。</p>
<p><br></p>
<h3 id="关于点值式转多项式的优化">关于点值式转多项式的优化</h3>
<p>由于每次求得点值是 <span
class="math inline">\(\omega_n^{-i}=\omega_n^{n-i}\)</span>。</p>
<p>所以可以直接用 多项式转点值式的函数， 最后把 <span
class="math inline">\([1,n-1]\)</span> 这一段翻转，每个数除掉 <span
class="math inline">\(n\)</span> 即可。</p>
<p><br></p>
<h3 id="对于加减运算取模的优化">对于加减运算取模的优化</h3>
<p>三目运算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a+=b,a=a&gt;=P?a-P:a;</span><br><span class="line">a-=b,a=a&lt;<span class="number">0</span>?a+P:a;</span><br></pre></td></tr></table></figure>
<p>逻辑运算优化（原理是逻辑预算会在第一个确定表达式值的位置停下）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a+=b,((a&gt;=P)&amp;&amp;(a-=P));</span><br><span class="line">a-=b,((a&lt;<span class="number">0</span>)&amp;&amp;(a+=P));</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3
id="关于系数预处理优化以ntt为例">关于系数预处理优化（以NTT为例）</h3>
<p>带入上面已经提到的优化，无预处理系数的 <span
class="math inline">\(\text{NTT}\)</span> 大概是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> w=<span class="built_in">qpow</span>(<span class="number">3</span>,(P<span class="number">-1</span>)/i/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> e=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j,e=<span class="number">1ll</span>*e*w%P) &#123;</span><br><span class="line">                <span class="type">int</span> t=<span class="number">1ll</span>*a[j+i]*e%P;</span><br><span class="line">                a[j+i]=a[j]-t,((a[j+i]&lt;<span class="number">0</span>)&amp;&amp;(a[j+i]+=P));</span><br><span class="line">                a[j]+=t,((a[j]&gt;=P)&amp;&amp;(a[j]-=P));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">        <span class="type">int</span> Inv=<span class="built_in">qpow</span>(n);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=<span class="number">1ll</span>*a[i]*Inv%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种简单的预处理是，每次对于每个分治大小，预处理依次系数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N],e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">    e[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> w=<span class="built_in">qpow</span>(<span class="number">3</span>,(P<span class="number">-1</span>)/i/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;++j) e[j]=<span class="number">1ll</span>*e[j<span class="number">-1</span>]*w%P;</span><br><span class="line">        <span class="comment">//for(int j=i-2;j&gt;=0;j-=2) e[j+1]=1ll*w*(e[j]=e[j&gt;&gt;1])%P;</span></span><br><span class="line">        <span class="comment">//这个版本是沿用上一次预处理的结果，实际(只有)用这种预处理方法可以极大程度上加强FFT的精度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">                <span class="type">int</span> t=<span class="number">1ll</span>*a[j+i]*e[j-l]%P;</span><br><span class="line">                a[j+i]=a[j]-t,((a[j+i]&lt;<span class="number">0</span>)&amp;&amp;(a[j+i]+=P));</span><br><span class="line">                a[j]+=t,((a[j]&gt;=P)&amp;&amp;(a[j]-=P));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">        <span class="type">int</span> Inv=<span class="built_in">qpow</span>(n);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=<span class="number">1ll</span>*a[i]*Inv%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种是在一开始就把所有的系数用一个数组存下来，具体过程可以描述为：</p>
<p>对于每个分治长度 <span class="math inline">\(n\)</span>
，我们只需要访问 <span
class="math inline">\(\omega_n^{0},\omega_n^{1},\cdots,\omega_n^{\frac{n}{2}-1}\)</span>。</p>
<p>那么对于分治长度 <span class="math inline">\(n\)</span> ，我们在
<span class="math inline">\(w\)</span> 数组的第 <span
class="math inline">\(\frac{n}{2}\)</span> ~ <span
class="math inline">\(n-1\)</span> 项依次存储这些值。</p>
<p>优化:我们只需要对于最大的分治长度处理，剩下的部分发现可以直接用折半引理访问得到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> a[N],w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    w[N&gt;&gt;<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">qpow</span>(<span class="number">3</span>,(P<span class="number">-1</span>)/N);</span><br><span class="line">    <span class="built_in">rep</span>(i,(N&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>,N<span class="number">-1</span>) w[i]=<span class="number">1ll</span>*w[i<span class="number">-1</span>]*t%P;</span><br><span class="line">    <span class="built_in">drep</span>(i,(N&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>,<span class="number">1</span>) w[i]=w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> *e=w+i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">                <span class="type">int</span> t=<span class="number">1ll</span>*a[j+i]*e[j-l]%P;</span><br><span class="line">                a[j+i]=a[j]-t,((a[j+i]&lt;<span class="number">0</span>)&amp;&amp;(a[j+i]+=P));</span><br><span class="line">                a[j]+=t,((a[j]&gt;=P)&amp;&amp;(a[j]-=P));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">        <span class="type">int</span> Inv=<span class="built_in">qpow</span>(n);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=<span class="number">1ll</span>*a[i]*Inv%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三份代码在 duck.ac 上的评测结果表明，不预处理系数将近慢一倍。</p>
<p>单组数据来看，预处理系数会慢一点；多组来看，预处理系数会快。实际差距不大，都可以使用。</p>
<p>但是在某些层面来说，下面这份板子才是最好的（适用NTT,FFT且精度较高），不需要预处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N],e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">    e[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> w=<span class="built_in">qpow</span>(<span class="number">3</span>,(P<span class="number">-1</span>)/i/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j-=<span class="number">2</span>) e[j+<span class="number">1</span>]=<span class="number">1ll</span>*w*(e[j]=e[j&gt;&gt;<span class="number">1</span>])%P;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">                <span class="type">int</span> t=<span class="number">1ll</span>*a[j+i]*e[j-l]%P;</span><br><span class="line">                a[j+i]=a[j]-t,((a[j+i]&lt;<span class="number">0</span>)&amp;&amp;(a[j+i]+=P));</span><br><span class="line">                a[j]+=t,((a[j]&gt;=P)&amp;&amp;(a[j]-=P));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">        <span class="type">int</span> Inv=<span class="built_in">qpow</span>(n);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=<span class="number">1ll</span>*a[i]*Inv%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="拓展">拓展</h1>
<h2 id="分治ntt">1. 分治+NTT</h2>
<p>常用于处理多个<strong>计数背包</strong>的快速合并
（实际<strong>无权值01背包</strong>也是可以的）。</p>
<p>我们可以用 NTT <span class="math inline">\(n\log n\)</span>
合并两个大小为 <span class="math inline">\(n\)</span> 的背包。</p>
<p>分治时，每次合并两个分治子问题，总共的时间就是 <span
class="math inline">\(\sum size\log n\)</span>。</p>
<p>每个背包的 <span class="math inline">\(size\)</span> 会被计算 <span
class="math inline">\(\log n\)</span> 次，所以总共复杂度是 <span
class="math inline">\(n \log ^2 n\)</span>。</p>
<p><br></p>
<h2 id="cdqntt">2. CDQ+NTT</h2>
<p><a href="https://www.luogu.com.cn/problem/P4721">模板题传送门</a></p>
<p>对于形如 <span
class="math inline">\(dp_i=\sum_{j=0}^{i-1}dp_jg_{i-j}\)</span> 的 <span
class="math inline">\(dp\)</span> 转移（就是dp转移与差值有关）。</p>
<p>由于求 <span class="math inline">\(dp_i\)</span> 时，需要保证 <span
class="math inline">\(dp_0,dp_1,\cdots,dp_{i-1}\)</span>
才能卷积，这个限制，我们可以用<strong>CDQ分治</strong>解决。</p>
<p>对于当前分治区间 <span class="math inline">\([L,R]\)</span>。</p>
<p>依次考虑 <span class="math inline">\([L,mid]\)</span> 内部转移，
<span class="math inline">\([L,mid]\)</span> 向 <span
class="math inline">\([mid+1,R]\)</span> 的转移(用FFT/NTT解决)， <span
class="math inline">\([mid+1,R]\)</span> 内部转移。</p>
<p>算法流程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(l,r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Solve</span>(l,mid);</span><br><span class="line">    (l,mid)-&gt;(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">Solve</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="mtt任意模数ntt">3. <a
href="https://www.cnblogs.com/chasedeath/p/13498834.html">MTT(任意模数NTT)</a></h2>
<p><br></p>
<h2 id="n-元点值式">4.<a
href="https://www.cnblogs.com/chasedeath/p/13498798.html"><span
class="math inline">\(n\)</span> 元点值式</a></h2>
<p><br></p>
<p>练习建议：</p>
<ol type="1">
<li><p><a
href="https://www.luogu.com.cn/problem/P1919">高精度乘法</a></p></li>
<li><p>简单应用：<a
href="http://acm.hdu.edu.cn/showproblem.php?pid=4609">HDU-4609</a> <a
href="https://www.cnblogs.com/chasedeath/p/12092699.html">题解</a></p></li>
<li><p>卷积构造模板： <a
href="https://www.lydsy.com/JudgeOnline/problem.php?id=3527">BZOJ-3527</a>
<a
href="https://www.cnblogs.com/chasedeath/p/12092699.html">题解</a></p></li>
<li><p>拓展卷积构造：<a
href="http://acm.hdu.edu.cn/showproblem.php?pid=5885">HDU-5885</a> <a
href="https://www.cnblogs.com/chasedeath/p/12097980.html">题解</a></p></li>
<li><p>构造卷积的应用：<a
href="http://acm.hdu.edu.cn/showproblem.php?pid=6061">HDU-6061</a> <a
href="https://www.cnblogs.com/chasedeath/p/12098078.html">题解</a></p></li>
<li><p><span class="math inline">\(CDQ\)</span> 分治+ <span
class="math inline">\(FFT\)</span> ：<a
href="http://acm.hdu.edu.cn/showproblem.php?pid=5730">HDU-5730</a> <a
href="https://www.cnblogs.com/chasedeath/p/12101353.html">题解</a></p></li>
<li><p><span class="math inline">\(CDQ\)</span> +NTT/降次前缀和优化
<span class="math inline">\(dp\)</span> ：<a
href="http://acm.hdu.edu.cn/showproblem.php?pid=5322">HDU-5332</a> <a
href="https://www.cnblogs.com/chasedeath/p/12101410.html">题解</a></p></li>
</ol>
<p>8.容斥+ <span class="math inline">\(MTT\)</span> ：<a
href="http://acm.hdu.edu.cn/showproblem.php?pid=6088">HDU-6088</a> <a
href="https://www.cnblogs.com/chasedeath/p/12101456.html">题解</a></p>
<p>9.图上 <span class="math inline">\(dp\)</span> ：</p>
<p>联通图个数：BZOJ-3456 <a
href="https://www.cnblogs.com/chasedeath/p/12103345.html">题解</a></p>
<p>带环联通图个数：<a
href="http://acm.hdu.edu.cn/showproblem.php?pid=5552">HDU-5552</a> <a
href="https://www.cnblogs.com/chasedeath/p/12103411.html">题解</a></p>
<p>森林数量和带限制森林数量：<a
href="http://acm.hdu.edu.cn/showproblem.php?pid=5279">HDU - 5279</a> <a
href="https://www.cnblogs.com/chasedeath/p/12106476.html">题解</a></p>
<p>10.点分治+FFT：<a
href="https://www.codechef.com/problems/PRIMEDST">CodeChef-PRIMEDST</a>
<a
href="https://www.cnblogs.com/chasedeath/p/12120855.html">题解</a></p>
<p><br></p>
<p><br></p>
<p><br></p>
<h2
id="更多应用和优化参见毛啸2016论文">更多应用和优化参见毛啸2016论文</h2>
<p>（如：两次FFT做卷积，4次FFT做MTT。。。）。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/Nimber/</url>
    <content><![CDATA[<hr />
<p>title: 'Nimber系列略学习笔记' date: 'Sat Aug 12 11:05:23 2023
categories: - oi-notes'</p>
<h1 id="nimber系列略学习笔记">Nimber系列略学习笔记</h1>
<h4 id="前言">前言</h4>
<p><span class="math inline">\(\text{Nim+Number=Nimber}\)</span></p>
<p>基于我们熟悉的博弈问题 <span
class="math inline">\(\text{Nim}\)</span> 问题，我们定义了多 <span
class="math inline">\(\text{Nim}\)</span> 问题的和，即 <span
class="math inline">\(\text{Nim}\)</span> 和</p>
<p>我们知道 <span class="math inline">\(\text{Nim}\)</span>
和就是异或运算，为了构成一个更完整的 <span
class="math inline">\(\text{Number}\)</span> 域，又引入一种新的运算</p>
<p>即 <span class="math inline">\(\text{Nim}\)</span> 积</p>
<p><br></p>
<span id="more"></span>
<h3 id="定义">定义</h3>
<p>对于在 <span class="math inline">\([0,2^{2^m})\)</span>
上的整数，定义两种 <span class="math inline">\(\text{Nim}\)</span>
运算，构成一个封闭的域</p>
<ol type="1">
<li><span class="math inline">\(\text{Nim}\)</span> 和 <span
class="math inline">\(\oplus\)</span>，<span
class="math inline">\(\displaystyle x\oplus y=\text{mex}\{\{a\oplus
y|a&lt;x\}\cup\{x\oplus b|b&lt;y\}\}\)</span></li>
</ol>
<p>其中对于非负整数集合的 <span
class="math inline">\(\text{mex}\)</span>
运算即求不在集合中的最小非负整数</p>
<p>也就是 <span class="math inline">\(\text{Nim}\)</span> 游戏的"和"</p>
<ol start="2" type="1">
<li><span class="math inline">\(\text{Nim}\)</span> 积 <span
class="math inline">\(\otimes\)</span></li>
</ol>
<p>需要先介绍高维 <span class="math inline">\(\text{Nim}\)</span>
游戏</p>
<p>对于一维情况：</p>
<p>数轴上整点处有若干黑点 <span
class="math inline">\(x_i\)</span>，每次操作可以选择一个黑点 <span
class="math inline">\(x_i\)</span>，找到 <span
class="math inline">\(a&lt;x_i\)</span>。</p>
<p>将线段 <span class="math inline">\([a,x_i]\)</span>
两端点的黑白翻转。</p>
<p>对于二维情况：</p>
<p>平面上整点处有若干黑点 <span
class="math inline">\((x_i,y_i)\)</span>，每次选择一个黑点 <span
class="math inline">\((x_i,y_i)\)</span>，找到另一个点 <span
class="math inline">\((a,b),a&lt;x_i,b&lt;y_i\)</span>。</p>
<p>将矩形 <span class="math inline">\((a,b)-(x_i,y_i)\)</span>
四个顶点的颜色翻转。</p>
<p>对于三维情况：</p>
<p>空间上整点处有若干黑点 <span
class="math inline">\((x_i,y_i,z_i)\)</span>，每次选择一个黑点 <span
class="math inline">\((x_i,y_i,z_i)\)</span>，找到另一个点 <span
class="math inline">\((a,b,c),a&lt;x_i,b&lt;y_i,c&lt;z_i\)</span>。</p>
<p>将长方体 <span class="math inline">\((a,b,c)-(x_i,y_i,z_i)\)</span>
八个顶点的颜色翻转。</p>
<p><span class="math inline">\(\vdots\)</span></p>
<p><span class="math inline">\(\text{Nim}\)</span> 积是高维 <span
class="math inline">\(\text{Nim}\)</span>
游戏的降维操作，显然各个维度之间无序，每个黑点之间可以通过 <span
class="math inline">\(\text{Nim}\)</span> 和相加。</p>
<p>由此定义在二维 <span class="math inline">\(\text{Nim}\)</span>
游戏上的 <span class="math inline">\(\text{Nim}\)</span> 积运算。</p>
<p><span class="math inline">\(x\otimes y=\text{mex}\{(a\otimes y)\oplus
(x\otimes b)\oplus(a\otimes b)|a&lt;x,b&lt;y\}\)</span></p>
<p>相较于 <span class="math inline">\(\text{Nim}\)</span> 和，<span
class="math inline">\(\text{Nim}\)</span>
积运算十分复杂，需要若干性质简化运算</p>
<ol type="1">
<li>基础运算律</li>
</ol>
<p><span class="math inline">\(x\otimes 1=x\)</span></p>
<p><span class="math inline">\(x\otimes y=y\otimes x\)</span></p>
<p><span class="math inline">\((x\otimes y)\otimes z=x\otimes (y\otimes
z)\)</span></p>
<ol start="2" type="1">
<li><p><span class="math inline">\(2^{2^n}\otimes
2^{2^m}=\left\{\begin{aligned}2^{2^n+2^m} &amp;&amp; n\ne m\\ 3\cdot
2^{2^n-1} &amp;&amp; n=m\end{aligned}\right.\)</span></p></li>
<li><p><span class="math inline">\(2^{2^n}\otimes x=2^{2^n}\times x\
(x&lt;2^{2^n})\)</span></p></li>
</ol>
<p>对于 <span class="math inline">\(x,y\in
[0,2^{2^m})\)</span>，利用性质3，用减半的方法优化运算，令 <span
class="math inline">\(n=2^{m-1}\)</span></p>
<p><span class="math inline">\(x=a\cdot 2^n+b,y=c\cdot
2^n+d,a,b,c,d\in[0,2^n)\)</span></p>
<p><span class="math inline">\(x\otimes y=(a\otimes 2^n\oplus b)\otimes
(c\otimes 2^n\oplus d)\)</span></p>
<p><span class="math inline">\(=((a\otimes c)\otimes (3\cdot
2^{n-1}))\oplus (2^n\cdot ((a\otimes d)\oplus (b\otimes c))\ ) \oplus
(b\otimes d)\)</span></p>
<p><span class="math inline">\(=((a\otimes c)\otimes (2^{n}\oplus
2^{n-1}))\oplus (2^n\cdot ((a\otimes d)\oplus (b\otimes c))\ ) \oplus
(b\otimes d)\)</span></p>
<p><span class="math inline">\(=((a\otimes c)\otimes 2^{n-1})\oplus
(2^n\cdot ((a\otimes c)\oplus (a\otimes d)\oplus (b\otimes c))\ ) \oplus
(b\otimes d)\)</span></p>
<p><span class="math inline">\(=((a\otimes c)\otimes 2^{n-1})\oplus
(2^n\cdot ((a\oplus b)\otimes (c\oplus d)\oplus (b\otimes d))) \oplus
(b\otimes d)\)</span></p>
<p>由此进行暴力递归需要依次计算 <span class="math inline">\(a\otimes
c,(a\otimes c)\otimes 2^{n-1},b\otimes d,(a\oplus b)\otimes (c\oplus
d)\)</span>。</p>
<p>复杂度为 <span class="math inline">\(O(4^{m})\)</span>，由于 <span
class="math inline">\(2^{n-1}\)</span>。</p>
<p>对于 <span class="math inline">\(2^{32}\)</span> 以内的运算，即 <span
class="math inline">\(m=5\)</span>，看起来已经可以接受?</p>
<p><br></p>
<h3 id="应用原根的优化">应用原根的优化</h3>
<p><span class="math inline">\(\text{Nimber}\)</span>
域内是存在原根的，<span class="math inline">\([0,2^{16})\)</span>
域内最小的原根是 <span class="math inline">\(258\)</span>。</p>
<p>如果预处理出 <span class="math inline">\([0,2^{16})\)</span>
以内所有数的原根指标和乘法表，即可 <span
class="math inline">\(O(1)\)</span> 查询 <span
class="math inline">\([0,2^{16})\)</span> 任意数的 <span
class="math inline">\(\text{Nimber}\)</span> 积。</p>
<p>由此也可以仅通过一次递归计算 <span
class="math inline">\([0,2^{32})\)</span> 域内的 <span
class="math inline">\(\text{Nimber}\)</span> 积。</p>
<p><br></p>
<h3 id="更多运算">更多运算</h3>
<p>对于 <span class="math inline">\([0,2^{2^m})\)</span> 域内的 <span
class="math inline">\(\text{Nimber}\)</span>，由性质 <span
class="math inline">\(x^{2^m}=x\)</span> 导出的运算有</p>
<p><span class="math inline">\(\displaystyle
\frac{1}{x}=x^{2^m-2}\)</span></p>
<p><span class="math inline">\(\sqrt x=x^{2^{m-1}}\)</span></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/Period%20&amp;%20Border/</url>
    <content><![CDATA[<hr />
<p>title: '字符串的Period(周期),Border' date: 'Sat Aug 12 11:05:23 2023
categories: - oi-notes'</p>
<h1 id="字符串的period周期border">字符串的Period(周期),Border</h1>
<p>前置知识：<span class="math inline">\(\text{kmp}\)</span>，<span
class="math inline">\(\text{AC}\)</span> 自动机</p>
<p>约定：字符串 <span class="math inline">\(S\)</span> 的长度为 <span
class="math inline">\(|S|\)</span>，原串的长度为 <span
class="math inline">\(n\)</span>，<span
class="math inline">\([l,r]\)</span> 的子串为 <span
class="math inline">\(S_{l,r}\)</span>，下标从 <span
class="math inline">\(1\)</span> 开始，前缀 <span
class="math inline">\(S_{1,i}=pre_i\)</span>，后缀 <span
class="math inline">\(S_{i,n}=suf_i\)</span>，设<span
class="math inline">\(S\)</span> 的 <span
class="math inline">\(\text{Border}\)</span> 集合为 <span
class="math inline">\(B(S)\)</span>，设最长的 <span
class="math inline">\(\text{Border}\)</span> 为 <span
class="math inline">\(\text{LBorder}\)</span>。</p>
<p><span class="math inline">\(\text{Border}\)</span>:</p>
<p>定义字符串 <span class="math inline">\(S\)</span> 的一个 <span
class="math inline">\(\text{Border}\)</span> 为一个满足 <span
class="math inline">\(pre_i=suf_{n-i+1}\)</span> 的前缀，<span
class="math inline">\(S\)</span> 和 <span
class="math inline">\(\empty\)</span> 也是一个 <span
class="math inline">\(\text{Border}\)</span>。</p>
<p><span class="math inline">\(\text{kmp,AC}\)</span> 自动机的 <span
class="math inline">\(fail\)</span> 指针均指向当前串的 <span
class="math inline">\(\text{LBorder}\)</span>。</p>
<span id="more"></span>
<p><br></p>
<p><span class="math inline">\(\text{Period}\)</span> （周期）:</p>
<p>若 <span class="math inline">\(\exists |T|\in B(S), 2|T|\ge
n\)</span>，则 <span class="math inline">\(S\)</span> 的一个周期是 <span
class="math inline">\(n-|T|+1\)</span>。</p>
<p><span class="math inline">\(\text{Periodicity Lemma}:\)</span></p>
<p>若 <span class="math inline">\(p,q\)</span> 是 <span
class="math inline">\(S\)</span> 的周期，且 <span
class="math inline">\(p+q+\gcd(p,q)\leq |S|\)</span>，则 <span
class="math inline">\(\gcd(p,q)\)</span> 也是 <span
class="math inline">\(|S|\)</span> 的一个周期。</p>
<p><a href="https://zhuanlan.zhihu.com/p/89385360">证明的话</a></p>
<p><br></p>
<p>关于 <span class="math inline">\(\text{Border}\)</span> 的推论：</p>
<ol type="1">
<li><p><span
class="math inline">\(B(S)=B(\text{LBorder})\cup\{S\}\)</span>，</p></li>
<li><p>串 <span class="math inline">\(S\)</span> 的所有 <span
class="math inline">\(\text{Border}\)</span> 长度构成了不超过 <span
class="math inline">\(\log n\)</span> 个等差数列。</p></li>
</ol>
<p>证明：</p>
<p>如果<span class="math inline">\(S\)</span>的<span
class="math inline">\(\text{LBorder}\)</span>，设其为<span
class="math inline">\(T\)</span>满足<span class="math inline">\(2|T|\ge
|S|\)</span>，则所有<span class="math inline">\(R\in B(S),2|R|\ge
|S|\)</span>形成了一个等差数列</p>
<p>参过下面这张图</p>
<figure>
<img src="https://s1.ax1x.com/2020/07/29/aZ5SUJ.png" alt="aZ5SUJ.png" />
<figcaption aria-hidden="true">aZ5SUJ.png</figcaption>
</figure>
<p>则长度为 <span
class="math inline">\(|T|-(|S|-|T|)\)</span>，即标为红色的那一段，它也是原串的一个
<span class="math inline">\(\text{Border}\)</span>。</p>
<p>更简洁的解释是，<span class="math inline">\(S\)</span> 有着长度为
<span class="math inline">\(|S|-|T|\)</span> 的周期。</p>
<p>所以实际上不止是 <span class="math inline">\(2|R|\ge |S|\)</span>
的串，而是所有 <span class="math inline">\(\forall|R|\equiv |S|\pmod
{|S|-|T|}\)</span> 的 <span class="math inline">\(R\)</span> 都是 <span
class="math inline">\(S\)</span> 的 <span
class="math inline">\(\text{Border}\)</span>。</p>
<p>这样的失配过程就可以归纳为：</p>
<p>每次 <span class="math inline">\(mod\)</span> 最短周期 <span
class="math inline">\(|T|-|S|\)</span>，而取模使得长度至少减半，故可以分成<span
class="math inline">\(\log n\)</span> 段等差数列。</p>
<p><span class="math display">\[ \ \]</span></p>
<p>并且任意一段最大项为 <span class="math inline">\(x\)</span>，差为
<span class="math inline">\(d\)</span> 的等差数列，最小项是 <span
class="math inline">\(x\mod d+d\)</span> 。</p>
<p>(<span class="math inline">\(+d\)</span> 是因为在 <span
class="math inline">\(x\mod d+d\)</span> 下一次可能跳的位置 <span
class="math inline">\(&gt;x\mod d\)</span>)</p>
<p><strong>应用</strong>：对于 <span
class="math inline">\(\text{kmp,AC}\)</span>
自动机的字符集过大导致无法存储每种字符的转移，而又有类似可持久化的匹配操作时，</p>
<p>直接暴力跳 <span class="math inline">\(fail\)</span>
会导致复杂度退化，但是可以用等差数列的性质来快速跳。</p>
<p>每次形成等差数列时，周期中失配位置的下一个字符都相同。</p>
<p>故如果在等差数列上失配，可以直接通过对于差值取模快速跳过，以保证复杂度为
<span class="math inline">\(O(\log n)\)</span>。</p>
<p>相比于倍增处理，这样跳常数小，实现简单。</p>
<p>具体看下面的习题代码。</p>
<p>练习模板: <a href="https://www.luogu.com.cn/problem/P5829">Luogu
P5829</a> 求公共 <span
class="math inline">\(\text{Border}\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">enum</span>&#123;N=<span class="number">1000010</span>&#125;;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> _,i,j,nxt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>),i=<span class="number">2</span>;s[i];++i)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j &amp;&amp; s[i]!=s[j+<span class="number">1</span>]) j=nxt[j];</span><br><span class="line">		<span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>]) j++;</span><br><span class="line">		nxt[i]=j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);_--;)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;i,&amp;j),i=nxt[i],j=nxt[j];i!=j;)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(i,j);</span><br><span class="line">			<span class="keyword">if</span>(nxt[i]&gt;i/<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 产生等差数列，快速跳过</span></span><br><span class="line">				<span class="type">int</span> d=i-nxt[i];</span><br><span class="line">				<span class="keyword">if</span>(j%d==i%d) i=j;</span><br><span class="line">				<span class="keyword">else</span> i=i%d+d;</span><br><span class="line">			&#125; <span class="keyword">else</span> i=nxt[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Stirling数小记</title>
    <url>/oi-notes/Stirling%20%E6%95%B0%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<hr />
<h3 id="定义组合意义">定义/组合意义</h3>
<p>第一类斯特林数：<span class="math inline">\(\begin{bmatrix}n\\
m\end{bmatrix}\)</span> 表示 <span class="math inline">\(n\)</span>
个不同元素分为 <span class="math inline">\(m\)</span>
个圆排列的方案数。</p>
<p>有标号的第一类斯特林数 <span
class="math inline">\(s(n,m)=(-1)^{n-m}\begin{bmatrix}n\\
m\end{bmatrix}\)</span>。</p>
<p>第二类斯特林数：<span class="math inline">\(\begin{Bmatrix}n\\
m\end{Bmatrix}\)</span> 表示 <span class="math inline">\(n\)</span>
个不同元素分为 <span class="math inline">\(m\)</span>
个集合的方案数。</p>
<p>注意圆排列和集合都是相互之间无序的。</p>
<p><br></p>
<hr />
<h3 id="递推方法">递推方法</h3>
<p>第一类斯特林数</p>
<p><span class="math inline">\(\begin{bmatrix}n\\
m\end{bmatrix}=\begin{bmatrix}n-1\\
m-1\end{bmatrix}+(n-1)\begin{bmatrix}n-1\\ m\end{bmatrix}\)</span></p>
<p>即新建一个圆排列，或者插入前面 <span
class="math inline">\(n-1\)</span> 个元素中任意一个的后面。</p>
<p>显然的，有标号的第一类斯特林数递推式就是：</p>
<p><span class="math inline">\(\begin{bmatrix}n\\
m\end{bmatrix}=\begin{bmatrix}n-1\\
m-1\end{bmatrix}-(n-1)\begin{bmatrix}n-1\\ m\end{bmatrix}\)</span></p>
<p><br></p>
<p>第二类斯特林数：</p>
<p><span class="math inline">\(\begin{Bmatrix}n\\
m\end{Bmatrix}=\begin{Bmatrix}n-1\\
m-1\end{Bmatrix}+m\begin{Bmatrix}n-1\\ m\end{Bmatrix}\)</span></p>
<p>即新建一个集合，或者加入前面的 <span class="math inline">\(m\)</span>
个集合。</p>
<p><br></p>
<hr />
<h3 id="第二类斯特林数的通项公式">第二类斯特林数的通项公式</h3>
<p><span class="math inline">\(\begin{aligned} \begin{Bmatrix} n \\ m
\end{Bmatrix}=\frac{1}{m!}\sum_{i=0}^{\infty} (-1)^{m-i}\binom{m}{i} i^n
\end{aligned}\)</span></p>
<p>其组合意义是枚举生成了多少个有序的集合，然后容斥，最后除去集合的顺序。</p>
<p><br></p>
<hr />
<h3 id="生成函数表示与行列求解">生成函数表示与行/列求解</h3>
<p>固定 <span class="math inline">\(n\)</span>，以 <span
class="math inline">\(m\)</span>
为形式幂指数，则第一类斯特林数的普通生成函数：</p>
<p><span
class="math inline">\(\displaystyle\text{OGF}=\prod_{i=0}^{n-1}(x+i)=x^{\overline{n}}\)</span></p>
<p>（其意义就是上面的递推公式）</p>
<p>倍增 + 卷积二项展开求出 <span class="math inline">\(F(x+i)\)</span>
即可做到 <span class="math inline">\(O(n\log n)\)</span> 求出一行。</p>
<p><br></p>
<p>固定 <span class="math inline">\(m\)</span>，以 <span
class="math inline">\(n\)</span>
为形式幂指数，则第一类斯特林数的指数型生成函数。</p>
<p><span class="math inline">\(\begin{aligned}\text{EGF}= &amp;
\frac{1}{m!}\cdot (\sum_{i=1}^{\infty}\frac{(i-1)!}{i!}x^i)^m\\= &amp;
\frac{1}{m!}\cdot
(\sum_{i=1}^{\infty}\frac{x^i}{i})^m\end{aligned}\)</span></p>
<p>设 <span
class="math inline">\(F(x)=\sum_{i=1}^{\infty}\frac{x^i}{i}\)</span>。</p>
<p><span class="math inline">\(\begin{aligned} \because
F&#39;(x)=&amp;\sum_{i=1}^{\infty}x^{i-1}=\frac{1}{1-x}\end{aligned}\)</span></p>
<p><span class="math inline">\(\begin{aligned} \therefore F(x)=\int
\frac{1}{1-x}=-\ln(1-x)\end{aligned}\)</span></p>
<p><span class="math inline">\(\begin{aligned}\therefore \text{EGF} =
&amp; \frac{1}{m!}\cdot (-\ln(1-x))^m\\= &amp; \frac{1}{m!}\cdot
(-1)^m\cdot \ln^m(1-x)\end{aligned}\)</span></p>
<p>（就是百度百科上的那个，它什么都没讲清楚）</p>
<p>多项式快速幂即可做到 <span class="math inline">\(O(n\log n-n\log
^2n)\)</span> 求一列。</p>
<p><br></p>
<p>而在上式的推导过程中额外加入 <span
class="math inline">\((-1)^m\)</span> 的常数，并且把 <span
class="math inline">\(x^i\)</span> 换成 <span
class="math inline">\((-x)^i\)</span>
可以得到有标号第一类斯特林数的指数型生成函数：</p>
<p><span class="math inline">\(\begin{aligned} \text{EGF} = &amp;
\frac{1}{m!}\cdot (\sum_{i=1}^{\infty}\frac{(-x)^i}{i})^m\\=&amp;
\frac{1}{m!}\cdot \ln^m(1+x)\end{aligned}\)</span></p>
<p><br></p>
<p>第二类斯特林数的一行可以直接由通项公式做卷积得到。</p>
<p><br></p>
<p>固定 <span class="math inline">\(m\)</span>，以 <span
class="math inline">\(n\)</span>
为形式幂指数，则第二类斯特林数的指数型生成函数表示为：</p>
<p><span class="math inline">\(\begin{aligned} \text{EGF}
&amp;=\frac{1}{m!}({\sum_{i=1}^{\infty} \frac{x^i}{i!}})^m\\
&amp;=\frac{1}{m!}(e^x-1)^m \\ &amp;=\frac{1}{m!}\sum_{i=0}^m (-1)^{m-1}
\binom{m}{i}e^{ix}\end{aligned}\)</span></p>
<p>实际上由这个二项展开的形式也可以发现，它就是上面通项公式的生成函数推导。</p>
<p>可以求一列，复杂度为 <span class="math inline">\(O(n\log n-n\log
^2n)\)</span> 常数很大。</p>
<p><span class="math display">\[ \ \]</span></p>
<p>虽然没什么意义，但是还是写一下二元形式：</p>
<p>第一类斯特林数：</p>
<p><span class="math inline">\(\begin{aligned} \text{EGF}=e^{-\ln
(1-x)y}\end{aligned}\)</span></p>
<p>第二类斯特林数：</p>
<p><span
class="math inline">\(\begin{aligned}\text{EGF}=e^{\begin{aligned}(e^x-1)y\end{aligned}}\end{aligned}\)</span></p>
<p>注意元 <span class="math inline">\(x\)</span> 为指数型，<span
class="math inline">\(y\)</span> 是普通型。</p>
<p><span class="math display">\[ \ \]</span></p>
<hr />
<h3
id="斯特林数与幂指数上升幂下降幂">斯特林数与幂指数/上升幂/下降幂</h3>
<p>第一类斯特林数：</p>
<p>上面已经说过 <span
class="math inline">\(\begin{aligned}x^{\overline{n}}=\sum_{i=0}^{n}\begin{bmatrix}n\\i\end{bmatrix}x^i\end{aligned}\)</span>。</p>
<p>同理，用有标号的第一类斯特林数将 <span
class="math inline">\(x^{\underline{n}}\)</span> 展开的式子是：</p>
<p><span
class="math inline">\(\begin{aligned}x^{\underline{n}}=\sum_{i=0}^{n}(-1)^{n-
i}\begin{bmatrix}n\\i\end{bmatrix}x^i\end{aligned}\)</span></p>
<p><br></p>
<p>第二类斯特林数：</p>
<p>类似通项公式的求解，组合意义将幂指数展开，视 <span
class="math inline">\(x^n\)</span> 为将 <span
class="math inline">\(n\)</span> 个元素随意放在 <span
class="math inline">\(x\)</span> 个位置，则枚举 <span
class="math inline">\(x\)</span> 个位置中哪些被选择。</p>
<p><span class="math inline">\(\displaystyle x^n=\sum_{i=0}^n
\binom{x}{i}i!\begin{Bmatrix}n\\i\end{Bmatrix}\)</span></p>
<p>把 <span class="math inline">\(\binom{x}{i}i!\)</span>
写成下降幂的形式，得到优美的式子</p>
<p><span class="math inline">\(\displaystyle x^n=\sum_{i=0}^n
\begin{Bmatrix}n\\i\end{Bmatrix}x^{\underline{i}}\)</span></p>
<p><br></p>
<p>而实际上由上式二项反演也可以得到通项公式</p>
<p><span class="math inline">\(\displaystyle \begin{Bmatrix} n \\ m
\end{Bmatrix}=\frac{1}{m!}\sum_{i=0}^{\infty} (-1)^{m-i}\binom{m}{i}
i^n\)</span></p>
<p>关于下降幂多项式的快速转化，可以再借鉴<a
href="https://www.cnblogs.com/chasedeath/p/13073206.html">这个</a></p>
<p><br></p>
<hr />
<h3 id="斯特林变换斯特林反演">斯特林变换/斯特林反演</h3>
<p>对于斯特林变换 <span class="math inline">\(\displaystyle
a_n=\sum_{i=0}^n\begin{Bmatrix}n\\i\end{Bmatrix}b_i\)</span></p>
<p>设 <span class="math inline">\(A(x),B(x)\)</span> 为数列 <span
class="math inline">\(a,b\)</span>
的指数型生成函数，带入前文推导的式子，则得到上式的生成函数表达就是</p>
<p><span class="math inline">\(A(x)=B(e^x-1)\)</span>。</p>
<p>显然得到 <span class="math inline">\(B(x)=A(\ln(x+1))\)</span>，而
<span class="math inline">\(\ln(x+1)\)</span>
显然转化为有标号的第一类斯特林数。</p>
<p>因此得到斯特林反演的表达形式是：</p>
<p><span
class="math inline">\(\begin{aligned}b_n=\sum_{i=0}^{n}(-1)^{n-i}\begin{bmatrix}n\\i\end{bmatrix}a_i\end{aligned}\)</span></p>
<p><del>(不大可能搞类似多项式复合的方法处理这个反演吧，最多可能也就是求一个位置)</del></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%5B%E6%B0%B4%5D%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E7%A7%AF/</url>
    <content><![CDATA[<hr />
<p>title: '[水]整数拆分积' date: 'Sat Aug 12 11:05:23 2023 categories: -
oi-notes'</p>
<h1 id="水整数拆分积">[水]整数拆分积</h1>
<p>问题：对于 <span class="math inline">\(n(n\ge
3)\)</span>，要求构造拆分 <span class="math inline">\(n=\sum_{i=1}^m
a_i\)</span>，最大化 <span class="math inline">\(\prod
a_i\)</span>。</p>
<p>最优情况下，满足</p>
<ol type="1">
<li><p><span class="math inline">\(n\mod 3=0\)</span>，<span
class="math inline">\(a_i=3\)</span>。</p></li>
<li><p><span class="math inline">\(n\mod 3=2\)</span>，<span
class="math inline">\(i&lt;m,a_i=3 ; a_m=2\)</span>。</p></li>
<li><p><span class="math inline">\(n\mod 3=1\)</span>，<span
class="math inline">\(i&lt;m,a_i=3 ; a_m=4\)</span> 或 <span
class="math inline">\(i&lt;m-1,a_i=3 ;a_{m-1}=a_m=2\)</span>。</p></li>
</ol>
<span id="more"></span>
<p>容易发现 <span class="math inline">\(a_i=2,a_i=4\)</span>
的都是边界情况，我们只需要分析为何 <span
class="math inline">\(a_i=3\)</span> 能够最大化答案。</p>
<p>考虑由高维均值不等式 <span class="math inline">\(\displaystyle
\sqrt[m]{\prod a_i}\leq \frac{\sum a_i}{m}\)</span>，<span
class="math inline">\(\displaystyle \prod a_i\leq (\frac{\sum
a_i}{m})^m\)</span>。</p>
<p>故知在 <span class="math inline">\(a_i\)</span>
尽量平均时取到最值，现在只需分析<span
class="math inline">\(a_i=x\)</span>在何时取到最值。</p>
<p>不妨用一个函数 <span
class="math inline">\(g(x)=x^{\frac{n}{x}}\)</span> 来描述问题，</p>
<p>由于上标中的 <span class="math inline">\(n\)</span>
不影响单调性，不妨分析 <span class="math inline">\(\displaystyle
f(x)=g^{\frac{1}{n}}(x)=x^{\frac{1}{x}}\)</span>。</p>
<p><span class="math display">\[
\begin{aligned}
f(x)&amp;=e^{\frac{\ln x}{x}}
\\
f&#39;(x)&amp;=e^{\frac{\ln x}{x}}\cdot \frac{1-\ln x}{x^2}
\end{aligned}
\]</span></p>
<p>容易发现 <span class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\(x_0=e\)</span> 处取极大值。</p>
<p>由于 <span class="math inline">\(x&#39;\in \Z\)</span>，带入 <span
class="math inline">\(f(2)\approx 1.414,f(3)\approx 1.442\)</span>。</p>
<p>故取 <span class="math inline">\(a_i=3\)</span>。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E4%B8%89%E5%85%83%E7%8E%AF%20-%20%E5%9B%9B%E5%85%83%E7%8E%AF%20/</url>
    <content><![CDATA[<hr />
<p>title: '无向图的 三元环 - 四元环 计数' date: 'Sat Aug 12 11:05:23
2023 categories: - oi-notes'</p>
<h1 id="无向图的-三元环---四元环-计数">无向图的 三元环 - 四元环
计数</h1>
<p>问题描述：</p>
<p>给定一个 <span class="math inline">\(n\)</span> 个点 <span
class="math inline">\(m\)</span> 条边的无向图，统计其中三元环 /
四元环的个数。</p>
<span id="more"></span>
<h3 id="三元环">三元环</h3>
<p>考虑枚举一条边 <span
class="math inline">\((u,v)\)</span>，为了避免重复我们可能令 <span
class="math inline">\(u&lt;v\)</span>。</p>
<p>然后暴力枚举求出 <span class="math inline">\(u,v\)</span>
两个点出边的交点个数。</p>
<p>具体的，先对于 <span class="math inline">\(u\)</span>
的出点打标记，然后查询 <span class="math inline">\(v\)</span>
的出点中被标记的个数。</p>
<p>tips: 当然每个三元环会被算三次</p>
<p>这样复杂度显然是 <span class="math inline">\(O(nm)\)</span> 的，当
<span class="math inline">\(v\)</span> 点度数大时就可以卡掉。</p>
<h4 id="优化">优化</h4>
<p>强制 <span class="math inline">\(deg_u&gt;deg_v\or
deg_u=deg_v,u&lt;v\)</span>。</p>
<p>考虑先固定 <span
class="math inline">\(u\)</span>，预处理出标记情况，然后枚举每个合法的
<span class="math inline">\((u,v)\)</span>，再去枚举 <span
class="math inline">\(v\)</span> 的出边。</p>
<p>考虑证明这个复杂度上限为 <span class="math inline">\(O(m\sqrt
m)\)</span> 级别。</p>
<p>假设对于 <span class="math inline">\((u,v)\)</span>：</p>
<p>1.如果 <span class="math inline">\(deg_v\leq \sqrt
m\)</span>，显然它们被枚举的次数总和 <span class="math inline">\(\leq
m\)</span>，枚举复杂度为 <span class="math inline">\(O(m\sqrt
m)\)</span>。</p>
<p>2.对于 <span class="math inline">\(deg_v&gt;\sqrt
m\)</span>，则显然有 <span class="math inline">\(deg_u\ge deg_v&gt;\sqrt
m\)</span>。</p>
<p>会枚举到 <span class="math inline">\(v\)</span> 的 <span
class="math inline">\(u\)</span> 显然不超过 <span
class="math inline">\(\sqrt m\)</span> 个，因此这样的 <span
class="math inline">\(v\)</span> 遍历次数为 <span
class="math inline">\(O(m\sqrt m)\)</span>。</p>
<p>故复杂度为 <span class="math inline">\(O(m\sqrt m)\)</span>。</p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="四元环">四元环</h3>
<p>类似三元环的方法，同样按照 <span
class="math inline">\((deg_u,u)\)</span> 二元组递减的顺序设定排名。</p>
<p>强制 <span class="math inline">\(u\)</span>
为四元环中排名最小的点，枚举合法的边 <span
class="math inline">\((u,v)\)</span>，那么我们计算的实际上是每个 <span
class="math inline">\(v\)</span> 的出边的交的个数。</p>
<p>依次枚举每个 <span class="math inline">\(v\)</span>
的过程中，对于出边 <span class="math inline">\((v,w)\)</span> 维护 <span
class="math inline">\(w\)</span> 出现次数，即可求出交点个数。</p>
<p>容易发现这样的计算不会出现重复。</p>
<p>而复杂显然是与上面相同的，还去掉对于 <span
class="math inline">\(u\)</span> 的出点打标记的过程。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/k%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<hr />
<p>title: 'k短路' date: 'Sat Aug 12 11:05:23 2023 categories: -
oi-notes'</p>
<h1 id="k短路">k短路</h1>
<p><del>好像是一个比较简单的东西</del></p>
<p>对于 <strong>正权有向图</strong>，<span
class="math inline">\(\displaystyle
G=(V,E),V=\{V_i\}_{i=1}^nE=\{(u_i,v_i,w_i)\}_{i=1}^m\)</span>，求 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 的前 <span
class="math inline">\(k\)</span> 短路。</p>
<p>考虑建立反图 <span
class="math inline">\(G&#39;=(V,E&#39;)\)</span>，容易 <span
class="math inline">\(\text{Dijkstra}\)</span> 求得 <span
class="math inline">\(t\)</span> 的单源最短路 <span
class="math inline">\(dis_i\)</span>，并且建立一棵<strong>最短路树</strong>。</p>
<span id="more"></span>
<p>考虑 <span class="math inline">\(s\rightarrow t\)</span>
的最短路，一定是走了一些树边和非树边。</p>
<p>选择一条非树边 <span class="math inline">\((u,v,w)\)</span>
会使长度增加 <span
class="math inline">\(w&#39;=w-(dis_u-dis_v)\)</span>，称 <span
class="math inline">\(w&#39;\)</span> 为额外长度。</p>
<p>考虑我们选择的非树边序列 <span
class="math inline">\((u_i,v_i,w_i)\)</span>，显然有：<span
class="math inline">\(u_{i+1}\)</span> 是 <span
class="math inline">\(v_i\)</span> 在最短路树上的祖先。</p>
<p>考虑用搜索扩展的方式来遍历所有路径情况。</p>
<p>记录当前的节点 <span class="math inline">\(u\)</span>，产生的额外长度
<span class="math inline">\(d\)</span>，则每次的扩展可以归纳为。</p>
<ol type="1">
<li><p>从 <span class="math inline">\(u\)</span> 所有祖先中取出边的集合
<span class="math inline">\(S_u\)</span>。</p></li>
<li><p>依次遍历 <span class="math inline">\(S_u\)</span> 中的所有边
<span class="math inline">\((u_i,v_i,w&#39;_i)\)</span>，进入递归 <span
class="math inline">\(u&#39;=v_i,d&#39;=d+w&#39;_i\)</span>.</p></li>
</ol>
<p>每次扩展会产生一个新的状态，且恰好可以遍历每一个状态一次.</p>
<p><br></p>
<p>然而，为了求出前 <span class="math inline">\(k\)</span>
短路，我们必须按照答案从小到大遍历。</p>
<p>那么我们首先需要将集合 <span class="math inline">\(S_u\)</span>
排序，从小到大遍历，其次要对于不同的递归情况按照大小扩展。</p>
<p>容易想到用一个堆维护扩展的顺序，为了保存遍历 <span
class="math inline">\(S_u\)</span> 集合的过程，记录一个指针 <span
class="math inline">\(p\)</span>。</p>
<p>此时，用堆维护扩展的方法显然：</p>
<ol type="1">
<li><p>取出堆顶状态 <span
class="math inline">\((u,d,p)\)</span>，</p></li>
<li><p>转移：</p>
<ol type="1">
<li><p>在当前递归栈中移动 <span class="math inline">\(p\leftarrow
p+1\)</span>，改变 <span class="math inline">\(d\)</span>，</p></li>
<li><p>模拟上面，建立新的递归栈，同时令指针为<span
class="math inline">\(0\)</span>。</p></li>
</ol></li>
</ol>
<p>得到 <span
class="math inline">\(u&#39;=v_{u,p},d&#39;=d+w&#39;_{v,0},p&#39;=0\)</span>。</p>
<p>如果暴力处理出 <span
class="math inline">\(S_u\)</span>，则预处理复杂度为 <span
class="math inline">\(O(nm\log m)\)</span>，状态扩展复杂度为 <span
class="math inline">\(O(2k\log k)\)</span>。</p>
<p>用可持久化可并堆处理 <span class="math inline">\(S_u\)</span>，<span
class="math inline">\(p\)</span> 记录当前堆顶节点指针。</p>
<p>每次扩展 <span class="math inline">\(p\leftarrow lson_p\)</span> 或者
<span class="math inline">\(p\leftarrow
rson_p\)</span>，增加一个扩展状态。</p>
<p>则预处理复杂度以及空间复杂度为<span class="math inline">\(O(m\log
m)\)</span>，状态扩展复杂度为 <span class="math inline">\(O(3k\log
k)\)</span>。</p>
<p><a href="https://www.luogu.com.cn/problem/P2483">Luogu P2483</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-7</span>,INF=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T val;</span><br><span class="line">	<span class="type">int</span> h;</span><br><span class="line">	Heap *ls,*rs;</span><br><span class="line">	<span class="function">T <span class="title">top</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">	<span class="built_in">Heap</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Heap</span>(Heap *x):<span class="built_in">val</span>(x-&gt;val),<span class="built_in">h</span>(x-&gt;h),<span class="built_in">ls</span>(x-&gt;ls),<span class="built_in">rs</span>(x-&gt;rs)&#123; ; &#125;</span><br><span class="line">	<span class="built_in">Heap</span>(T val):<span class="built_in">val</span>(val),<span class="built_in">h</span>(<span class="number">0</span>),<span class="built_in">ls</span>(<span class="number">0</span>),<span class="built_in">rs</span>(<span class="number">0</span>)&#123; ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> Heap* <span class="title">Union</span><span class="params">(Heap *x,Heap *y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x) <span class="keyword">return</span> y;</span><br><span class="line">		<span class="keyword">if</span>(!y) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">if</span>(y-&gt;val&lt;x-&gt;val) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		Heap* u=<span class="keyword">new</span> <span class="built_in">Heap</span>(x);</span><br><span class="line">		u-&gt;rs=<span class="built_in">Union</span>(u-&gt;rs,y);</span><br><span class="line">		<span class="keyword">if</span>(u-&gt;rs &amp;&amp; (!u-&gt;ls || u-&gt;rs-&gt;h&gt;u-&gt;ls-&gt;h)) <span class="built_in">swap</span>(u-&gt;ls,u-&gt;rs);</span><br><span class="line">		u-&gt;h=u-&gt;rs?u-&gt;rs-&gt;h+<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Heap* <span class="title">pop</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">Union</span>(ls,rs); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> Heap* <span class="title">push</span><span class="params">(Heap *u,T val)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">Union</span>(u,<span class="keyword">new</span> <span class="built_in">Heap</span>(val)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Heap &lt;Pair&gt; Node;</span><br><span class="line">Node *rt[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to;db w;</span><br><span class="line">	Edge *nxt;</span><br><span class="line">	<span class="built_in">Edge</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="type">int</span> to,db w,Edge* nxt):<span class="built_in">to</span>(to),<span class="built_in">w</span>(w),<span class="built_in">nxt</span>(nxt)&#123; ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Edge *head[N],*pre[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,db w)</span></span>&#123;</span><br><span class="line">	Edge* t=<span class="keyword">new</span> <span class="built_in">Edge</span>(v,w,head[u]);</span><br><span class="line">	head[u]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,fa[N];</span><br><span class="line">db E,dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> priority_queue &lt;Pair,vector&lt;Pair&gt;,greater&lt;Pair&gt;&gt; que;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) dis[i]=INF;</span><br><span class="line">	dis[u]=<span class="number">0</span>,que.<span class="built_in">push</span>(&#123;<span class="number">0</span>,u&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=que.<span class="built_in">top</span>().se;db d=que.<span class="built_in">top</span>().fi; que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(dis[u]&lt;d-eps) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(Edge *i=head[u];i;i=i-&gt;nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v=i-&gt;to;</span><br><span class="line">			<span class="keyword">if</span>(dis[v]&gt;dis[u]+i-&gt;w+eps) pre[v]=i,fa[v]=u,que.<span class="built_in">push</span>(&#123;dis[v]=dis[u]+i-&gt;w,v&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> I[N];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) I[i]=i;</span><br><span class="line">	<span class="built_in">sort</span>(I+<span class="number">1</span>,I+n+<span class="number">1</span>,[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123; <span class="keyword">return</span> dis[x]&lt;dis[y]; &#125;);</span><br><span class="line">	<span class="built_in">rep</span>(u,<span class="number">1</span>,n) &#123;</span><br><span class="line">		<span class="keyword">for</span>(Edge *i=head[u];i;i=i-&gt;nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v=i-&gt;to;</span><br><span class="line">			<span class="keyword">if</span>(pre[v]==i) <span class="keyword">continue</span>;</span><br><span class="line">			rt[v]=<span class="built_in">push</span>(rt[v],<span class="built_in">mp</span>(i-&gt;w-(dis[v]-dis[u]),u));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rt[n]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(j,<span class="number">1</span>,n) &#123;</span><br><span class="line">		<span class="type">int</span> u=I[j];</span><br><span class="line">		rt[u]=<span class="built_in">Union</span>(rt[u],rt[fa[u]]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span>&#123;</span><br><span class="line">	db s;</span><br><span class="line">	Node *rt;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> State &amp;__) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s&gt;__.s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kth_Path</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> priority_queue &lt;State&gt; que;</span><br><span class="line">	<span class="keyword">if</span>(dis[<span class="number">1</span>]&gt;E+eps) <span class="keyword">return</span> <span class="built_in">void</span>(<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>));</span><br><span class="line">	ans=<span class="number">1</span>,E-=dis[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(rt[<span class="number">1</span>]) que.<span class="built_in">push</span>(&#123;dis[<span class="number">1</span>]+rt[<span class="number">1</span>]-&gt;val.fi,rt[<span class="number">1</span>]&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		State u=que.<span class="built_in">top</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(u.s&gt;E+eps) <span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> v=u.rt-&gt;val.se;</span><br><span class="line">		ans++,E-=u.s;</span><br><span class="line">		<span class="keyword">if</span>(rt[v]) que.<span class="built_in">push</span>(&#123;u.s+rt[v]-&gt;<span class="built_in">top</span>().fi,rt[v]&#125;);</span><br><span class="line">		u.s-=u.rt-&gt;val.fi;</span><br><span class="line">		<span class="keyword">if</span>(u.rt-&gt;ls) &#123;</span><br><span class="line">			Pair w=u.rt-&gt;ls-&gt;val;</span><br><span class="line">			que.<span class="built_in">push</span>(&#123;u.s+w.fi,u.rt-&gt;ls&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(u.rt-&gt;rs) &#123;</span><br><span class="line">			Pair w=u.rt-&gt;rs-&gt;val;</span><br><span class="line">			que.<span class="built_in">push</span>(&#123;u.s+w.fi,u.rt-&gt;rs&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;E);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>();db w; <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;w);</span><br><span class="line">		<span class="built_in">AddEdge</span>(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Dijkstra</span>(n);</span><br><span class="line">	<span class="built_in">Construct</span>();</span><br><span class="line">	<span class="built_in">Kth_Path</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>下降幂多项式的运算</title>
    <url>/oi-notes/%E4%B8%8B%E9%99%8D%E5%B9%82%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<hr />
<h2 id="下降幂的定义">下降幂的定义</h2>
<p>下降幂 <span class="math inline">\(\text{Falling
Factorial}\)</span>。</p>
<p>下降幂多项式 <span class="math inline">\(\text{Falling Factorial
Polynomial}\)</span> 下面简称 <span
class="math inline">\(\text{FFP}\)</span>。</p>
<p><span class="math inline">\(x\)</span> 的 <span
class="math inline">\(n\)</span> 阶下降幂 <span
class="math inline">\(x^{\underline n}=\prod_0^{n-1}(x-i) =
\frac{x!}{(x-n)!}\)</span>。</p>
<p>一个下降幂多项式 <span class="math inline">\(F(x)=\sum
a_ix^{\underline i}\)</span>。</p>
<span id="more"></span>
<p><a
href="https://www.cnblogs.com/chasedeath/p/14049870.html">学习了斯特林数或许对于下降幂的性质能够有所了解</a></p>
<p><br></p>
<p><br></p>
<hr />
<h3 id="快速求解-xunderline-n-的展开形式">快速求解 <span
class="math inline">\(x^{\underline n}\)</span> 的展开形式</h3>
<p><span class="math inline">\(x^{\underline{n}}=x(x-1)\cdots
(x-n+1)\)</span></p>
<p>考虑倍增求解，假设已知 <span
class="math inline">\(F(x)=x^{\underline{n}}\)</span>。</p>
<p>要求 <span
class="math inline">\(G(x)=x^{\underline{2n}}\)</span>。</p>
<p>显然 <span class="math inline">\(G(x)=F(x)F(x-n)\)</span>。</p>
<p>而 <span class="math inline">\(\begin{aligned} F(x-n)=\sum_{i=0}^{n}
[x^i]F(x) \cdot (x-n)^i\end{aligned}\)</span>。</p>
<p>用一次卷积处理这个二项展开即可。</p>
<p>复杂度为 <span class="math inline">\(O(n\log n)\)</span>。</p>
<p><br></p>
<hr />
<h2 id="ffp与其点值的-textegf">FFP与其点值的 <span
class="math inline">\(\text{EGF}\)</span></h2>
<p>点值的 <span class="math inline">\(\text{EGF}\)</span> 为 <span
class="math inline">\(\displaystyle
EGF(F(x))=\sum_0^{\infty}\frac{F(i)x^i }{i!}\)</span>。 <span
class="math display">\[
\begin{aligned}
EGF(F(x))&amp;=\sum_{i=0}^{\infty}\frac{x^i}{i!}\sum_{j=0}^{n}
\frac{i!}{(i-j)!}\cdot F_j
\\
&amp;=\sum_{i=0}^{\infty}x^i \sum_{j=0}^{n} \frac{1}{(i-j)!}\cdot F_j
\end{aligned}
\]</span></p>
<p>换一下顺序： <span class="math display">\[
\begin{aligned}
EGF(F(x))&amp;=\sum_{i=0}^{n} F_i \sum_{j=i}^{\infty}\frac{1}{(j-i)!}
x^j
\\
&amp;=\sum_{i=0}^{n} F_i \cdot x^i \sum_{j=0}^{\infty}\frac{1}{j!} x^j
\\
&amp;=\sum_{i=0}^{n} F_i \cdot x^i e^x
\end{aligned}
\]</span></p>
<p>那么直接和 <span class="math inline">\(e^x\)</span> 卷积就可以得到
<span class="math inline">\(F(x)\)</span> 的 <span
class="math inline">\(\text{EGF}\)</span>。</p>
<p>Tips: <span class="math inline">\(e^x\)</span> 直接带入展开式 <span
class="math inline">\(\displaystyle
e^{ax}=\sum_0^{\infty}\frac{(ax)^i}{i!}\)</span>。</p>
<p>如果要从 <span class="math inline">\(\text{EGF}\)</span> 得到 <span
class="math inline">\(F(x)\)</span>。</p>
<p><span class="math inline">\(\displaystyle EGF(F(x))=\sum_{i=0}^{n}
F_i \cdot x^ie^x\)</span></p>
<p><span class="math inline">\(\displaystyle
F_i=\frac{EGF(F(x))}{x^ie^x}\)</span></p>
<p>那么就直接卷上 <span class="math inline">\(e^{-x}\)</span>
就可以了。</p>
<p>即可以通过简单卷积完成 <span class="math inline">\(\text{FFP}
\Longleftrightarrow \text{EGF}\)</span> 的转化。</p>
<p><br></p>
<hr />
<h2 id="ffp卷积">FFP卷积</h2>
<p>求出 <span
class="math inline">\(\text{EGF}\)</span>，然后点值对应相乘（注意乘完之后要补上一个
<span class="math inline">\(i!\)</span> ），最后再反求 <span
class="math inline">\(F(x)\)</span>。</p>
<p><br></p>
<p><br></p>
<hr />
<p>Tips: 下面的知识恐怕需要先学<a
href="https://www.cnblogs.com/chasedeath/p/13073178.html">多点求值/快速插值</a></p>
<h2 id="多项式转ffp">多项式转FFP</h2>
<p>带入 <span class="math inline">\(0,\cdots n-1\)</span>，多点求值得到
<span class="math inline">\(\text{FFP}\)</span> 点值的 <span
class="math inline">\(EGF\)</span>，然后求得到 <span
class="math inline">\(\text{FFP}\)</span>。</p>
<p><br></p>
<p><br></p>
<hr />
<h2 id="ffp转多项式">FFP转多项式</h2>
<p>求出 <span class="math inline">\(F(x)\)</span> 的 <span
class="math inline">\(EGF\)</span>，然后带入前 <span
class="math inline">\(n\)</span> 项的值，快速插值回来即可。</p>
<p>由于 <span class="math inline">\(x_i\)</span>
是连续的，所以不需要再多点求值求解 <span
class="math inline">\(\prod\frac{1}{x_i-x_j}\)</span>，可以直接阶乘得到。</p>
<p><br></p>
<p><br></p>
<h2 id="关于上升幂">关于上升幂</h2>
<p><span class="math inline">\(x^{\overline
n}=\frac{(x+n-1)!}{(x-1)!}=x(x+1)(x+2)\cdots(x+n-1)\)</span></p>
<p>容易发现的是 <span class="math inline">\(x^{\overline
n}=(-x)(-((-x)-1))(-((-x)-2))\cdots (-(-x-(n-1)))=(-1)^n
(-x)^{\underline{n}}\)</span>.</p>
<p>所以上升幂多项式与普通多项式的转化 可以认为是上面的点值变成了 <span
class="math inline">\(0,-1,\cdots ,-(n-1)\)</span>，奇数项系数取反。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E5%85%B3%E4%BA%8E%E7%89%A9%E5%93%81%E5%A4%A7%E5%B0%8F%E8%BE%83%E5%B0%8F%E7%9A%8401%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<hr />
<p>title: '关于物品大小较小的01背包' date: 'Sat Aug 12 11:05:23 2023
categories: - oi-notes'</p>
<h1 id="关于物品大小较小的01背包">关于物品大小较小的01背包</h1>
<p>设题目给出的物品大小为 <span
class="math inline">\(w_i\)</span>，个数为 <span
class="math inline">\(n\)</span> ,总和为 <span
class="math inline">\(N\)</span>。</p>
<h3 id="前言">前言</h3>
<p>这个东西可能纯粹是乱搞。</p>
<p>发现 WC2020 选课这个题直接被一个错误的写法爆水。</p>
<p>ps: 这个题是大小范围 1~3 ，实际上正解复杂度很高。</p>
<span id="more"></span>
<h3 id="w_iin12"><span class="math inline">\(w_i\in\{1,2\}\)</span></h3>
<p>这个范围的 01背包，实际上可以：</p>
<ol type="1">
<li><p>回撤贪心，从小到大考虑，每次要让总和加一，则决策就是 选一个 1
或者 选一个 2，删掉一个 1</p></li>
<li><p>奇怪的dp? (先放着下面讲)</p></li>
</ol>
<h2 id="w_iin123"><span
class="math inline">\(w_i\in\{1,2,3\}\)</span></h2>
<p>好像是并没有很好的写法的，在 WC2020选课
这道题中，由于求出的背包只需要访问最后 <span
class="math inline">\(L\)</span> 个结果。</p>
<p>配合上面的贪心，先求出 <span
class="math inline">\(w_i\in\{1,2\}\)</span> 的，然后和 3的暴力合并求出
<span class="math inline">\(L\)</span> 个位置的结果，复杂度为 <span
class="math inline">\(O(NL)\)</span>。</p>
<p><br></p>
<p><del>作为乱搞选手</del>，然后想要提一下这个奇怪的dp，</p>
<p>大概可以表达为：</p>
<ol type="1">
<li><p>对于每种权值的物品分别排序，</p></li>
<li><p>每个dp位置记录答案的同时，记录方案在每种权值里选择了几个，</p></li>
<li><p>转移就是考虑每种权值选择剩下的最优的一个。</p></li>
</ol>
<p>实际上，这个 dp 在 <span class="math inline">\(w_i\leq 2\)</span>
时正确性显然，实际原理是与贪心一致的。</p>
<p>而当 <span class="math inline">\(w_i\leq 3\)</span>
时，由于转移不完全，在实际随机数据测试中发现：</p>
<p>(ps:由于比较难搞暴力，所以只有测试<span class="math inline">\(n\leq
1000\)</span>的)</p>
<ol type="1">
<li><p>可能存在一个位置的dp值没有被转移到</p></li>
<li><p>可能存在若干个位置(约 0~1/60 的比率，大部分情况都在 1/200 以下)的
dp值错误</p></li>
</ol>
<p>3.这个错误率在权值值域越小时错误率越低，在值域为10时几乎不会错<del>(雾)</del></p>
<p><br></p>
<p><del>这似乎可以解释为什么WC出题人没有卡掉这个错误的dp，因为真的比较难卡？</del></p>
<p><br></p>
<p>然后尝试了几种乱搞性质的优化，发现</p>
<ol type="1">
<li>每次多枚举几个物品。</li>
</ol>
<p>效果不佳。</p>
<p><br></p>
<ol start="2" type="1">
<li>记录前 <span class="math inline">\(k\)</span> 大不同的 dp
值(实际上，是指通过比较决策是否相同来判断 dp 值是否相同)。</li>
</ol>
<p>当 <span class="math inline">\(w_i\leq 3\)</span> 时，<span
class="math inline">\(k\)</span> 达到
3后几乎不可能错（近万组没锅）。</p>
<p>当 <span class="math inline">\(w_i\leq 4\)</span> 时，<span
class="math inline">\(k\)</span> 达到6后几乎不可能错
（实际还是出现过错误，要想完全正确比较难，但是如果调整到 <span
class="math inline">\(k=11\)</span>
时上千组可能才会有一个位置不一样）。</p>
<p>测试了 <span class="math inline">\(w_i\leq 7\)</span>
左右的情况。</p>
<p>发现想要完全正确很难，但是调整 <span class="math inline">\(k\)</span>
的大小后，总是可以让正确率非常高(然而这个 <span
class="math inline">\(k\)</span> 可能比较大，甚至需要记录几十个)。</p>
<p>并且发现出现错误的位置几乎只有没有被dp到的那一个位置。</p>
<p><br></p>
<ol start="3" type="1">
<li>正反dp!</li>
</ol>
<p>沿用上面的 前 k 大优化，调整参数。</p>
<p>正反 dp 就是再求一次不选 <span class="math inline">\(i\)</span>
个时最小的花费。</p>
<p>然后两边取 max。</p>
<p>这个优化可以大幅提高正确率。</p>
<p><span class="math inline">\(w=3,k=1\)</span> 几乎不会错。</p>
<p><span class="math inline">\(w=4,k=1\)</span> 时上万组错一个，<span
class="math inline">\(k=2\)</span> 几乎不会错。</p>
<p><span class="math inline">\(w=5,k=2\)</span> 几乎不会错。</p>
<p><span class="math inline">\(w=6,k=2\)</span> 5000 组错一个，<span
class="math inline">\(k=3\)</span> 几乎不会错</p>
<p>参数调一下就可以了，不知道上界是多少，测了 <span
class="math inline">\(w=10,k=10\)</span> 看起来问题不大</p>
<p>附一下评测的代码，希望这个问题能够得到神仙的完美解决!</p>
<p>数据生成器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">    T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[N],B[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">GetTickCount</span>());</span><br><span class="line">    <span class="type">int</span> T=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T);</span><br><span class="line">    <span class="type">int</span> R=<span class="number">10</span>,AR=<span class="number">20000000</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="built_in">rand</span>()%<span class="number">1000</span>+<span class="number">1</span>,m=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) A[i]=<span class="built_in">rand</span>()%R+<span class="number">1</span>,B[i]=<span class="built_in">rand</span>()%AR+<span class="number">1</span>,m+=A[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,n,m);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,A[i],B[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化2:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">    T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">//int dp[N*10][12],s[N*10];</span></span><br><span class="line"><span class="type">int</span> A[<span class="number">12</span>][N];</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> D=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">11</span>],s;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> Node __) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">rand</span>()%<span class="number">5</span>==<span class="number">0</span>) <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">10</span>) <span class="keyword">if</span>(dp[i]!=__.dp[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s!=__.s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node __) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s&lt;__.s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        s+=A[x][dp[x]];</span><br><span class="line">        dp[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; dp[N*<span class="number">10</span>][D];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Part2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> dp[N*<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-63</span>,<span class="keyword">sizeof</span> dp),dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">drep</span>(j,m,a[i]) <span class="keyword">if</span>(dp[j-a[i]]&gt;=<span class="number">0</span>) <span class="built_in">cmax</span>(dp[j],dp[j-a[i]]+b[i]);</span><br><span class="line">    <span class="comment">//rep(i,1,m) cmax(s[i],s[i-1]),cmax(dp[i],dp[i-1]);</span></span><br><span class="line">    <span class="comment">//rep(i,0,m) cout&lt;&lt;dp[i]&lt;&lt;&#x27; &#x27;&lt;&lt;s[i]&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) sum+=a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m) <span class="keyword">if</span>(dp[i]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]!=::dp[i][<span class="number">0</span>].s) &#123;</span><br><span class="line">            <span class="comment">//assert(0);</span></span><br><span class="line">            c++;</span><br><span class="line">            cerr&lt;&lt;<span class="string">&quot;#&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;dp[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;::dp[i][<span class="number">0</span>].s&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c) <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;## %d / %d\n&quot;</span>,c,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">        n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,m) <span class="built_in">rep</span>(j,<span class="number">0</span>,D<span class="number">-1</span>) dp[i][j].s=<span class="number">-1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>].s=<span class="number">0</span>;<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">10</span>) dp[<span class="number">0</span>][<span class="number">0</span>].dp[i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">10</span>) A[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            a[i]=<span class="built_in">rd</span>(),b[i]=<span class="built_in">rd</span>();</span><br><span class="line">            A[a[i]][++A[a[i]][<span class="number">0</span>]]=b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">10</span>) <span class="built_in">sort</span>(A[i]+<span class="number">1</span>,A[i]+A[i][<span class="number">0</span>]+<span class="number">1</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="comment">//int ans=0;</span></span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,m) <span class="built_in">rep</span>(j,<span class="number">0</span>,D<span class="number">-1</span>) <span class="keyword">if</span>(~dp[i][j].s) &#123;</span><br><span class="line">            <span class="comment">//if(i &amp;&amp; s[i-1]&gt;s[i]) &#123;</span></span><br><span class="line">            <span class="comment">//s[i]=s[i-1];</span></span><br><span class="line">            <span class="comment">//rep(j,1,10) dp[i][j]=dp[i-1][j];</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="built_in">rep</span>(d,<span class="number">1</span>,<span class="built_in">min</span>(<span class="number">10</span>,m-i)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j].dp[d]&lt;=A[d][<span class="number">0</span>]) &#123;</span><br><span class="line">                    Node t=dp[i][j]; t.<span class="built_in">Add</span>(d);</span><br><span class="line">                    <span class="built_in">rep</span>(k,<span class="number">0</span>,D<span class="number">-1</span>) <span class="keyword">if</span>(~t.s) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i+d][k]&lt;t) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(!k || dp[i+d][k<span class="number">-1</span>]!=t) <span class="built_in">swap</span>(dp[i+d][k],t);</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Part2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化3:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">    T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> A[<span class="number">12</span>][N];</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> D=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">11</span>],s;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> Node __) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">rand</span>()%<span class="number">5</span>==<span class="number">0</span>) <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">10</span>) <span class="keyword">if</span>(dp[i]!=__.dp[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s!=__.s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node __) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s&lt;__.s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        s+=A[x][dp[x]];</span><br><span class="line">        dp[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; dp[N*<span class="number">10</span>][D];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">10</span>) <span class="built_in">sort</span>(A[i]+<span class="number">1</span>,A[i]+A[i][<span class="number">0</span>]+<span class="number">1</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m) <span class="built_in">rep</span>(j,<span class="number">0</span>,D<span class="number">-1</span>) dp[i][j].s=<span class="number">-1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>].s=<span class="number">0</span>;<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">10</span>) dp[<span class="number">0</span>][<span class="number">0</span>].dp[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m) <span class="built_in">rep</span>(j,<span class="number">0</span>,D<span class="number">-1</span>) <span class="keyword">if</span>(~dp[i][j].s) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(d,<span class="number">1</span>,<span class="built_in">min</span>(<span class="number">10</span>,m-i)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j].dp[d]&lt;=A[d][<span class="number">0</span>]) &#123;</span><br><span class="line">                Node t=dp[i][j]; t.<span class="built_in">Add</span>(d);</span><br><span class="line">                <span class="built_in">rep</span>(k,<span class="number">0</span>,D<span class="number">-1</span>) <span class="keyword">if</span>(~t.s) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i+d][k]&lt;t) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!k || dp[i+d][k<span class="number">-1</span>]!=t) <span class="built_in">swap</span>(dp[i+d][k],t);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Formin&#123;</span><br><span class="line">    Node dp[N*<span class="number">10</span>][D];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">10</span>) <span class="built_in">sort</span>(A[i]+<span class="number">1</span>,A[i]+A[i][<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,m) <span class="built_in">rep</span>(j,<span class="number">0</span>,D<span class="number">-1</span>) dp[i][j].s=INF;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>].s=<span class="number">0</span>;<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">10</span>) dp[<span class="number">0</span>][<span class="number">0</span>].dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,m) <span class="built_in">rep</span>(j,<span class="number">0</span>,D<span class="number">-1</span>) <span class="keyword">if</span>(dp[i][j].s!=INF) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(d,<span class="number">1</span>,<span class="built_in">min</span>(<span class="number">10</span>,m-i)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j].dp[d]&lt;=A[d][<span class="number">0</span>]) &#123;</span><br><span class="line">                    Node t=dp[i][j]; t.<span class="built_in">Add</span>(d);</span><br><span class="line">                    <span class="built_in">rep</span>(k,<span class="number">0</span>,D<span class="number">-1</span>) <span class="keyword">if</span>(~t.s) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(t&lt;dp[i+d][k]) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(!k || dp[i+d][k<span class="number">-1</span>]!=t) <span class="built_in">swap</span>(dp[i+d][k],t);</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">10</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,A[i][<span class="number">0</span>]) sum+=A[i][j];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,m) <span class="built_in">cmax</span>(::dp[i][<span class="number">0</span>].s,sum-dp[m-i][<span class="number">0</span>].s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Part2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> dp[N*<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-63</span>,<span class="keyword">sizeof</span> dp),dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">drep</span>(j,m,a[i]) <span class="keyword">if</span>(dp[j-a[i]]&gt;=<span class="number">0</span>) <span class="built_in">cmax</span>(dp[j],dp[j-a[i]]+b[i]);</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) sum+=a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m) <span class="keyword">if</span>(dp[i]&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]!=::dp[i][<span class="number">0</span>].s) &#123;</span><br><span class="line">            <span class="comment">//assert(0);</span></span><br><span class="line">            c++;</span><br><span class="line">            cerr&lt;&lt;<span class="string">&quot;#&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;dp[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;::dp[i][<span class="number">0</span>].s&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c) <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;## %d / %d\n&quot;</span>,c,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">        n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">10</span>) A[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">            a[i]=<span class="built_in">rd</span>(),b[i]=<span class="built_in">rd</span>();</span><br><span class="line">            A[a[i]][++A[a[i]][<span class="number">0</span>]]=b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Work</span>(),Formin::<span class="built_in">Work</span>();</span><br><span class="line">        <span class="built_in">Part2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E5%85%B3%E4%BA%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<hr />
<p>title: '关于生成函数' date: 'Sat Aug 12 11:05:23 2023 categories: -
oi-notes'</p>
<h1 id="关于生成函数">关于生成函数</h1>
<h2 id="基础">基础</h2>
<h3 id="普通生成函数">普通生成函数</h3>
<p>对于数列 <span class="math inline">\(a_i\)</span> ，它的普通生成函数(
<span class="math inline">\(\text{OGF}\)</span> )为 <span
class="math inline">\(A(x)=\sum a_ix^i\)</span>。</p>
<p>这个 <span class="math inline">\(x^i\)</span>
刚开始并没有实际意义，即为形式幂级数，实际这个 <span
class="math inline">\(i\)</span> 甚至可以不是一个整数，如 <span
class="math inline">\(\text{FWT}\)</span> 中的指数为集合幂指数。</p>
<p>普通生成函数常用于解决无序的组合计数问题，如背包问题。</p>
<span id="more"></span>
<h4 id="常见背包的生成函数">常见背包的生成函数</h4>
<p>我们让 <span class="math inline">\(x^i\)</span> 项表示选择了 <span
class="math inline">\(i\)</span> 个物品，则可以构造生成函数。</p>
<p>一个01背包，每一个物品的生成函数为 <span
class="math inline">\(A(x)=x+1\)</span> ，其中 <span
class="math inline">\(x\)</span> 项表示多选了一个，1
项表示空着不选。</p>
<p>同理，对于一个有限背包，每个物品上限 <span
class="math inline">\(m_i\)</span> ，则 <span
class="math inline">\(A_i(x)=\sum_{j=0}^{m_i} x^j\)</span>。</p>
<p>一个完全背包的生成函数为 <span class="math inline">\(\begin{aligned}
A(x)=\sum_{i=0}^{\infty}
x^i=\frac{1-x^{\infty}}{1-x}=\frac{1}{1-x}\end{aligned}\)</span>
（因为我们所求的答案是前若干项，无穷项没有意义）。</p>
<p>那么多个物品的组合就可以通过这些生成函数相乘来轻松表示，因此也容易被多项式的快速运算优化。</p>
<h3 id="用生成函数描述递推关系">用生成函数描述递推关系</h3>
<p>一个最简单的例子，设斐波那契数列的普通生成函数为 <span
class="math inline">\(F(x)\)</span>。</p>
<p>我们知道 <span
class="math inline">\(F_i=F_{i-1}+F_{i-2},F_0=0,F_1=1\)</span>。</p>
<p>则可以用生成函数表示斐波那契数列的递推关系 <span
class="math inline">\(F(x)=x F(x)+x^2 F(x)+x\)</span>。</p>
<p>其中 <span class="math inline">\(xF(x)\)</span> 对应递推式的 <span
class="math inline">\(F_{i-1}\)</span> ， <span
class="math inline">\(x^2F(x)\)</span> 对应递推式的 <span
class="math inline">\(F_{i-2}\)</span> ， <span
class="math inline">\(x\)</span> 对应 <span
class="math inline">\(F_1\)</span> 的值。</p>
<p>类似的问题还包括数列的线性递推，即 <span
class="math inline">\(a_i=\sum b_ja_{i-j}\)</span>
，但是这个求解比较复杂。。。</p>
<p><br></p>
<h4 id="基于概率期望的生成函数">基于概率期望的生成函数</h4>
<p>取自 集训队论文 2018 - 1
浅谈生成函数在掷骰子问题上的应用长沙市长郡中学杨懋龙。</p>
<p>对于随机非负离散变量 <span class="math inline">\(x\)</span>
，令它的概率生成函数是 <span
class="math inline">\(F(z)=\begin{aligned}\sum_{i=0}^{\infty}P(x=i)z^i\end{aligned}\)</span>
，则可以看到这里的指数代表 <span class="math inline">\(x\)</span>
的值。</p>
<p><span class="math inline">\(x\)</span>
的值不一定能够相加，但是利用这个生成函数，可以快速表达期望，方差等，具体见下式：</p>
<ol type="1">
<li><p><span
class="math inline">\(F(1)=\begin{aligned}\sum_{i=0}^{\infty}P(x=i)=1\end{aligned}\)</span></p></li>
<li><p><span
class="math inline">\(F&#39;(1)=\begin{aligned}\sum_{i=0}^{\infty}P(x=i)\cdot
i=E(x)\end{aligned}\)</span></p></li>
<li><p><span
class="math inline">\(E(x^{\underline{k}})=F^{(k)}(1)\)</span> ( <span
class="math inline">\(x\)</span> 的 <span
class="math inline">\(k\)</span> 阶下降幂，( <span
class="math inline">\(k\)</span> )表示 <span
class="math inline">\(k\)</span> 阶导数)</p></li>
<li><p><span class="math inline">\(x\)</span> 的方差 <span
class="math inline">\(=\begin{aligned}\sum_{i=0}^{\infty}P(x=i)\cdot
(i-E(x))^2\end{aligned}=\begin{aligned}\sum_{i=0}^{\infty}P(x=i)\cdot
i^2-2P(x=i)\cdot i\cdot E(x)+P(x=i)\cdot
E^2(x)\end{aligned}\)</span></p></li>
</ol>
<p><span
class="math inline">\(=E(x^2)-2E^2(x)+E^2(x)=E(x^2)-E^2(x)=E(x^{\underline{2}})+E(x)-E^2(x)=F&#39;&#39;(1)+F&#39;(1)-(F&#39;(1))^2\)</span></p>
<p>可以作为导数在生成函数推导中应用的一个例子。</p>
<p><br></p>
<h3 id="指数生成函数">指数生成函数</h3>
<p>对于数列 <span class="math inline">\(a_i\)</span>
，它的指数生成函数（ <span class="math inline">\(\text{EGF}\)</span>）为
<span class="math inline">\(\begin{aligned} A(x)=\sum
\frac{a_ix^i}{i!}\end{aligned}\)</span>。</p>
<p>指数型生成函数是处理有序排列问题的一大利器，因此，指数上的 <span
class="math inline">\(i\)</span> 通常表示个数。</p>
<p>为什么 <span class="math inline">\(\frac{1}{i!}\)</span>
可以简化排列问题，可以参见这样的一个例子。</p>
<p>用若干类物品排成一个排列，每一类有 <span
class="math inline">\(m_i\)</span> 个，则不同的排列个数为 <span
class="math inline">\(\begin{aligned} \frac{(\sum m_i)!}{\prod
m_i!}\end{aligned}\)</span>。</p>
<p>这个式子的意义就是:
假设先随便排列，由于每一类相同，因此类之内的排列都要除掉。</p>
<p>可以看到， <span class="math inline">\(\frac{1}{i!}\)</span>
描述的就是类内的排列，因此最后求得答案项还要乘上 <span
class="math inline">\(n!\)</span>。</p>
<p>如果一类物品任意个数加入排列，则其指数生成函数为 <span
class="math inline">\(\begin{aligned}
A(x)=\sum_{i=0}^{\infty}\frac{x^i}{i!}=e^x\end{aligned}\)</span>。</p>
<p>根据 <span class="math inline">\(e^{-x}=\sum_i
\frac{(-x)^i}{i!}\)</span> ,还能得到：</p>
<p>限制为偶数个的指数生成函数 <span
class="math inline">\(\begin{aligned}
A(x)=\sum_{2|i}^{\infty}\frac{x^i}{i!}=\frac{e^x+e^{-x}}{2}\end{aligned}\)</span>，</p>
<p>限制为奇数个的指数生成函数 <span
class="math inline">\(\begin{aligned}
A(x)=\sum_{2|i}^{\infty}\frac{x^i}{i!}=\frac{e^x-e^{-x}}{2}\end{aligned}\)</span>。</p>
<p>限制为 <span class="math inline">\(n\)</span>
的倍数个，较为复杂，需要用到<a
href="https://www.cnblogs.com/chasedeath/p/13499214.html">单位根反演</a>。</p>
<h4 id="ex-在排列问题叠加上的应用"><span
class="math inline">\(e^{x}\)</span> 在排列问题叠加上的应用</h4>
<p>若有一类等价排列子问题，其指数型生成函数为 <span
class="math inline">\(F(x)\)</span>
，则任意叠加其得到的排列问题指数型生成函数为。</p>
<p><span class="math inline">\(\begin{aligned} \sum_{i=0}^{\infty}
\frac{F^i(x)}{i!}=e^{F(x)}\end{aligned}\)</span> ，其中 <span
class="math inline">\(\frac{1}{i!}\)</span> 表示除去子问题之间等价。</p>
<p><br></p>
<h2 id="更多常用技巧">更多常用技巧</h2>
<ol type="1">
<li><p>分治NTT解决多个多项式卷积问题</p></li>
<li><p>CDQ分治NTT解决有序递推问题</p></li>
</ol>
<p><br></p>
<ol start="3" type="1">
<li><p>推导生成函数的关系</p>
<ol type="1">
<li><p>树的递归关系：</p>
<p>问题：计算合法树的数量，如树上染色问题等。</p>
<p>这一类问题可以表示为 一种递归关系，即 枚举根的状态
加上根的儿子对应的生成函数，</p>
<p>例子 [Codeforces Round #250]小朋友和二叉树 。</p>
<p>设一个点的生成函数为 <span class="math inline">\(G\)</span>
，整棵数的生成函数为 <span class="math inline">\(F\)</span>
，其中幂指数代表权值和，则 <span class="math inline">\(G\)</span>
是我们已知的，且有关系</p>
<p><span class="math inline">\(F=G\cdot F^2+1\)</span> ，其中 <span
class="math inline">\(F^2\)</span> 表示枚举两个子树的状态， <span
class="math inline">\(G\)</span> 表示枚举根的状态， <span
class="math inline">\(+1\)</span> 表示空树。</p>
<p>类似这样的问题还有 <a
href="https://loj.ac/problem/6538">烷基计数加强版加强版</a>
这个方程要用到牛顿迭代求解</p></li>
</ol></li>
<li><p>集合幂指数在处理 01 状态上的应用</p></li>
</ol>
<p>如果用整数指数形式表示的生成函数解决 01 状态上的 or,and,
xor操作。</p>
<p>我们通常需要把这个过程转化为对 <span
class="math inline">\(0,1\)</span> 个数来做。</p>
<p>但是这一类的问题，通常可以用<strong>集合幂指数</strong>轻松表示，前提是你了解
<span class="math inline">\(\text{FWT}\)</span>
卷积三种类型的本质过程。</p>
<p><a href="https://www.cnblogs.com/chasedeath/p/12969126.html">例题
ZJOI 2019开关</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E5%8D%95%E4%BD%8D%E6%A0%B9%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<hr />
<p>title: '单位根反演' date: 'Sat Aug 12 11:05:23 2023 categories: -
oi-notes'</p>
<h1 id="单位根反演">单位根反演</h1>
<p>最基础的用途是用于 FFT 中点值式转多项式。</p>
<p>即对于 <span class="math inline">\(G(i)=F(\omega_n^i)\)</span> ，由
<span class="math inline">\(G(i)\)</span> 反演得到 <span
class="math inline">\([x^i]F(i)\)</span> 的过程，称之为单位根反演。</p>
<p>式子非常简单：</p>
<p><span class="math inline">\(\sum_{j=0}^{n-1}\omega_n^{ij}=
\left\{\begin{aligned} \frac{\omega_n^{in}-1}{\omega_n^i-1}=0 &amp;&amp;
i\ne 0\\ n &amp;&amp; i=0\end{aligned} \right.\)</span>。</p>
<p>更简洁的式子为 <span
class="math inline">\(\begin{aligned}\frac{\sum_{j=0}^{n-1}\omega_n^{ij}}{n}=[n|i]\end{aligned}\)</span>。</p>
<span id="more"></span>
<p>在生成函数的化简与构造中，常用于解决 <span class="math inline">\(\mod
n=0\)</span> 的限制。</p>
<p>如 <span
class="math inline">\(\sum_{n|i}\frac{x^i}{i!}\)</span>。</p>
<p>通过单位根反演转化为：</p>
<p><span class="math display">\[
\sum_{n|i}\frac{x^i}{i!}=\sum_{i=0}^{\infty}\frac{\sum_{j=0}^{n-1}\omega_n^{ij}}{n}
\cdot \frac{x^i}{i!}=\sum_{i=0}^{\infty}\sum_{j=0}^{n-1}
\frac{(x\omega_n^j)^i}{i!}=\sum_{j=0}^{n-1}e^{x\omega_n^j}
\]</span> 作为无穷级数压缩的一种方法。</p>
<p>但是单位根反演转化有一个非常明显的局限，就是在模意义下， <span
class="math inline">\(n\)</span> 阶单位根很可能无法求解。</p>
<p>现在笔者还不会求模意义下特定的 <span class="math inline">\(n\)</span>
阶单位根。。。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<hr />
<p>title: '回文自动机 (PAM,Palindrome Automaton)' date: 'Sat Aug 12
11:05:23 2023 categories: - oi-notes'</p>
<h1 id="回文自动机-pampalindrome-automaton">回文自动机 (PAM,Palindrome
Automaton)</h1>
<p>如果学习了<span class="math inline">\(\text{AC}\)</span>
自动机和后缀自动机（<span
class="math inline">\(\text{SAM}\)</span>），那么这个冷门算法其实非常简单。</p>
<p>约定：原字符串为 <span class="math inline">\(S\)</span>，长度为 <span
class="math inline">\(|S|\)</span>。</p>
<span id="more"></span>
<h3 id="结构介绍">结构介绍</h3>
<p>自动机节点意义： <span class="math inline">\(\text{PAM}\)</span>
没有复杂的结构，每个节点对应了一种回文子串，节点个数 <span
class="math inline">\(\leq |S|+2\)</span>。</p>
<p>自动机的转移：<span class="math inline">\(\text{PAM}\)</span> 和
<span class="math inline">\(\text{AC}\)</span> 自动机一样，有失配指针
<span class="math inline">\(fail\)</span> 和匹配数组 <span
class="math inline">\(nxt\)</span>。</p>
<p><span class="math inline">\(fail_i\)</span> 即是 <span
class="math inline">\(i\)</span> 的后缀的最长状态，<span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(fail_i\)</span>
的边构成了一棵树，但是这棵树有着两个根节点(?)，分别对应着长度为
奇数/偶数 的回文子串。</p>
<p>每个转移 <span class="math inline">\(nxt_{i,j}\)</span>
意味着在当前状态 <span class="math inline">\(i\)</span> 的串两边增加字符
<span class="math inline">\(j\)</span>。</p>
<p>但是由于 <span class="math inline">\(\text{PAM}\)</span>
的构造是一个在线算法，所以如果想要像 <span
class="math inline">\(\text{AC}\)</span> 自动机一样每次转移直接访问
<span class="math inline">\(nxt\)</span>，需要结束后遍历结构。</p>
<h3 id="构造">构造</h3>
<p>为了便于访问，设偶数/奇数根分别为 <span
class="math inline">\(0,1\)</span>，每个节点存储一个当前状态的长度 <span
class="math inline">\(len\)</span>。</p>
<p>特别的，<span
class="math inline">\(len_0=0,len_1=-1\)</span>（便于让所有的串都满足
<span class="math inline">\(len_{nxt_{i,j}}=len_i+2\)</span>）。</p>
<p>同时让空串对应奇数根节点，把偶数根连向奇数，即 <span
class="math inline">\(fail_0=1\)</span>，这样就只有一个根节点了。</p>
<p>为了在线构造方便，<span class="math inline">\(\text{PAM}\)</span>
需要实现一个匹配函数 <span
class="math inline">\(\text{Find}(x,y)\)</span>，即在当前 <span
class="math inline">\(x\)</span> 状态找到下一个位置 <span
class="math inline">\(S_y\)</span> 的匹配状态，如果失配则返回奇数根
<span class="math inline">\(1\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(s[y]!=s[y-len[x]<span class="number">-1</span>]) x=fail[x]; <span class="comment">// 如果失配到了x=1,那么必然有s[y]=s[y]</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加一个节点 <span class="math inline">\(S_i=c\)</span>：</p>
<ol type="1">
<li><p>找到一个最长的匹配，设当前前缀最长的回文后缀对应的状态为 <span
class="math inline">\(now\)</span>，则直接为 <span
class="math inline">\(now\)</span> 匹配 <span
class="math inline">\(S_i\)</span> 即可。</p></li>
<li><p>新建状态（如果当前的回文子串还未出现过）。</p></li>
</ol>
<p>和 <span class="math inline">\(\text{AC}\)</span>
自动机类似，访问<span
class="math inline">\(fail\)</span>树上最近的匹配，即可得到这个点的<span
class="math inline">\(fail\)</span> 值。</p>
<p><strong>需要注意的点是，因为当前节点可以是根节点，寻找 <span
class="math inline">\(fail\)</span> 必须在新建转移 <span
class="math inline">\(nxt_{now,c}\)</span> 之前进行，否则可能找到的
<span class="math inline">\(fail\)</span> 是自己</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Extend</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    now=<span class="built_in">Find</span>(now,i);</span><br><span class="line">    <span class="keyword">if</span>(!nxt[now][c]) &#123;</span><br><span class="line">        fail[++cnt]=nxt[<span class="built_in">Find</span>(fail[now],i)][c];</span><br><span class="line">		len[nxt[now][c]=cnt]=len[now]+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    now=nxt[now][c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Palindrome_Automaton</span>&#123;</span><br><span class="line">	<span class="type">int</span> len[N],fail[N],nxt[N][<span class="number">26</span>],now,cnt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,cnt) <span class="built_in">memset</span>(nxt,fail[i]=<span class="number">0</span>,<span class="number">104</span>);</span><br><span class="line">		s[now=<span class="number">0</span>]=len[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">		fail[<span class="number">0</span>]=fail[<span class="number">1</span>]=cnt=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123; </span><br><span class="line">		<span class="keyword">while</span>(s[y-len[x]<span class="number">-1</span>]!=s[y]) x=fail[x];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Extend</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">		now=<span class="built_in">Find</span>(now,i);</span><br><span class="line">   		<span class="keyword">if</span>(!nxt[now][c]) &#123;</span><br><span class="line">			fail[++cnt]=nxt[<span class="built_in">Find</span>(fail[now],i)][c];</span><br><span class="line">			len[nxt[now][c]=cnt]=len[now]+<span class="number">2</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	now=nxt[now][c];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="拓展回文串与-textborder">拓展：回文串与 <span
class="math inline">\(\text{Border}\)</span></h3>
<p><a href="https://www.cnblogs.com/chasedeath/p/13396877.html">关于
<span class="math inline">\(\text{Border}\)</span></a></p>
<p>推论1：回文串的 <span class="math inline">\(\text{Border}\)</span>
也是回文串。</p>
<p>若有回文串 <span class="math inline">\(S\)</span> 的一个 <span
class="math inline">\(\text{Border} :T\)</span>，则 <span
class="math inline">\(S_{1,|T|}=S_{|S|-|T|+1,|S|}=reverse(S_{1,|T|})\)</span>，</p>
<p>故 <span class="math inline">\(T\)</span> 也是一个回文串。</p>
<p>推论2：遍历回文自动机的 <span class="math inline">\(fail\)</span>
链，能得到当前串的所有 <span
class="math inline">\(\text{Border}\)</span> （基于推论 1 得到）。</p>
<p>结合 <span class="math inline">\(\text{kmp,ACAM}\)</span> 与 <span
class="math inline">\(\text{Border}\)</span>
的关系能够有更好的理解。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E5%A0%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<hr />
<p>title: '堆' date: 'Sat Aug 12 11:05:23 2023 categories: -
oi-notes'</p>
<h1 id="堆">堆</h1>
<p>每个节点权值大于（小根堆）父亲的树形数据结构。</p>
<p>以下均讨论小根堆的问题。</p>
<span id="more"></span>
<h2 id="普通二叉堆">普通二叉堆</h2>
<p>用数组 <span class="math inline">\(a[1\sim n]\)</span>
构成一棵二叉树来维护堆操作，可以做到：</p>
<ul>
<li><p>插入元素，</p></li>
<li><p>查询堆顶，</p></li>
<li><p>删除堆顶或者删除特定元素（需要记录权值位置）。</p></li>
</ul>
<ol type="1">
<li>插入元素：先放到 <span class="math inline">\(a[n+1]\)</span>
的位置，然后每次与父亲比较是否交换</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    a[++n]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=n;p&gt;<span class="number">1</span> &amp;&amp; a[p]&lt;a[p&gt;&gt;<span class="number">1</span>];) <span class="built_in">swap</span>(a[p],a[p&gt;&gt;<span class="number">1</span>]),p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>删除特定元素</li>
</ol>
<p>删除后，把 <span class="math inline">\(a[n]\)</span>
元素放到空的位置，然后向下走，注意每次一定是把左右儿子中比较小的换上来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(a[x],a[n--]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=x;(p&lt;&lt;<span class="number">1</span>)&lt;=n;)&#123;</span><br><span class="line">		<span class="type">int</span> nxt=p&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)&lt;=n &amp;&amp; a[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]&lt;a[p&lt;&lt;<span class="number">1</span>]) nxt=p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[nxt]&lt;a[p]) <span class="built_in">swap</span>(a[p],a[nxt]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="配对堆">配对堆</h2>
<p>配对堆不是一个二叉树结构，使用左儿子右兄弟来存储树形结构。</p>
<p>可以实现的操作有：</p>
<ul>
<li><p>插入/删除元素，查询堆顶，</p></li>
<li><p>查询堆顶，</p></li>
<li><p><strong>合并两个堆。</strong></p></li>
</ul>
<p>首先要维护最基本的两个操作：</p>
<ol type="1">
<li>合并两个堆：</li>
</ol>
<p>直接按照堆顶权值大小合并，接上去即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[N],ch[N],br[N]; <span class="comment">//权值，儿子，兄弟</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span>(a[x]&gt;a[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    br[y]=ch[x],ch[x]=y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>配对操作：</li>
</ol>
<p>把一个点的所有儿子两两合并之后再依次合并到一起。</p>
<p>配对堆的所有操作都基于合并和配对实现。</p>
<p>合并操作是 <span class="math inline">\(O(1)\)</span> 的。</p>
<p>配对操作单次最坏是 <span class="math inline">\(O(n)\)</span>，但是和
<span class="math inline">\(Splay\)</span>
类似的，配对可以让儿子中兄弟最多的个数减半，是一个均摊 <span
class="math inline">\(O(\log n)\)</span>
的操作，因此不可持久化，但是实际运行常数比较小。</p>
<p>操作实现：用一个函数给 <span class="math inline">\(x\)</span> 和
<span class="math inline">\(x\)</span>
的右边的所有兄弟配对，递归实现。</p>
<p>每次让 <span class="math inline">\(x\)</span>
和右边第一个兄弟配对（即先合并），再和右边剩下的节点合并。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pair</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !br[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> y=br[x],z=br[y];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Union</span>(<span class="built_in">Union</span>(x,y),<span class="built_in">Pair</span>(z));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>删除元素：</li>
</ol>
<p>如果删除的不是堆顶元素，还需要额外存储每个点的父亲。</p>
<p>把被删除元素的儿子合并之后接到父亲上面。</p>
<ol start="4" type="1">
<li>查询堆顶：</li>
</ol>
<p>如果是查询某个特定元素所在堆的堆顶，需要用并查集来维护。</p>
<p><br></p>
<h2 id="左偏树">左偏树</h2>
<p>左偏树是一个二叉堆结构，顾名思义，向左边偏的树。</p>
<p>左偏树判断左偏的方法是定义了一个 <span
class="math inline">\(dis\)</span> 数组，满足 <span
class="math inline">\(\forall dis_{lson}\ge
dis_{rson},dis_x=dis_{rson}+1\)</span>。</p>
<p>因此一直走右儿子的链长度就是 <span class="math inline">\(O(\log
n)\)</span> 的。</p>
<p>利用这个性质完成操作，每次合并之后检查是否满足 <span
class="math inline">\(dis_{lson},dis_{rson}\)</span>
的大小关系来保证左偏。</p>
<p>可以完成的操作有：</p>
<ul>
<li><p>插入节点/合并堆，</p></li>
<li><p>删除节点，</p></li>
<li><p>访问堆顶，</p></li>
<li><p><strong>可持久化</strong>。</p></li>
</ul>
<ol type="1">
<li>检查操作：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis[ls[x]]&lt;dis[rs[x]]) <span class="built_in">swap</span>(ls[x],rs[x]);</span><br><span class="line">    dis[x]=dis[rs[x]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左偏树的合并操作即：</p>
<p>让较大的堆顶 和 小的堆顶的右儿子合并成为 新的右儿子。</p>
<p>很显然合并次数$<span
class="math inline">\(两个堆的右儿子长度之和，这个操作是单次\)</span>O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span>(a[x]&gt;a[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> rs[x]=<span class="built_in">Union</span>(rs[x],y),;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>删除节点： 合并左右儿子后接到父亲上。</p></li>
<li><p>访问堆顶：
左偏树的最大深度没有保证，访问特定节点所在堆的堆顶需要用并查集维护。</p></li>
<li><p>可持久化： 由于单次访问复杂度保证了是 <span
class="math inline">\(O(\log
n)\)</span>，因此可以对于每次合并得到的开一个新的节点存下来，即完成了可持久化操作</p></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E5%90%88%E8%BF%90%E7%AE%97+%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<hr />
<p>title: '多项式复合+拉格朗日反演' date: 'Sat Aug 12 11:05:23 2023
categories: - oi-notes'</p>
<h1 id="多项式复合拉格朗日反演">多项式复合+拉格朗日反演</h1>
<h2 id="多项式复合">多项式复合</h2>
<p>多项式复合形如 <span class="math inline">\(F(G(x))\)</span>
，即复合函数，较为数学的形式可以写作 <span
class="math inline">\(u=F(v),v=G(x)\)</span>。</p>
<p>在符号上，记做 <span class="math inline">\(F\circ
G=F(G(x))\)</span>。</p>
<p>稍微展开一下就是 <span class="math inline">\(\begin{aligned}
F(G(x))=\sum_i [x^i]F(x)\cdot G^i(x)\end{aligned}\)</span>。</p>
<span id="more"></span>
<h2 id="拉格朗日lagrange反演">拉格朗日(Lagrange)反演</h2>
<p>数学上，拉格朗日反演揭示了幂函数的反函数的形式。</p>
<p>OI上，拉格朗日反演是复合逆/反函数的反演。</p>
<p>对于多项式 <span class="math inline">\(F(x),G(x)\)</span>
，若他们的复合满足 <span class="math inline">\(F(G(x))=x\)</span> ，则
<span class="math inline">\(F(x)\)</span> 与 <span
class="math inline">\(G(x)\)</span> 互为复合逆(若在非模意义下， <span
class="math inline">\(y=F(x),y=G(x)\)</span> 的图像关于直线 <span
class="math inline">\(y=x\)</span> 对称，即反函数)，此时也有 <span
class="math inline">\(G(F(x))=x\)</span>。</p>
<p>拉格朗日反演用于求解复合逆的<strong>一项的值</strong>：</p>
<p><span class="math display">\[
[x^n]F(x)=\frac{1}{n}[x^{-1}](\frac{1}{G(x)})^n
\]</span> 显然，存在复合逆的多项式必然没有常数项：</p>
<p>所以上式写成更阳间的样子就是 <span
class="math inline">\(\begin{aligned}[]
[x^n]F(x)=\frac{1}{n}[x^{n-1}](\frac{x}{G(x)})^n\end{aligned}\)</span>。</p>
<p>由于证明太~~，咕了</p>
<p>另外还有扩展拉格朗日反演：</p>
<p><span class="math inline">\(\begin{aligned}
[][x^n]H(F(x))=\frac{1}{n}[x^{n-1}]H&#39;(x)(\frac{x}{G(x)})^n\end{aligned}\)</span>。</p>
<p><span class="math display">\[ \ \]</span></p>
<h2 id="多项式复合逆">多项式复合逆</h2>
<p>对于给定的 <span class="math inline">\(F(x)\)</span>
，求其复合逆：</p>
<p>带入拉格朗日反演的式子：</p>
<p><span class="math display">\[
F(x)=\sum \frac{1}{i}[x^{i-1}](\frac{x}{G(x)})^i x^i
\]</span> 求这个式子的核心是 分块 + 暴力。</p>
<p><span class="math inline">\(i=a\cdot S+b\)</span> ，求出 <span
class="math inline">\((\frac{x}{G(x)})^{Sa},(\frac{x}{G(x)})^b\)</span>
，然后直接对于每个位置把两个式子暴力合并即可。</p>
<p>两部分复杂度总和为 <span class="math inline">\(O(n\sqrt n\log
n+n^2)\)</span>。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E5%B9%B3%E9%9D%A2%E5%9B%BE%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<hr />
<p>title: '平面图的欧拉定理' date: 'Sat Aug 12 11:05:23 2023 categories:
- oi-notes'</p>
<h1 id="平面图的欧拉定理">平面图的欧拉定理</h1>
<h3 id="平面图">平面图</h3>
<p>平面图是一张无向图，顾名思义：存在一种在平面上画点的方法，使得所有的边不会相交。</p>
<h3 id="欧拉定理">欧拉定理</h3>
<p>对于一张平面图 <span class="math inline">\(G=(V,E)\)</span>，<span
class="math inline">\(F\)</span>
为平面图上的边把平面划分的区域个数（注意统计最外层的无限区域），则：</p>
<p>一张平面图是连通的 <span
class="math inline">\(\Longleftrightarrow\)</span> <span
class="math inline">\(|V|-|E|+|F|=2\)</span>。</p>
<span id="more"></span>
<p>下面是一个例子：</p>
<figure>
<img src="https://i.loli.net/2021/01/07/38Omti1zofAV6HY.png"
alt="Snipaste_2021-01-07_14-31-51.png" />
<figcaption
aria-hidden="true">Snipaste_2021-01-07_14-31-51.png</figcaption>
</figure>
<p><span class="math inline">\(|V|=5,|E|=8,F=5\)</span>
（包含最外层的区域），</p>
<p>很显然这个定理也可以用来统计联通块的数量/区域的数量。</p>
<p>即 <span class="math inline">\(C=|V|-|E|+|F|-1\)</span>。</p>
<h3 id="欧拉定理与网格图">欧拉定理与网格图</h3>
<p>当题目涉及到网格图染色问题时，不妨将所有染色的网格视为点，边即为四联通。</p>
<figure>
<img src="https://i.loli.net/2021/01/07/x2IniXu6brhJA7y.png"
alt="Snipaste_2021-01-07_14-35-46.png" />
<figcaption
aria-hidden="true">Snipaste_2021-01-07_14-35-46.png</figcaption>
</figure>
<p>此时构成一个特殊的平面图，且此时可以发现：</p>
<ol type="1">
<li><p><span class="math inline">\(F\)</span>为 4相邻块个数 + 空腔个数 +
1</p></li>
<li><p><span class="math inline">\(|E|\)</span>为相邻对数</p></li>
<li><p><span class="math inline">\(|V|\)</span>为染色个数</p></li>
</ol>
<p>由此可以在染色问题上把 <strong>空腔数量</strong> 与
<strong>连通性结合起来</strong>。</p>
<p><del>作为一种可能出现的思路</del></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<hr />
<p>title: '数论知识小结 [基础篇]' date: 'Sat Aug 12 11:05:23 2023
categories: - oi-notes'</p>
<h1 id="数论知识小结-基础篇">数论知识小结 [基础篇]</h1>
<p>符号 <span class="math inline">\((a,b)=\gcd(a,b)\)</span>。</p>
<p>乘除 <span class="math inline">\(a|b\rightarrow b=ka (k\in
\N^+)\)</span>。</p>
<p><span class="math inline">\(\sum\)</span> 求和，<span
class="math inline">\(\prod\)</span> 求积。</p>
<p>任意 <span class="math inline">\(\forall\)</span>，存在 <span
class="math inline">\(\exists\)</span>。</p>
<p>$x$ 向下取整，$x$ 向上取整。</p>
<p><span class="math inline">\([a,b]\)</span> 区间，通常指整数即 <span
class="math inline">\([a,b]\cap \Z\)</span>。</p>
<span id="more"></span>
<h3 id="调和级数">调和级数</h3>
<p>数学上，调和级数为 <span
class="math inline">\(H_n=\sum_{i=1}^{n}\frac{1}{i}\)</span>。</p>
<p>在<strong>OI</strong>中，我们常用调和级数分析 <span
class="math inline">\(\sum_{i=1}^n\frac{n}{i}\approx n\ln
n\)</span>。</p>
<p>把它近似看成是 <span class="math inline">\(f(x)=\frac{n}{x}\)</span>
在 <span class="math inline">\([1,n]\)</span> 上的积分，它的原函数 <span
class="math inline">\(F(x)=n\ln x\)</span>。</p>
<p>即 <span class="math inline">\(\displaystyle
\sum_{i=1}^n\frac{n}{i}\approx \int_1^nf(x) dx=F(n)-F(1)=n\ln n-n\approx
n\ln n\)</span>。</p>
<p>附：广义调和级数 $H^z_n=_{i=1}^{n} $ 它的无穷形式为黎曼函数 <span
class="math inline">\(\displaystyle
\zeta(z)=H^{z}_{\infty}\)</span>。</p>
<p><br></p>
<h3 id="向下取整的性质数论分段">向下取整的性质/数论分段</h3>
<p>性质：$=$。</p>
<p>数论分段：即对于 <span class="math inline">\(i=[1,n]\)</span>，把
<span class="math inline">\(i\)</span> 按照 <span
class="math inline">\(\lfloor \frac{n}{i}\rfloor\)</span> 的值分成 <span
class="math inline">\(O(\sqrt n)\)</span> 段，（ <span
class="math inline">\(2\cdot \sqrt n\)</span> 段左右）。</p>
<p>证明：对于 <span class="math inline">\(i\leq \sqrt
n\)</span>，显然只有 <span class="math inline">\(\sqrt n\)</span>
个不同的值。</p>
<p>对于 <span class="math inline">\(i&gt;\sqrt n\)</span>，此时 <span
class="math inline">\(\frac{n}{i}&lt;\sqrt n\)</span>，也只有 <span
class="math inline">\(\sqrt n\)</span> 个不同的值。</p>
<p><br></p>
<h3 id="素数质数质数密度">素数/质数/质数密度</h3>
<p>对于 <span class="math inline">\(x&gt;1\)</span>，若 <span
class="math inline">\(\nexists y\in[2,n-1],y|x\)</span>，则 <span
class="math inline">\(x\)</span> 是一个质数，下文称素数集合为 <span
class="math inline">\(prime\)</span> 集合。</p>
<p>用素数对于 <span class="math inline">\(n\)</span> 进行唯一分解 <span
class="math inline">\(n=\prod_{p_i\in prime} p_i^{c_i}\)</span>。</p>
<p>如果 <span class="math inline">\(x\)</span> 不是质数，则 <span
class="math inline">\(\exists y\in [2,\sqrt n] ,y|x\)</span>。</p>
<p>所以可以朴素写出一个 <span class="math inline">\(O(\sqrt n)\)</span>
的素数判别法。</p>
<p><span
class="math inline">\(\pi(n)=|prime\cap[1,n]|\)</span>，素数密度在<strong>渐进意义</strong>上是
<span class="math inline">\(O(\log n)\)</span> 的，即在复杂度上可以认为
<span class="math inline">\(\pi(n)=O(\frac{n}{\log n})\)</span> （实际在
<span class="math inline">\(n\)</span> 较小时完全看不出这一点）。</p>
<p>利用这一点预先处理小素数，每次只判断素数，可以写出一个 <span
class="math inline">\(O(\frac{\sqrt n}{\log n})\)</span>
的素数判别法。</p>
<p>更快的方法是 <span class="math inline">\(\text{Miller
Rabin}\)</span>，不要在这个时候学。</p>
<p>质因数分解：即求 <span class="math inline">\(n=\prod p_i^{c_i},p_i\in
prime\)</span>，其中 <span class="math inline">\(\sum c_i\leq \log
_2^n\)</span>。</p>
<p>由于对于一个数 <span class="math inline">\(n\)</span>，最多存在一个
<span class="math inline">\(y\in prime \cap [\sqrt
n,n],y|n\)</span>，因此可以先分解掉 <span
class="math inline">\(y&lt;\sqrt n\)</span>
的部分，剩下的一个就知道了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Factor</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;++i) <span class="keyword">if</span>(n%i==<span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i),n/=i; <span class="comment">// 分解掉&lt;sqrt(n)的部分</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,n); <span class="comment">// 如果还剩下，那么就是&gt;sqrt(n)的一个质数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度是 <span class="math inline">\(O(\sqrt n +\log
n)\)</span>。</p>
<p><br></p>
<p>朴素的素数筛法：埃氏筛。</p>
<p>对于 <span class="math inline">\([2,n]\)</span> 每个数 <span
class="math inline">\(i\)</span>，<span
class="math inline">\(x=ki(k&gt;1)\)</span>
均不是质数，直接枚举复杂度为调和级数 <span class="math inline">\(O(n\ln
n)\)</span>。</p>
<p>更优化的，对于 <span class="math inline">\([2,n]\)</span> 中每个质数
<span class="math inline">\(i\)</span>，<span
class="math inline">\(x=ki(k&gt;1)\)</span> 均不是质数，由于素数密度为
<span class="math inline">\(O(\log n)\)</span>，所以可以近似认为是 <span
class="math inline">\(O(n\log \log n)\)</span>，实际要慢一些。</p>
<h3 id="线性筛欧拉筛">线性筛(欧拉筛)</h3>
<p>筛素数知识一个基础，可以筛很多函数，尤其是适用于积性函数。</p>
<p>直接上代码背板子好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> notpri[N],prime[N],primecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    notpri[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!notpri[i]) prime[++primecnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=primecnt &amp;&amp; <span class="number">1ll</span>*i*prime[j]&lt;=n;++j)&#123;</span><br><span class="line">            notpri[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 <span class="math inline">\(i\mod prime_j= 0\)</span>
意味着后面的数已经被 <span
class="math inline">\(\frac{i}{prime_j}\)</span> 筛掉了，所以可以
<code>break</code>。</p>
<p>复杂度是带有一定常数的 <span
class="math inline">\(O(n)\)</span>，还可以用来筛其他的一些函数。</p>
<p><br></p>
<p><br></p>
<h3 id="gcdtextlcm"><span
class="math inline">\(\gcd,\text{lcm}\)</span></h3>
<p>最大公因数 <span class="math inline">\(\text{gcd(greatest common
divisor)}\)</span> 常用 <span
class="math inline">\(\gcd(x,y)=(x,y)\)</span> 表示</p>
<p>最小公倍数 <span class="math inline">\(\text{lcm(least common
multiple)}\)</span>。</p>
<p>特别的：<span class="math inline">\((a,0)=a\)</span>。</p>
<p>求 <span class="math inline">\(\gcd(a,b)\)</span>
可以用辗转相除法（也称为欧几里得算法），即利用性质 <span
class="math inline">\((a,b)=(a\mod b,b)\)</span>。</p>
<p>每次递归调用 <span class="math inline">\(\gcd(b,a\mod b)\)</span>
即可，边界为 <span class="math inline">\((a,0)=a\)</span>。</p>
<p>复杂度分析：</p>
<p>对于 <span class="math inline">\(a\ge b\Rightarrow a\mod b \leq
\frac{a}{2}\)</span>。</p>
<p>所以每次取模会减少一倍，复杂度为 <span class="math inline">\(O(\log
a)\)</span>。</p>
<p><br></p>
<h4 id="附扩展欧几里得算法">附：扩展欧几里得算法</h4>
<p>用于求解不定方程 <span class="math inline">\(ax+by =1\)</span>
的一组解 <span class="math inline">\((x,y)\)</span>。</p>
<p>存在解的条件是 <span class="math inline">\((a,b)=1\)</span>，否则
<span class="math inline">\((a,b)|ax+by\)</span>，即 <span
class="math inline">\(ax+by&gt;1\)</span>。</p>
<p>用类似求 <span class="math inline">\(\text{gcd}\)</span>
的方法求出。</p>
<p><span class="math inline">\(ax+by=1\)</span></p>
<p><span class="math inline">\((a\mod b)\cdot x+ \lfloor
\frac{a}{b}\rfloor\cdot b\cdot x + by=1\)</span></p>
<p><span class="math inline">\((a\mod b)\cdot x+ b\cdot (\lfloor
\frac{a}{b}\rfloor\cdot x + y)=1\)</span></p>
<p>那么如果求出 <span class="math inline">\((a\mod b)\cdot x&#39;+b\cdot
y&#39;=1\)</span> 的解。</p>
<p>则 <span class="math inline">\(x&#39;=x,y&#39;=\lfloor
\frac{a}{b}\rfloor \cdot x+y\)</span>。</p>
<p>即 <span class="math inline">\(x=x&#39;,y=y&#39;-\lfloor
\frac{a}{b}\rfloor x\)</span>。</p>
<p>每次都递归求出 <span class="math inline">\((a\mod b) \cdot x+ by
=1\)</span>。</p>
<p>复杂度与 <span class="math inline">\(\gcd\)</span> 相同，最后的 <span
class="math inline">\((a,b)=a=1,b=0\)</span> 是边界条件，此时 <span
class="math inline">\(x+0\cdot y=1\)</span> 的一组解是 <span
class="math inline">\((1,0)\)</span>。</p>
<p>写成代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ax + by =1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123; </span><br><span class="line">        <span class="keyword">if</span>(a!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// (a,b)!=1 ,不存在解</span></span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>; <span class="comment">// 初始解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">Exgcd</span>(b,a%b,y,x),y-=a/b*x; <span class="comment">// 带入上面的式子，注意这里带入的是(b,a%b),所以x,y要反过来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意求出的 <span class="math inline">\(x,y\)</span> 不保证为正数</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="因数个数">因数个数</h3>
<p>似乎没有找到规范的函数定义，所以下称 <span
class="math inline">\(d(n)\)</span>。</p>
<p>即 <span class="math inline">\(d(n)=|\{i|i\in[1,n]\and
i|n\}|\)</span>。</p>
<p>对于 <span class="math inline">\(n=\prod
p_i^{c_i}\)</span>，列一条小学的公式 <span
class="math inline">\(d(n)=\prod (c_i+1)\)</span>。</p>
<p>因数个数一个非常松的上界是 <span class="math inline">\(O(\sqrt
n)\)</span>，证明这里略去。</p>
<p>实际上，搜索得到的上界大致是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxn=10^ 1  max= 4</span><br><span class="line">maxn=10^ 2  max= 12</span><br><span class="line">maxn=10^ 3  max= 32</span><br><span class="line">maxn=10^ 4  max= 64</span><br><span class="line">maxn=10^ 5  max= 128</span><br><span class="line">maxn=10^ 6  max= 240</span><br><span class="line">maxn=10^ 7  max= 448</span><br><span class="line">maxn=10^ 8  max= 768</span><br><span class="line">maxn=10^ 9  max= 1344</span><br><span class="line">maxn=10^10  max= 2304</span><br><span class="line">maxn=10^11  max= 4032</span><br><span class="line">maxn=10^12  max= 6720</span><br><span class="line">maxn=10^13  max= 10752</span><br><span class="line">maxn=10^14  max= 17280</span><br><span class="line">maxn=10^15  max= 26880</span><br><span class="line">maxn=10^16  max= 41472</span><br><span class="line">maxn=10^17  max= 64512</span><br><span class="line">maxn=10^18  max= 103680</span><br></pre></td></tr></table></figure>
<p>可以看到，因数个数是非常少的</p>
<p>附:</p>
<p>质因数个数 <span class="math inline">\(\Omega(n)=|prime\cap
[1,n]|\)</span>，非常松的上界是 <span
class="math inline">\(\Omega(n)=O(\log n)\)</span>。</p>
<p>约数和函数 <span
class="math inline">\(\sigma(n)=\sum_{i|n}i\)</span>。</p>
<p><br></p>
<h3
id="费马小定理欧拉定理欧拉函数阶">费马小定理/欧拉定理/欧拉函数/阶</h3>
<p>费马小定理： 对于任意质数 <span
class="math inline">\(P,x&gt;0,x^{p-1}\equiv 1 \pmod P\)</span>。</p>
<p>欧拉函数：<span class="math inline">\(\varphi(n)\)</span> 为 <span
class="math inline">\([1,n-1]\)</span> 中与 <span
class="math inline">\(n\)</span> 互质的数个数，特别的 <span
class="math inline">\(\varphi(1)=1\)</span>。</p>
<p>设 <span class="math inline">\(n=\prod p_i^{c_i}\)</span> 其中 <span
class="math inline">\(p_i\)</span> 是质数，<span
class="math inline">\(c_i&gt;0\)</span>，则 <span
class="math inline">\(\varphi(n)=\prod
p_i^{c_i-1}(p_i-1)=n\prod\frac{p_i-1}{p_i}\)</span>。</p>
<p>对于可以通过类似筛素数的方法求出来 <span
class="math inline">\([1,n]\)</span> 的 <span
class="math inline">\(\varphi(i)\)</span>。</p>
<p>对于数 <span
class="math inline">\(n\)</span>，需要采用质因数分解求出，朴素的做法为
<span class="math inline">\(O(\sqrt n)\)</span>，用 <span
class="math inline">\(\text{Pollard&#39;s Rho}\)</span>
算法复杂度更低。</p>
<p><br></p>
<p>欧拉定理：对于任意数 <span
class="math inline">\(P&gt;1,x&gt;0,x^{\varphi(P)}\equiv 1\pmod
P\)</span>。</p>
<p>推论：<span class="math inline">\(x^c\equiv x^{c\mod \varphi (P)}
\pmod P\)</span>。</p>
<p>很显然，费马小定理是欧拉定理的特殊情况。</p>
<p><br></p>
<p>阶：对于 <span class="math inline">\((a,n)=1\)</span> 的整数，满足
<span class="math inline">\(a^r≡1 \pmod n\)</span> 的最小整数 <span
class="math inline">\(r\)</span>，称为 <span
class="math inline">\(a\)</span> 模 <span
class="math inline">\(n\)</span> 的阶，以下记作 <span
class="math inline">\(d(a)\)</span>。</p>
<p>显然 <span class="math inline">\(a^i \mod n\)</span> 构成了一个以
<span class="math inline">\(r\)</span> 为最小正周期的循环。</p>
<p>性质：根据欧拉定理 <span class="math inline">\(a^{\varphi(n)}\mod
n=1\)</span>，所以有 <span
class="math inline">\(d(a)|\varphi(n)\)</span> 。</p>
<p>求解阶：先对于 <span class="math inline">\(\varphi(n)\)</span>
质因数分解，然后可以。</p>
<ol type="1">
<li><p>依次枚举每个因数判断是否有 <span class="math inline">\(a^i\mod
n=1\)</span>，取最小的 <span class="math inline">\(i\)</span>，复杂度为
<span class="math inline">\(O(\sqrt n\log n)\)</span>。</p></li>
<li><p>设 <span class="math inline">\(\varphi(n)=p_i^{c_i}\)</span>，令
<span class="math inline">\(x=\varphi(P)\)</span>，从 <span
class="math inline">\(x\)</span> 开始，如果 <span
class="math inline">\(a^{\frac{x}{p_i}}\mod n=1\)</span>， 则 <span
class="math inline">\(x\rightarrow \frac{x}{p_i}\)</span>。</p></li>
</ol>
<p>预处理复杂度受限于质因数分解（下文有介绍）。</p>
<p>单次查询复杂度上限是 <span class="math inline">\(O(\log ^2
P)\)</span> （为快速幂复杂度乘上 <span class="math inline">\(\sum
c_i\)</span>）。</p>
<p><br></p>
<h3 id="模逆元乘法逆元">模逆元（乘法逆元）</h3>
<p>对于任意数 <span
class="math inline">\(x&gt;1,P&gt;1,(x,P)=1\)</span>，存在一个数 <span
class="math inline">\(\frac{1}{x}\equiv y\pmod P\)</span>。</p>
<p>即 <span class="math inline">\(xy\equiv 1 \pmod P\)</span>， <span
class="math inline">\(y\)</span> 为 <span
class="math inline">\(x\)</span> 的一个模逆元。</p>
<p>当 <span class="math inline">\(P\)</span> 为质数时，由于 <span
class="math inline">\(x^{P-1}\equiv 1 \pmod P\)</span>，所以 <span
class="math inline">\(y\equiv x^{P-2}\pmod P\)</span> 为 <span
class="math inline">\(x\)</span> 的一个逆元。</p>
<p>当 <span class="math inline">\(P\)</span> 不为质数时，如果已知 <span
class="math inline">\(\varphi (P)\)</span>，可以类似得做，否则可以构造
<span class="math inline">\(a\cdot x+b\cdot
P=1\)</span>，用扩展欧几里得算法求出一组合法解 <span
class="math inline">\((a,b)\)</span>，则<span
class="math inline">\(a\)</span> 即为一个答案。</p>
<p><br></p>
<h3 id="原根指标">原根/指标</h3>
<p>原根：一个数 <span class="math inline">\(P\)</span>
有原根的条件是他可以表示为 <span
class="math inline">\(P=1,2,4,p,2p,p^n(p\in prime)\)</span>。</p>
<p>对于 <span class="math inline">\(P\)</span>，令 <span
class="math inline">\(d(x)\)</span> 为 <span
class="math inline">\(x\)</span> 模 <span
class="math inline">\(P\)</span> 的原根，若存在 <span
class="math inline">\(d(x)=\varphi(P)\)</span>，则<span
class="math inline">\(x\)</span> 是 <span
class="math inline">\(P\)</span> 的一个原根。</p>
<p>找原根：</p>
<p>设 <span class="math inline">\(\varphi(P)=\prod
p_i^{c_i}\)</span>，其中 <span class="math inline">\(p_i\)</span>
是质数。</p>
<p>由于 <span class="math inline">\(d(x)|\varphi(P)\)</span>，如果 <span
class="math inline">\(d(x)&lt;\varphi(P)\)</span> 那么必然存在一个<span
class="math inline">\(x^{\frac{\varphi(P)}{p_i}}\equiv 1\pmod
P\)</span>。</p>
<p>所以先求一遍质因数分解，然后快速幂判断就可以做到 <span
class="math inline">\(O(\log ^2 P)\)</span> 判断原根。</p>
<p>显然原根不唯一，已经被证明对于任意 <span
class="math inline">\(P\)</span> 如果存在原根，则其最小原根不超过 <span
class="math inline">\(O(P^{\frac{1}{4}})\)</span> 级别。</p>
<p><br></p>
<p>指标：</p>
<p>对于一个数 <span class="math inline">\(P\)</span> 和它的一个原根
<span class="math inline">\(x\)</span>，对于 <span
class="math inline">\(\gcd(y,P)=1\)</span>，则 <span
class="math inline">\(y\)</span> 一定可以用<span
class="math inline">\(x^i\)</span> 表示，那么 <span
class="math inline">\(i\)</span> 就是 <span
class="math inline">\(y\)</span> 的指标。</p>
<p>同时，<span class="math inline">\(y\)</span> 模 <span
class="math inline">\(P\)</span> 的阶就是 <span
class="math inline">\(d(y)=\frac{\varphi(P)}{\gcd(\varphi(P),i)}\)</span>，可以认为是数列
<span class="math inline">\(a_j=i\cdot j\mod \varphi(P)\)</span>
的周期问题。</p>
<p>可以使用 <span class="math inline">\(\text{BSGS}\)</span> 算法在
<span class="math inline">\(O(\sqrt P\log P)\)</span> 或者 <span
class="math inline">\(O(\sqrt P)\)</span> 的时间内求出一个数的指标。</p>
<p>（关于去掉 <span class="math inline">\(\log
P\)</span>：只需要处理出模逆元直接累乘，每次用 <span
class="math inline">\(\text{Hash Table}\)</span> 访问即可）。</p>
<p>指标在二次剩余的较劣做法中也有应用，同时也可以直接套用性质用于阶的求解</p>
<p><br></p>
<h3 id="快速乘">快速乘</h3>
<p>求 <span class="math inline">\(x,y\in[0,P-1],P\leq 10^{18},x\cdot y
\mod P\)</span>。</p>
<p>直接乘法会爆 long long</p>
<p>可以用类似快速幂的方法写，复杂度为 <span class="math inline">\(O(\log
P)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qmul</span><span class="params">(ll x,ll y,ll P)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=(x+x)%P) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=(res+x)%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方法是强行用 long double 使得精度误差比较小。</p>
<p>然后计算的时候用 unsigned long long
溢出，溢出过程中只要差距不超过<span
class="math inline">\(2^{64}\)</span> 就能保证准确。</p>
<p>复杂度为 <span class="math inline">\(O(1)\)</span>，通常不会挂。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qmul</span><span class="params">(ll x,ll y,ll P)</span></span>&#123;</span><br><span class="line">    ull z=(<span class="type">long</span> <span class="type">double</span>)x/P*y;</span><br><span class="line">    ll res=(ull)x*y-(ull)z*P;</span><br><span class="line">    <span class="keyword">return</span> (res%P+P)%P; <span class="comment">// ps : 通常偏差在 +-P 以内，因为实际上long double =精度误差非常小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8D%95%E4%BD%8D%E6%A0%B9%E7%82%B9%E5%80%BC%E5%BC%8F%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<hr />
<p>title: '多项式指定大小的单位根点值式求解(含Bluestein’s Algorithm)'
date: 'Sat Aug 12 11:05:23 2023 categories: - oi-notes'</p>
<h1
id="多项式指定大小的单位根点值式求解含bluesteins-algorithm">多项式指定大小的单位根点值式求解(含Bluestein’s
Algorithm)</h1>
<p>下面的阐述建立于存在 <span class="math inline">\(n\)</span>
阶单位根的前提下。</p>
<p>（如果是NTT，必须满足 <span class="math inline">\(n|(P-1)\)</span>
，否则单位根可能会变成一个复杂的<strong>多维向量</strong>）。</p>
<p><span class="math display">\[ \ \]</span></p>
<h2
id="用卷积解决多项式与点值式的转化bluesteins-algorithm">用卷积解决多项式与点值式的转化:Bluestein’s
Algorithm</h2>
<p>设最终求得的点值式为 <span class="math inline">\(f(x^k)=\sum a_i\cdot
\omega_n^{i k}\)</span>。</p>
<p>其中指数为 <span class="math inline">\(ik\)</span> ，有一种简单的转化
<span class="math inline">\(i\cdot
k=\cfrac{i^2+k^2-(i-k)^2}{2}\)</span>。</p>
<p>由于在模意义下， <span class="math inline">\(x^{\frac{i}{2}}\)</span>
次(二次剩余)是一个非常麻烦的东西，所以考虑一个更优的转化。</p>
<p><span class="math display">\[
i\cdot k=C(i+k,2)-C(i,2)-C(k,2)
\]</span> 这条式子的组合意义是：从集合 <span
class="math inline">\(i,k\)</span> 分别选一个，等价于从 <span
class="math inline">\(i+k\)</span> 选两个减去在 <span
class="math inline">\(i,k\)</span> 内部选两个。</p>
<p>通过这样的转化，我们可以对于每一个 <span
class="math inline">\(a_i\)</span> 计算其对于每个 <span
class="math inline">\(f(x^k)\)</span> 的贡献，</p>
<p>具体过程是简单的构造卷积，这里省略。</p>
<p><br></p>
<h2 id="适用于特殊情况的转化方法">适用于特殊情况的转化方法</h2>
<p>需要了解的是，多项式卷积的 FFT / NTT 不止适用与于二元分治。</p>
<p>对于多项式 <span class="math inline">\(F(x)\)</span> 的 <span
class="math inline">\(d\)</span> 元分治，设分治子问题的答案为 <span
class="math inline">\(G_j(x&#39;_i),j\in[0,d-1]\)</span>
，可以得到合并式子：</p>
<p><span class="math display">\[
F(x_i)=\sum_{j=0}^{d-1}x_i^jG_j(x_i^d)=\sum_{i=0}^{d-1}x_i^jG_j(x&#39;_{i\mod
\frac{n}{d}})
\]</span> 对于 <span class="math inline">\(n\)</span>
进行质因数分解，得到 <span class="math inline">\(n=\prod p_i\)</span>
，带入上面的式子，带入 <span class="math inline">\(p_i\)</span>
元分治强行求解，可以认为最终复杂度为 <span class="math inline">\(O(n\sum
p_i)=O(n\cdot \max\{p_i\} \log n)\)</span>。</p>
<p>因此，这种方法使用于 <span class="math inline">\(p_i\)</span>
较小的情况。</p>
<p><br></p>
<h2 id="n-元点值式的用途">n 元点值式的用途</h2>
<p>DFT 的卷积是溢出的， <span class="math inline">\(x^i\)</span>
会溢出到 <span class="math inline">\(x^{i\mod n}\)</span>
，系数之间存在着循环关系。</p>
<p>我们可以利用 <span class="math inline">\(n\)</span>
元卷积做到指定大小的循环卷积，可以处理一些特定问题。</p>
<p><a href="https://www.luogu.com.cn/problem/P4191">例题:
[CTSC2010]性能优化</a>（使用 <span class="math inline">\(O(n\log n\log
C)\)</span> 的快速幂无法通过，尚未尝试Bluestein’s Algorithm）。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E6%8E%B7%E9%AA%B0%E5%AD%90+%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<hr />
<p>title: '集训队论文《浅谈生成函数在掷骰子问题上的应用》 阅读笔记'
date: 'Sat Aug 12 11:05:23 2023 categories: - oi-notes'</p>
<h1
id="集训队论文浅谈生成函数在掷骰子问题上的应用-阅读笔记">集训队论文《浅谈生成函数在掷骰子问题上的应用》
阅读笔记</h1>
<h2 id="概率生成函数">概率生成函数</h2>
<p>对于随机非负离散变量 <span class="math inline">\(x\)</span>
，它的概率生成函数是 <span
class="math inline">\(F(z)=\begin{aligned}\sum_{i=0}^{\infty}P(x=i)z^i\end{aligned}\)</span>。</p>
<p>有性质：</p>
<ol type="1">
<li><p><span
class="math inline">\(F(1)=\begin{aligned}\sum_{i=0}^{\infty}P(x=i)=1\end{aligned}\)</span>。</p></li>
<li><p><span
class="math inline">\(F&#39;(1)=\begin{aligned}\sum_{i=0}^{\infty}P(x=i)\cdot
i=E(x)\end{aligned}\)</span>。</p></li>
<li><p><span
class="math inline">\(E(x^{\underline{k}})=F^{(k)}(1)\)</span> （ <span
class="math inline">\(x\)</span> 的 <span
class="math inline">\(k\)</span> 阶下降幂）。</p></li>
<li><p><span class="math inline">\(x\)</span> 的方差 <span
class="math inline">\(=\begin{aligned}\sum_{i=0}^{\infty}P(x=i)\cdot
(i-E(x))^2\end{aligned}=\begin{aligned}\sum_{i=0}^{\infty}P(x=i)\cdot
i^2-2P(x=i)\cdot i\cdot E(x)+P(x=i)\cdot
E^2(x)\end{aligned}\)</span></p></li>
</ol>
<p><span
class="math inline">\(=E(x^2)-2E^2(x)+E^2(x)=E(x^2)-E^2(x)=E(x^{\underline{2}})+E(x)-E^2(x)=F&#39;&#39;(1)+F&#39;(1)-(F&#39;(1))^2\)</span></p>
<p>CTSC2006 歌唱王国</p>
<p>给定序列 <span class="math inline">\(A_{1.. n}\)</span>。</p>
<p>求从一个空序列每次放 <span class="math inline">\([1,m]\)</span>
随机，第一次出现 <span class="math inline">\(A\)</span> 的期望长度。</p>
<p>设当前对应 <span class="math inline">\(\text{kmp}\)</span> 位置为
<span class="math inline">\(i\)</span> ，每次都可以转移一下：</p>
<ol type="1">
<li><p><span class="math inline">\(F(n)=0\)</span></p></li>
<li><p><span class="math inline">\(F(i)=\frac{\sum_{j=1}^m
F(nxt_{i,j})}{m}+1\)</span></p></li>
</ol>
<p><span class="math inline">\(nxt\)</span> 非拓扑关系，且无法枚举 <span
class="math inline">\(1..m\)</span>。</p>
<p>考虑每次 <span class="math inline">\(\text{kmp}\)</span>
合法匹配指针最多位移一位，令 <span class="math inline">\(G(i)\)</span>
为匹配变为 <span class="math inline">\(i+1\)</span> 的期望次数，则 <span
class="math inline">\(G(i)=\sum_{j=1}^{m}\sum_{k=nxt_{i,j}}^{i}
G(k)\)</span>。</p>
<p>设 <span class="math inline">\(sum_i=\sum_1^{i}G(i)\)</span>
，依次求出 <span class="math inline">\([1,n-1]\)</span> 所有的 <span
class="math inline">\(G(i)\)</span>。</p>
<p>并不需要知道真的 <span class="math inline">\(nxt\)</span>
数组，只需要知道 <span class="math inline">\(-sum_{nxt_{i,j}-1}\)</span>
，每次从 <span class="math inline">\(fail_i\)</span>
转移过来，改变一个位置的值，可以 <span
class="math inline">\(O(1)\)</span> 完成计算，即可做到 <span
class="math inline">\(O(n)\)</span>。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%932/</url>
    <content><![CDATA[<hr />
<p>title: '数论知识小结 [微提高篇]' date: 'Sat Aug 12 11:05:23 2023
categories: - oi-notes'</p>
<h1 id="数论知识小结-微提高篇">数论知识小结 [微提高篇]</h1>
<h3 id="二次剩余和高次剩余">二次剩余和高次剩余</h3>
<p><span class="math inline">\(y^c\equiv x\pmod P\)</span> 则 <span
class="math inline">\(y\)</span> 为 <span
class="math inline">\(x\)</span> 模 <span
class="math inline">\(P\)</span> 的 <span
class="math inline">\(c\)</span> 次剩余。</p>
<p>关于<a
href="https://www.cnblogs.com/chasedeath/p/13043597.html">二次剩余</a></p>
<span id="more"></span>
<h3 id="mathrmmiller_rabin-素数检测"><span
class="math inline">\(\mathrm{Miller\_Rabin}\)</span> 素数检测</h3>
<p><span class="math inline">\(x\)</span> 是质数的必要条件是：</p>
<p><span class="math inline">\(\forall a,a^{x-1}\equiv 1\pmod
x\)</span>。</p>
<p>同于对于一个质数 <span class="math inline">\(x\)</span>，必然有：</p>
<p><span class="math inline">\(a^2\equiv 1\pmod x\)</span> 的解只有
<span class="math inline">\(1,x-1\)</span>。</p>
<p>证明是：</p>
<p><span class="math inline">\(\because a^2\equiv 1 \pmod x\)</span></p>
<p><span class="math inline">\(\therefore (a-1)(a+1)\equiv 0 \pmod
x\)</span></p>
<p>因为 <span class="math inline">\(x\)</span> 是质数，所以 <span
class="math inline">\(a-1\mod x=0\)</span> 或 <span
class="math inline">\(a+1\mod x=0\)</span>，即 <span
class="math inline">\(a\in\{1,x-1\}\)</span>。</p>
<p><br></p>
<h4 id="mathrmmiller_rabin算法的步骤"><span
class="math inline">\(\mathrm{Miller\_Rabin}\)</span>算法的步骤</h4>
<p>将 <span class="math inline">\(x-1\)</span> 分解为 <span
class="math inline">\(x-1=2^s\cdot t\)</span>。</p>
<p>找一个 <span class="math inline">\(&lt;x\)</span> 的质数 <span
class="math inline">\(a\)</span>，求出 <span
class="math inline">\(b\equiv a^t \pmod x\)</span>。</p>
<p>将 <span class="math inline">\(b\)</span> 进行 <span
class="math inline">\(s\)</span> 次平方，设这一次平方的结果 <span
class="math inline">\(b^2\equiv c \pmod x\)</span>。</p>
<p>当出现 <span class="math inline">\(c=1\)</span>时，<span
class="math inline">\(b\)</span> 只能为 <span
class="math inline">\(1\)</span>，<span
class="math inline">\(x-1\)</span> 否则 <span
class="math inline">\(x\)</span> 就不是质数。</p>
<p><span class="math inline">\(s\)</span> 次平方后，<span
class="math inline">\(b\equiv a^{x-1}\pmod x\)</span>，若 <span
class="math inline">\(b\ne 1\)</span>，则 <span
class="math inline">\(x\)</span> 不是质数。</p>
<p>在一定范围内，使用指定的极少个进行检测就能保证正确性。即便不这么做，也不需要太多的质数。<a
href="https://loj.ac/problem/143">模板题</a> 跑5次就能过了。</p>
<p>注意 <span class="math inline">\(x\leq 2\or 2|x\)</span>
要特判，取模需要快速乘。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Miller_Rabin</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=<span class="number">1</span> || ~x&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ll s=<span class="number">0</span>,t=x<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(~t&amp;<span class="number">1</span>) s++,t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">20</span>) &#123;</span><br><span class="line">		ll a=prime[<span class="built_in">rand</span>()%primecnt+<span class="number">1</span>],b=<span class="built_in">qpow</span>(a,t,x),c;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,s) &#123;</span><br><span class="line">			c=<span class="built_in">qmul</span>(b,b,x);</span><br><span class="line">			<span class="keyword">if</span>(c==<span class="number">1</span> &amp;&amp; b!=<span class="number">1</span> &amp;&amp; b!=x<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			b=c;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(b!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3
id="可以结合-mathrmmiller-rabin-的-nfrac13-特殊情况质因数分解">可以结合
<span class="math inline">\(\mathrm{Miller Rabin}\)</span> 的 <span
class="math inline">\(n^{\frac{1}{3}}\)</span> 特殊情况质因数分解</h3>
<p>实际上，这种方法常用于求 <span class="math inline">\(n\)</span>
的因子个数</p>
<p>方法非常简单，先对于所有 <span class="math inline">\(pri_i\le
n^{\frac{1}{3}}\)</span> 的因子对于 <span
class="math inline">\(n\)</span> 筛去，剩下的部分中，所有质因子 <span
class="math inline">\(&gt;n^{\frac{1}{3}}\)</span>。</p>
<p>因此最多包含两个质因数（可能相同）。</p>
<p>用 <span class="math inline">\(\mathrm{Miller\_Rabin}\)</span>
判断是否只包含一个质数，然后简单判别两个质因数是否相同即可。</p>
<p>复杂度为 <span class="math inline">\(O(\log n+\pi
(n^{\frac{1}{3}}))\)</span>。</p>
<p>小范围内比下面的 <span
class="math inline">\(\text{Pollard&#39;s\_Rho}\)</span>
更快，更简单。</p>
<p><br></p>
<h3 id="textpollards_rho质因数分解"><span
class="math inline">\(\text{Pollard&#39;s\_Rho}\)</span>质因数分解</h3>
<p>核心就是名字里的 Rho ( <span class="math inline">\(\rho\)</span>
)，是伪循环的一个形象的表示。</p>
<p>伪循环：从某一个时刻开始，进入一个真循环，之前的时间就是 <span
class="math inline">\(\rho\)</span> 的脚。</p>
<p>构造<strong>伪随机函数</strong> <span
class="math inline">\(G_n(x)=(x^2+c)\mod n\)</span>。</p>
<p>构造数列 <span class="math inline">\(a_i=G_n(a_{i-1})\)</span>。</p>
<p>由于函数的值域只有 <span
class="math inline">\([0,n-1]\)</span>，必然出现伪循环，即在从个位置开始，进入一个未知长度的循环，也就是长成了一个
<span class="math inline">\(\rho\)</span> 的形状。</p>
<p>由于这个函数是<strong>伪随机函数</strong>，所以这个循环大小在期望情况下是
<span class="math inline">\(O(\sqrt n)\)</span> 的。</p>
<p><br></p>
<p><span class="math inline">\(\text{Pollard&#39;s\_Rho}\)</span>
算法要找到一个 <span
class="math inline">\(p\in[2,n-2],p|n\)</span>。</p>
<p>考虑用 <span class="math inline">\(\text{Floyd}\)</span>
算法找环，即定义两个变量，一个每次走一步，一个每次走两步，设他们为 <span
class="math inline">\(x,y\)</span>。</p>
<p>当 <span class="math inline">\(x=y\)</span> 时，显然出现循环。</p>
<p>由于 <span class="math inline">\(p|n\)</span>，所以当 <span
class="math inline">\(x \equiv y \pmod p\)</span> 时，实际上是 <span
class="math inline">\(G_p(x)\)</span> 这个函数出现了循环。</p>
<p>所以在找 <span class="math inline">\(G_n(x)\)</span>
的循环时，可以通过求出 <span class="math inline">\(\gcd(x-y,n)\)</span>
判断是否出现<span class="math inline">\(G_p(x)\)</span> 的循环。</p>
<p>注意如果出现 <span class="math inline">\(x=y\)</span> 情况已经找到
<span class="math inline">\(n\)</span>
的循环，说明这个我们这次构造的这个函数找不到 <span
class="math inline">\(p\)</span> 的循环。</p>
<p>由于 <span class="math inline">\(\forall n\notin prime,\exist
p\in[1,\sqrt n],p|n\)</span>。</p>
<p>所以期望情况下每 <span class="math inline">\(\sqrt p\leq \sqrt {\sqrt
n}=n^{\frac{1}{4}}\)</span> 的长度会出现循环。</p>
<p>算法复杂度是期望 <span class="math inline">\(O(n^{\frac{1}{4}}\log
n)\)</span> 的。</p>
<p>那么写出 <span
class="math inline">\(\text{Pollard&#39;s\_Rho}\)</span>
算法的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Pollards_Rho</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">	ll c=<span class="built_in">rand</span>(); <span class="comment">// 随机生成一个函数</span></span><br><span class="line">    ll x=<span class="built_in">rand</span>(),y=x,d=<span class="number">1</span>; <span class="comment">// 随机一个初始值</span></span><br><span class="line">    <span class="keyword">while</span>(d==<span class="number">1</span>)&#123;</span><br><span class="line">		x=(<span class="built_in">qmul</span>(x,x)+c)%n;</span><br><span class="line">		y=(<span class="built_in">qmul</span>(y,y)+c)%n;</span><br><span class="line">		y=(<span class="built_in">qmul</span>(y,y)+c)%n;</span><br><span class="line">		d=<span class="built_in">gcd</span>(n,<span class="built_in">abs</span>(x-y));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(d==n) <span class="keyword">return</span> <span class="built_in">Pollards_Rho</span>(n); <span class="comment">// 构造失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> d; <span class="comment">// 找到了p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不断调用即可完成对于n的质因数分解</p>
<p>对于质因数分解，更高级的算法可以参考<a
href="https://loj.ac/problem/6466">LOJ-6466</a></p>
<h3 id="莫比乌斯函数">莫比乌斯函数</h3>
<p>设 <span class="math inline">\(n=\prod_1^m p_i^{c_i}\)</span>，其中
<span class="math inline">\(c_i&gt;0,p_i\)</span> 为质数。</p>
<p>则莫比乌斯函数 <span
class="math inline">\(\mu(n)=\left\{\begin{aligned}1 &amp;&amp; n=1\\
(-1)^m &amp;&amp; \nexists c_i&gt;1 \\ 0 &amp;&amp; \exists
c_i&gt;1\end{aligned}\right.\)</span>。</p>
<h3 id="狄利克雷卷积">狄利克雷卷积</h3>
<p>对于数列 <span
class="math inline">\(F,G\)</span>，他们的狄利克雷卷积（下记作 <span
class="math inline">\(F\oplus G\)</span> ）为:</p>
<p><span class="math display">\[
(F\oplus G)_i=\sum_{d|i}F_d\cdot G_{\frac{i}{d}}
\]</span> <span class="math display">\[ \ \]</span></p>
<h3 id="莫比乌斯反演">莫比乌斯反演</h3>
<p>设元函数 <span class="math inline">\(E_i=1\)</span>，<span
class="math inline">\(G=F\oplus E\)</span>，即 <span
class="math inline">\(G_i=\sum_{d|i}F_d\)</span>.</p>
<p>由 <span class="math inline">\(G\)</span> 反解 <span
class="math inline">\(F\)</span> 得到莫比乌斯反演 <span
class="math inline">\(F_i=\sum_{d|i}\mu(d)
G_{\frac{i}{d}}\)</span>。</p>
<p><br></p>
<h3 id="积性函数">积性函数</h3>
<p><strong>积性函数</strong>的定义，对于一个定义在 <span
class="math inline">\(\Z\)</span> 上的函数$ F(n)$，若满足</p>
<p><span class="math inline">\(F(1)=1,\forall (u,v)=1,F(u)\cdot
F(v)=F(u\cdot v)\)</span>，则 <span class="math inline">\(F(u)\)</span>
是一个积性函数</p>
<p><strong>完全积性函数</strong>对于任意的 <span
class="math inline">\(u,v\)</span> 对满足上述性质</p>
<p>常见的积性函数有</p>
<ol type="1">
<li><p>元函数 <span class="math inline">\(e(n)=[n=1]\)</span>。</p></li>
<li><p>因数个数函数 <span class="math inline">\(d(n)\)</span>。</p></li>
<li><p>欧拉函数 <span
class="math inline">\(\varphi(n)\)</span>。</p></li>
<li><p>莫比乌斯系数 <span
class="math inline">\(\mu(n)\)</span>。</p></li>
<li><p>约数和函数 <span
class="math inline">\(\sigma(n)\)</span>。</p></li>
</ol>
<p>推论：任意两个积性函数的狄利克雷函数卷积仍然是积性函数。</p>
<h4 id="线性筛筛法求解积性函数">线性筛筛法求解积性函数</h4>
<p>把积性函数 <span class="math inline">\(F(n)\)</span> 表示为：</p>
<p><span class="math inline">\(F(n)=\left\{\begin{aligned} 1 &amp;&amp;
n=1 \\ G(n) &amp;&amp; n=p_i^t \\ \prod G(p_i^{c_i}) &amp;&amp; n=\prod
p_i^{c_i}\end{aligned}\right.\)</span></p>
<p>如果能在较短的时间内求得 <span
class="math inline">\(G(p_i^t)\)</span>，则可以用线性筛法求解积性函数
<span class="math inline">\(F(n)\)</span> 的前 <span
class="math inline">\(n\)</span> 项。</p>
<h5 id="一个最简单的应用-在-on-时间求解-idznnz">一个最简单的应用: 在
<span class="math inline">\(O(n)\)</span> 时间求解 <span
class="math inline">\(id^z(n)=n^z\)</span></h5>
<p>显然，<span class="math inline">\(id^z(n)\)</span>
是一个完全积性函数，且直接求复杂度为 <span class="math inline">\(O(n\log
z)\)</span>。</p>
<p>因为是完全积性函数，所以只需要求解 <span
class="math inline">\(id^z(p_i)\)</span>，这一部分复杂度为 <span
class="math inline">\(O(\pi(n)\cdot \log z)=O(n)\)</span>。</p>
<p>线性筛法的复杂度为 <span
class="math inline">\(O(n)\)</span>，因此总复杂度也为 <span
class="math inline">\(O(n)\)</span>。</p>
<p><del>(这就是传说中的魔法吗！！)</del></p>
<h5 id="一个简单的应用求解-mun">一个简单的应用：求解 <span
class="math inline">\(\mu(n)\)</span></h5>
<p>鉴于 <span class="math inline">\(\mu(n)\)</span>
的特殊性，也只需要求出 <span
class="math inline">\(\mu(p_i)\)</span>。</p>
<p>写出的代码大致是这样的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pri[N],notpri[N],pc,mu[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sieve_Mobius</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!notpri[i]) pri[++pc]=i,mu[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pc &amp;&amp; <span class="number">1ll</span>*i*pri[j]&lt;=n;++j) &#123;</span><br><span class="line">            notpri[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) &#123;</span><br><span class="line">                mu[i*pri[j]]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i*pri[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="真-应用-大型模板">真-应用: 大型模板</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CalcG</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> prime[N],primecnt,notprime[N];</span><br><span class="line"><span class="type">int</span> F[N],D[N];</span><br><span class="line"><span class="comment">// F存储函数值</span></span><br><span class="line"><span class="comment">// D存储质因数出现的幂次积</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sieve_Multiplicative_Function</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    F[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!notprime[i]) &#123;</span><br><span class="line">            prime[++primecnt]=i;</span><br><span class="line">            <span class="keyword">for</span>(ll j=i;j&lt;=n;j*=i) F[j]=<span class="built_in">CalcG</span>(j),D[j]=j;</span><br><span class="line">            <span class="comment">// 计算F(p_i^t)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=primecnt &amp;&amp; <span class="number">1ll</span>*i*prime[j]&lt;=n;++j) &#123;</span><br><span class="line">            notprime[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> k=i*prime[j];</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123;</span><br><span class="line">                D[k]=D[i] * prime[j];</span><br><span class="line">                F[k]=F[i/D[i]] * F[D[k]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            D[k]=prime[j];</span><br><span class="line">            F[k]=F[i] * F[prime[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="杜教筛">杜教筛</h3>
<p>用于求解 <strong>较大范围</strong> 且
<strong>可以构造出一些性质</strong>的积性函数 前缀和</p>
<p><a
href="https://www.cnblogs.com/chasedeath/p/13092808.html">不推荐看我的，但是还是放一下链接</a></p>
<p><br></p>
<h3 id="min25筛">Min25筛</h3>
<p>用于求 <strong>较大范围</strong> 且 <strong>使用范围更广</strong>
的积性函数前缀和 ， 但在效率上不敌杜教筛</p>
<p><a
href="https://www.cnblogs.com/chasedeath/p/12751225.html">还是放一下链接</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91/</url>
    <content><![CDATA[<hr />
<p>title: '最大流/最小割树/等价流树 学习笔记' date: 'Sat Aug 12 11:05:23
2023 categories: - oi-notes'</p>
<h1 id="最大流最小割树等价流树-学习笔记">最大流/最小割树/等价流树
学习笔记</h1>
<p>最小割树 <span class="math inline">\(\text{Gomory-Hu
Tree}\)</span></p>
<h4 id="前置">前置</h4>
<p>约定无向图点数为 <span class="math inline">\(n\)</span>，边数为 <span
class="math inline">\(m\)</span>。</p>
<p>割:断开一些边，使得 <span class="math inline">\(s,t\)</span>
两点不连通。</p>
<p>设 <span class="math inline">\(\lambda(u,v)\)</span> 为 <span
class="math inline">\(u,v\)</span> 的最小割权值。</p>
<p>在非负边权的无向图上使用网络流即可求得两点间的最小割，但是如果涉及查询所有点对的最小割，就需要进行
<span class="math inline">\(n^2\)</span> 次网络流，复杂度很高。</p>
<span id="more"></span>
<p><br></p>
<h2 id="简介">简介</h2>
<p>对于非负边权的无向图，适用于求出多点对之间的最小割/最大流的结构。</p>
<h3 id="textgomory-hu-tree的核心性质">1.<span
class="math inline">\(\text{Gomory-Hu Tree}\)</span>的核心性质</h3>
<p>构造树，使得树边 <span class="math inline">\((u,v)\)</span>
满足割掉这条边后，<span class="math inline">\(u,v\)</span>
的最小割对应将图分为树在两边的这两个集合。</p>
<p>而边 <span class="math inline">\((u,v)\)</span> 的权值 <span
class="math inline">\(w(u,v)=\lambda(u,v)\)</span>。</p>
<h3 id="求解最小割的方法">2.求解最小割的方法</h3>
<h4 id="引理">引理:</h4>
<p><span class="math inline">\(\lambda(a,b)\ge
\min\{\lambda(a,c),\lambda(c,b)\}\)</span></p>
<p>证明：假设 <span class="math inline">\(\lambda(a,b) &lt;
\min\{\lambda(a,c),\lambda(c,b)\}\)</span></p>
<p>设 <span class="math inline">\(a,b\)</span>
最小割的两个集合后两点所属的联通块集合为 <span
class="math inline">\(A,B\)</span>，则：</p>
<ol type="1">
<li><p>若 <span class="math inline">\(c\in A\)</span>，则 <span
class="math inline">\(a,b\)</span> 最小割也是 <span
class="math inline">\(b,c\)</span> 的割。</p></li>
<li><p>若 <span class="math inline">\(c\in B\)</span>，则 <span
class="math inline">\(a,b\)</span> 最小割也是 <span
class="math inline">\(a,c\)</span> 的割。</p></li>
</ol>
<p>以上两种情况均与 <span class="math inline">\(\lambda(a,b) &lt;
\min\{\lambda(a,c),\lambda(c,b)\}\)</span> 矛盾。</p>
<p><br></p>
<p>假设要求 <span class="math inline">\(u,v\)</span>
两点间的最短路，则答案就是 <span class="math inline">\(u,v\)</span>
在树上路径的最小边权值，设其为边 <span
class="math inline">\((s,t)\)</span>。</p>
<p>由上面的引理，显然有 <span
class="math inline">\(\lambda(u,v)\ge\lambda(s,t)\)</span>。</p>
<p>而我们由 <span class="math inline">\(\text{Gomory-Hu Tree}\)</span>
的性质知道，<span class="math inline">\(s,t\)</span> 的割也是 <span
class="math inline">\(u,v\)</span> 的一个割，即 <span
class="math inline">\(\lambda(u,v)\le \lambda(s,t)\)</span>。</p>
<p>所以答案就是 <span class="math inline">\(\lambda(s,t)\)</span>。</p>
<h2 id="构建方法">构建方法</h2>
<p>构建 <span class="math inline">\(\text{Gomory-Hu Tree}\)</span>
最重要的一条引理，可以认为是最小割的"不交叉"性质</p>
<p>对于 <span class="math inline">\(s,t\)</span>
最小割的一侧，设其点集为 <span
class="math inline">\(W\)</span>，则对于任意的 <span
class="math inline">\(u,v\in W\)</span>，存在一个 <span
class="math inline">\(s,t\)</span> 最小割 <span
class="math inline">\(X\)</span>，满足 <span
class="math inline">\(X\sube W\)</span>。</p>
<p>具体的证明比较复杂，<del>咕</del>，但是这个性质确实非常巧妙。</p>
<p>利用这个性质，可以得到 <span class="math inline">\(\text{Gomory-Hu
Tree}\)</span> 的<strong>不严谨的递归构造方法</strong>。</p>
<ol type="1">
<li><p>对于当前点集 <span class="math inline">\(S\)</span>，若 <span
class="math inline">\(|S|=1\)</span>，则结束递归。</p></li>
<li><p>从 <span class="math inline">\(S\)</span> 中选择两个点 <span
class="math inline">\(x,y\)</span> 求出最小割，设在割中 <span
class="math inline">\(x,y\)</span> 所属点集分别为<span
class="math inline">\(X,Y\)</span>。</p></li>
<li><p>在 <span class="math inline">\(\text{Gomory-Hu Tree}\)</span>
上加入边 <span
class="math inline">\((x,y,\lambda(x,y))\)</span>，递归解决子问题 <span
class="math inline">\(X\cap S,Y\cap S\)</span>。</p></li>
</ol>
<p><br></p>
<p>实际在递归求解 <span class="math inline">\(S\)</span>
的问题时，应该将图中其他的点缩点（这是论文里说的，实际没有人这么写）。</p>
<p><del>是不是不缩点跑出来的树形是错的?</del></p>
<p>递归求解的次数为 <span class="math inline">\(O(n)\)</span>，只需要求
<span class="math inline">\(O(n)\)</span> 次网络流即可。</p>
<p>放一下丑陋的板子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,M=<span class="number">6200</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> U[M],V[M],W[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125; e[M];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123; <span class="built_in">AddEdge</span>(u,v,w),<span class="built_in">AddEdge</span>(v,u,w); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erep(u,i) for(int i=head[u];i;i=e[i].nxt)</span></span><br><span class="line"><span class="type">int</span> dis[N],vc,S,T;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">rep</span>(i,<span class="number">1</span>,vc) head[i]=<span class="number">0</span>; ecnt=<span class="number">1</span>,vc=<span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,vc) dis[i]=INF;</span><br><span class="line">	<span class="type">static</span> queue &lt;<span class="type">int</span>&gt; que;</span><br><span class="line">	dis[S]=<span class="number">0</span>,que.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u=que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">erep</span>(u,i) &#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(!w || dis[v]&lt;=dis[u]+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			dis[v]=dis[u]+<span class="number">1</span>,que.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[T]&lt;INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> in)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==T) <span class="keyword">return</span> in;</span><br><span class="line">	<span class="type">int</span> out=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">erep</span>(u,i) &#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">		<span class="keyword">if</span>(!w || dis[v]!=dis[u]+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> t=<span class="built_in">Dfs</span>(v,<span class="built_in">min</span>(in-out,w));</span><br><span class="line">		e[i].w-=t,e[i^<span class="number">1</span>].w+=t,out+=t;</span><br><span class="line">		<span class="keyword">if</span>(in==out) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!out) dis[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">Bfs</span>()) ans+=<span class="built_in">Dfs</span>(S,INF);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Mincut</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">clear</span>(),vc=n,S=u,T=v;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">Link</span>(U[i],V[i],W[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Dinic</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector &lt;Pii&gt; G[N];</span><br><span class="line"><span class="type">int</span> P[N],R[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> x=P[l],y=P[l+<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> w=<span class="built_in">Mincut</span>(x,y);</span><br><span class="line">	<span class="type">int</span> p1=l<span class="number">-1</span>,p2=r+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,l,r) <span class="keyword">if</span>(dis[P[i]]&lt;INF) R[++p1]=P[i];</span><br><span class="line">	<span class="keyword">else</span> R[--p2]=P[i]; </span><br><span class="line">	<span class="built_in">rep</span>(i,l,r) P[i]=R[i];</span><br><span class="line">	G[x].<span class="built_in">pb</span>(<span class="built_in">mp</span>(y,w)),G[y].<span class="built_in">pb</span>(<span class="built_in">mp</span>(x,w));</span><br><span class="line">	<span class="built_in">Build</span>(l,p1),<span class="built_in">Build</span>(p2,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">10</span>],s[N][<span class="number">10</span>],dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=dep[u];++i) fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>],s[u][i]=<span class="built_in">min</span>(s[u][i<span class="number">-1</span>],s[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">for</span>(Pii t:G[u]) <span class="keyword">if</span>(t.first!=f) &#123;</span><br><span class="line">		<span class="type">int</span> v=t.first,w=t.second;</span><br><span class="line">		fa[v][<span class="number">0</span>]=u,s[v][<span class="number">0</span>]=w,dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="type">int</span> mi=<span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,del=dep[x]-dep[y];(<span class="number">1</span>&lt;&lt;i)&lt;=del;++i) <span class="keyword">if</span>(del&amp;(<span class="number">1</span>&lt;&lt;i)) <span class="built_in">cmin</span>(mi,s[x][i]),x=fa[x][i];</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span> mi;</span><br><span class="line">	<span class="built_in">drep</span>(i,<span class="number">9</span>,<span class="number">0</span>) <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) <span class="built_in">cmin</span>(mi,s[x][i]),<span class="built_in">cmin</span>(mi,s[y][i]),x=fa[x][i],y=fa[y][i];</span><br><span class="line">	<span class="built_in">cmin</span>(mi,s[x][<span class="number">0</span>]),<span class="built_in">cmin</span>(mi,s[y][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>()+<span class="number">1</span>,m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) U[i]=<span class="built_in">rd</span>()+<span class="number">1</span>,V[i]=<span class="built_in">rd</span>()+<span class="number">1</span>,W[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) P[i]=i; <span class="built_in">Build</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">LCA</span>(<span class="built_in">rd</span>()+<span class="number">1</span>,<span class="built_in">rd</span>()+<span class="number">1</span>));<span class="comment">//printf(&quot;%d\n&quot;,MinCut(rd()+1,rd()+1));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="等价流树">等价流树</h2>
<p>等价流树的树形不需要满足 <span class="math inline">\(\text{Gomory-Hu
Tree}\)</span> 的性质，只需要能够查询两点间的答案即可。</p>
<p>在论文中看到的等价流树的非递归构建方法（伪代码）。</p>
<p><span
class="math inline">\(w_{1,..,n}=0,fa_{1}=1,fa_{2,..,n}=1\)</span></p>
<p><span class="math inline">\(\text{for u = 2 to n do}\)</span> <span
class="math inline">\(v = fa_u\)</span></p>
<p>求解<span class="math inline">\(u,v\)</span>最小割</p>
<p>​ <span class="math inline">\(w_u=\lambda(u,v)\)</span></p>
<p>​ <span class="math inline">\(\text{for x=u+1 to n do}\)</span></p>
<p>​ <span class="math inline">\(\text{if} fa_x=v \text{ and x在u这一侧
then }fa_x=u\)</span></p>
<p>​ <span class="math inline">\(\text{end for}\)</span></p>
<p><span class="math inline">\(\text{end for}\)</span></p>
<p>但是这个东西实际也不会跑得比 <span
class="math inline">\(\text{Gomory-Hu Tree}\)</span>
快，了解一下即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">860</span>,M=<span class="number">170010</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> U[M],V[M],W[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125; e[M];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123; <span class="built_in">AddEdge</span>(u,v,w),<span class="built_in">AddEdge</span>(v,u,w); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erep(u,i) for(int i=head[u];i;i=e[i].nxt)</span></span><br><span class="line"><span class="type">int</span> dis[N],vc,S,T;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">rep</span>(i,<span class="number">1</span>,vc) head[i]=<span class="number">0</span>; ecnt=<span class="number">1</span>,vc=<span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,vc) dis[i]=INF;</span><br><span class="line">	<span class="type">static</span> queue &lt;<span class="type">int</span>&gt; que;</span><br><span class="line">	dis[S]=<span class="number">0</span>,que.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u=que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">erep</span>(u,i) &#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(!w || dis[v]&lt;=dis[u]+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			dis[v]=dis[u]+<span class="number">1</span>,que.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[T]&lt;INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> in)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==T) <span class="keyword">return</span> in;</span><br><span class="line">	<span class="type">int</span> out=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">erep</span>(u,i) &#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">		<span class="keyword">if</span>(!w || dis[v]!=dis[u]+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> t=<span class="built_in">Dfs</span>(v,<span class="built_in">min</span>(in-out,w));</span><br><span class="line">		e[i].w-=t,e[i^<span class="number">1</span>].w+=t,out+=t;</span><br><span class="line">		<span class="keyword">if</span>(in==out) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!out) dis[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">Bfs</span>()) ans+=<span class="built_in">Dfs</span>(S,INF);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Mincut</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">clear</span>(),vc=n,S=u,T=v;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">Link</span>(U[i],V[i],W[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Dinic</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) U[i]=<span class="built_in">rd</span>(),V[i]=<span class="built_in">rd</span>(),W[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n) fa[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(u,<span class="number">2</span>,n) &#123;</span><br><span class="line">		<span class="type">int</span> v=fa[u]; w[u]=<span class="built_in">Mincut</span>(v,u);</span><br><span class="line">		<span class="built_in">rep</span>(x,u+<span class="number">1</span>,n) <span class="keyword">if</span>(fa[x]==v &amp;&amp; dis[x]==INF) fa[x]=u;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE/</url>
    <content><![CDATA[<hr />
<p>title: '最小树形图 | 最小内向森林' date: 'Sat Aug 12 11:05:23 2023
categories: - oi-notes'</p>
<h1 id="最小树形图-最小内向森林">最小树形图 | 最小内向森林</h1>
<h2 id="最小树形图">最小树形图</h2>
<p>对于带权有向图 <span class="math inline">\(G=(V,E)\)</span>。</p>
<p>对于根 <span class="math inline">\(root\)</span> 最小树形图为以 <span
class="math inline">\(root\)</span> 为根的外向树最小边权和。</p>
<h3 id="有根树的树形图">有根树的树形图</h3>
<p>对于确定的 <span class="math inline">\(root\)</span>
求最小树形图。</p>
<span id="more"></span>
<h3 id="朱刘算法">朱刘算法</h3>
<p>核心:</p>
<ol type="1">
<li>对于有向图上的一个非根节点，对于它的所有入边加减一个权值 <span
class="math inline">\(v\)</span>，最优解的树形图形态不变。</li>
</ol>
<p>因为所有非根点必然有一条入边，所以可以对于每个点，取入边边权最小值减去，把减去的部分加入答案。</p>
<p>经过这样的操作使得每条边边权非负，且每个点都有一条为 0 的入边。</p>
<p><br></p>
<ol start="2" type="1">
<li>对于权<strong>非负</strong>的有向图上，如果存在<strong>一个边权均为0的环</strong>，可以把环上的点收缩。</li>
</ol>
<p>因为无论最后得到的树形图如何连边，一定可以通过断掉环上的一条边来生成一个可行的树形图。</p>
<p>算法流程</p>
<ol type="1">
<li><p>为每个点的入边更改边权</p></li>
<li><p>收缩0环</p>
<ol type="1">
<li>存在环 : 回到1，</li>
<li>不存在环：结束算法。</li>
</ol></li>
</ol>
<p>此时存在两种情况</p>
<ol type="1">
<li><p>图不连通，无解，</p></li>
<li><p>图联通，每个点一定存在一条为 0
的入边，取出一个合法边集，然后依次展开每个被收缩的 0
环，即可得到一个最小树形图方案</p></li>
</ol>
<p>复杂度分析：</p>
<p>每次收缩环需要依次遍历，每次至少缩小一个点，因此复杂度上限为 <span
class="math inline">\(O(nm)\)</span>。</p>
<p><br></p>
<p>Tips:</p>
<ol type="1">
<li><p>注意不要更改根的入边。</p></li>
<li><p>0 边构成的的图不连通。</p></li>
</ol>
<p>实现：只记录一条 0 边指向的点，找环。</p>
<p><br></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,rt,ans;</span><br><span class="line"><span class="type">int</span> U[N],V[N],W[N];</span><br><span class="line"><span class="type">int</span> id[N],inw[N],pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reweight</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) inw[i]=INF,pre[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>(U[i]!=V[i] &amp;&amp; V[i]!=rt) <span class="keyword">if</span>(inw[V[i]]&gt;W[i]) inw[V[i]]=W[i],pre[V[i]]=U[i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(i!=rt &amp;&amp; id[i]==i) &#123;</span><br><span class="line">		 <span class="keyword">if</span>(inw[i]==INF) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		 ans+=inw[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>(U[i]!=V[i] &amp;&amp; V[i]!=rt) W[i]-=inw[V[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Union</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> fl=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) vis[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(id[i]==i &amp;&amp; !vis[i]) &#123;</span><br><span class="line">		<span class="type">int</span> u=i;</span><br><span class="line">		<span class="keyword">while</span>(u &amp;&amp; !vis[u]) vis[u]=i,u=pre[u];</span><br><span class="line">		<span class="keyword">if</span>(vis[u]==i) &#123;</span><br><span class="line">			<span class="type">int</span> v=pre[u];</span><br><span class="line">			fl=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(v!=u) id[v]=u,v=pre[v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),rt=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) id[i]=i;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) U[i]=<span class="built_in">rd</span>(),V[i]=<span class="built_in">rd</span>(),W[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">Reweight</span>();</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">Union</span>()) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m) U[i]=id[U[i]],V[i]=id[V[i]];</span><br><span class="line">		rt=id[rt];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="可并堆优化朱刘算法">可并堆优化朱刘算法</h3>
<p>涉及到的操作：</p>
<ol type="1">
<li><p>依次插入每个点，为其确定一条最小的出边，</p></li>
<li><p>如果出边（0边）构成了环，将环上的点缩点，</p></li>
<li><p>合并环上点的点出边集合，并将这个点重新加入待定点集。</p></li>
</ol>
<p><br></p>
<p>3 操作要用可并堆维护合并点集入边的最小权值，并且支持全局减操作。</p>
<p>2
操作用并查集维护判断是否出现了环，我写得比较丑，一个并查集存缩点之后新点的编号，一个存点所在连通块。</p>
<p>比较常见的实现是左偏树，因为便于全局修改的标记下传操作，代码也比较好写</p>
<p>用可并堆维护朱刘算法的操作，单次合并操作为<span
class="math inline">\(O(\log m)\)</span>，因此复杂度为<span
class="math inline">\(O((n+m)\log m)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,rt,ans;</span><br><span class="line"><span class="comment">// 轻度封装的左偏树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Heap *ls,*rs;</span><br><span class="line">    Pii val;</span><br><span class="line">    <span class="type">int</span> tag,dis;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Down</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ls) ls-&gt;val.first+=tag,ls-&gt;tag+=tag;</span><br><span class="line">        <span class="keyword">if</span>(rs) rs-&gt;val.first+=tag,rs-&gt;tag+=tag;</span><br><span class="line">        tag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Up</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs &amp;&amp; (!ls || rs-&gt;dis&gt;ls-&gt;dis)) <span class="built_in">swap</span>(ls,rs);</span><br><span class="line">        dis=rs?rs-&gt;dis+<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Heap</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Heap</span>(Pii x)&#123; ls=rs=<span class="number">0</span>,val=x,tag=<span class="number">0</span>,dis=<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Heap* <span class="title">Union</span><span class="params">(Heap* a,Heap *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;val&gt;b-&gt;val) <span class="built_in">swap</span>(a,b);</span><br><span class="line">        a-&gt;<span class="built_in">Down</span>(),a-&gt;rs=<span class="built_in">Union</span>(a-&gt;rs,b);</span><br><span class="line">        <span class="keyword">return</span> a-&gt;<span class="built_in">Up</span>(),a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; tag+=x,val.first+=x; &#125;</span><br><span class="line">    <span class="function">Pii <span class="title">top</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function">Heap* <span class="title">pop</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">Down</span>(),<span class="built_in">Union</span>(ls,rs); &#125;</span><br><span class="line">&#125; *H[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> F[N],J[N]; <span class="comment">// F存连通块，J存编号</span></span><br><span class="line">Pii G[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> F[x]==x?x:F[x]=<span class="built_in">Find</span>(F[x]); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">I</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> J[x]==x?x:J[x]=<span class="built_in">I</span>(J[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Work</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 依次加入每个点，先把自环弹掉</span></span><br><span class="line">    <span class="keyword">while</span>(H[i] &amp;&amp; <span class="built_in">I</span>(H[i]-&gt;<span class="built_in">top</span>().second)==i) H[i]=H[i]-&gt;<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(!H[i]) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    G[i]=H[i]-&gt;<span class="built_in">top</span>(),H[i]-&gt;<span class="built_in">Add</span>(-G[i].first),H[i]=H[i]-&gt;<span class="built_in">pop</span>();</span><br><span class="line">    ans+=G[i].first;</span><br><span class="line">    <span class="type">int</span> v=<span class="built_in">I</span>(G[i].second);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Find</span>(i)!=<span class="built_in">Find</span>(v)) F[<span class="built_in">Find</span>(i)]=<span class="built_in">Find</span>(v);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=v;u!=i;u=<span class="built_in">I</span>(G[u].second)) J[<span class="built_in">I</span>(u)]=i,H[i]=<span class="built_in">Union</span>(H[i],H[u]);</span><br><span class="line">        <span class="built_in">Work</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),rt=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) J[i]=F[i]=i;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>(),w=<span class="built_in">rd</span>();</span><br><span class="line">        H[v]=<span class="built_in">Union</span>(H[v],<span class="keyword">new</span> <span class="built_in">Heap</span>(<span class="built_in">mp</span>(w,u)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(<span class="built_in">I</span>(i)==i &amp;&amp; i!=rt) <span class="built_in">Work</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="无根树的最小树形图">无根树的最小树形图</h3>
<p>建立超级源点 <span class="math inline">\(S\)</span> 向 <span
class="math inline">\(V\)</span>
中的点连边权极大的边，以限制每次只选一条这样的边。</p>
<p>单次得到答案后减去这个极大值即可，注意如果答案中出现多个这样的极大值，说明原图无解是无解的。</p>
<p><br></p>
<h2 id="最小内向森林">最小内向森林</h2>
<p>对于给定的值 <span
class="math inline">\(k\)</span>，最小内向森林是一个有根树集合，且其恰好包含
<span class="math inline">\(k\)</span> 条边。</p>
<p><br></p>
<h3 id="凸优化朱刘算法">凸优化+朱刘算法</h3>
<p>最小内向森林问题是一个<strong>凸函数问题</strong>，可以考虑 <span
class="math inline">\(\text{wqs}\)</span> 二分。</p>
<p>同样建立超级原点 <span class="math inline">\(S\)</span>，二分原点
<span class="math inline">\(S\)</span> 向 <span
class="math inline">\(V\)</span> 中点连的边权 <span
class="math inline">\(\alpha\)</span>。</p>
<p>通过朱刘算法得到新图的最小树形图。</p>
<p>二分使得最终的树形图包含原点度数为 <span
class="math inline">\(|V|-1-k\)</span> 即可。</p>
<p><br></p>
<h3 id="优先内向树扩张算法">优先内向树扩张算法</h3>
<p>考虑在上面二分的过程中，一个点向原点连边当且仅当这个点不再有边边权
<span class="math inline">\(&lt;\alpha\)</span>。</p>
<p>同时一旦这个点向原点连边，就不再会与其他任何点合并。</p>
<p>也就是这点的所有出边再减去下一条最小树边权值之后，存在一个 <span
class="math inline">\(\alpha&#39;&lt;0\)</span>。</p>
<p>容易想到按照每个点最小边的边权为优先级进行操作。</p>
<p>最后被扩展的边的实际上就是我们要找的 <span
class="math inline">\(\alpha\)</span>。</p>
<p>令 <span class="math inline">\(dec_u\)</span> 表示 <span
class="math inline">\(u\)</span>
节点中，被合并上来所有节点已经减掉的值的最大值。</p>
<p><span class="math inline">\(dec_u&#39;=dec_u+\min
\{w_{v,u}\}\)</span>，合并时 <span class="math inline">\(dec_u\)</span>
取 <span class="math inline">\(\max\)</span>。</p>
<p>按照 <span class="math inline">\(dec&#39;_u\)</span>
递增的顺序考虑每个点的扩张，最后一个 <span
class="math inline">\(dec&#39;_u\)</span> 就是我们所需要的 <span
class="math inline">\(\alpha\)</span>。</p>
<p>用一个额外的堆维护 <span class="math inline">\(dec&#39;_u\)</span>
的权值，直到扩张满 <span class="math inline">\(k\)</span> 次即可。</p>
<p>复杂度为 <span class="math inline">\(O((n+m)\log m+n\log
n)\)</span>。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%88%97%E5%BC%8F/</url>
    <content><![CDATA[<hr />
<p>title: '矩阵行列式' date: 'Sat Aug 12 11:05:23 2023 categories: -
oi-notes'</p>
<h1 id="矩阵行列式">矩阵行列式</h1>
<p>对于一个 <span class="math inline">\(n\)</span> 行 <span
class="math inline">\(n\)</span> 列的矩阵 <span
class="math inline">\(A\)</span>，有矩阵的行列式（常用 <span
class="math inline">\(\det(A),|A|\)</span> ）表示。</p>
<h3 id="行列式的意义">行列式的意义</h3>
<p>如果将矩阵的每一行视为一个 <span class="math inline">\(n\)</span>
维向量，则 <span class="math inline">\(n\)</span>
阶行列式的意义可以看做是有向长度/面积/体积在 <span
class="math inline">\(n\)</span> 为空间下的扩展。</p>
<p>具体的例子：</p>
<p><span class="math inline">\(n=1\)</span> 时，<span
class="math inline">\(|A|=A_{1,1}\)</span>，即有向长度。</p>
<p><span class="math inline">\(n=2\)</span> 时，<span
class="math inline">\(|A|=A_{1,1}A_{2,2}-A_{1,2}A_{2,1}=\vec{A_1}\times
\vec{A_2}\)</span>。</p>
<p>因此也可以得到常用的一个 3维向量外积的表达式</p>
<p><span class="math display">\[
\vec{a}\times \vec{b}=\begin{vmatrix} \vec{x}\ \ \vec{y}\ \ \vec{z} \\
a_1\ a_2\ a_3\\ b_1\ b_2\ b_3\end{vmatrix}
\]</span> 其中 <span
class="math inline">\(\vec{x},\vec{y},\vec{z}\)</span>
是三维平面的三个维度的单位向量。</p>
<p>上式即将有向体积中的一个向量改为单位向量后压缩到一个平面上。</p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="最基本的求法">最基本的求法：</h3>
<p>枚举 <span class="math inline">\(1,2,\cdots,n\)</span> 的一个排列
<span class="math inline">\(p_i\)</span>，设排列 <span
class="math inline">\(p\)</span> 的逆序对为 <span
class="math inline">\(f(p)\)</span>。</p>
<p>则 <span class="math inline">\(\displaystyle |A|=\sum (-1)^{f(p)} \Pi
A_{i,p_i}\)</span>，其中 <span
class="math inline">\((-1)^{f(p)}\)</span> 也记作 <span
class="math inline">\(\sigma(p),\text{sgn}(p)\)</span>。</p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="矩阵行列式的性质">矩阵行列式的性质：</h3>
<p>1.交换任意两行（列）得到矩阵 <span
class="math inline">\(A&#39;\)</span>，则 <span
class="math inline">\(|A&#39;|=-|A|\)</span> （交换后每个排列 <span
class="math inline">\(f(p)\)</span> 的奇偶性改变）。</p>
<p>2.对于某一行（列）乘上一个值 <span class="math inline">\(k\)</span>
得到矩阵 <span class="math inline">\(A&#39;\)</span>，则 <span
class="math inline">\(|A&#39;|=k|A|\)</span>。</p>
<p>3.某一行减去另一行的 <span class="math inline">\(k\)</span>
倍得到矩阵 <span class="math inline">\(A&#39;\)</span>，则 <span
class="math inline">\(|A&#39;|=|A|\)</span>。</p>
<h3 id="根据性质得到的快速求法">根据性质得到的快速求法</h3>
<p>根据性质1,2,3 可以对于矩阵进行高斯消元。</p>
<p>而对于一个上三角/下三角矩阵，带入上面的基本求法，显然能够得到 非 0 值
的排列只有对角线 <span class="math inline">\(p_i=i\)</span>。</p>
<p>因此得到上/下三角矩阵之后就可以快速求解，复杂度为高斯消元的 <span
class="math inline">\(O(n^3)\)</span>。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E5%AF%BC%E5%BC%95/</url>
    <content><![CDATA[<hr />
<p>title: '复习导引' date: 'Sat Aug 12 11:05:23 2023 categories: -
oi-notes'</p>
<h1 id="复习导引">复习导引</h1>
<h3 id="part1-序列类">Part1 序列类</h3>
<ol type="1">
<li>多功能型：</li>
</ol>
<p>1.1分块，莫队(奇偶排序加速莫队)</p>
<p>1.2树状数组</p>
<p>1.3线段树，函数式线段树，可持久化函数式线段树(主席树)，<span
class="math inline">\(\text{Segmentbeats}\)</span>(吉老师树) , <span
class="math inline">\(\text{ZKW}\)</span>线段树，线段树合并</p>
<p>1.4二叉堆，左偏树，配对堆，可持久化左偏树</p>
<p>1.5平衡树：<span class="math inline">\(\text{Splay}\)</span>，<span
class="math inline">\(\text{Treap}\)</span>，非旋<span
class="math inline">\(\text{Treap}\)</span>，可以持久化非旋<span
class="math inline">\(\text{Treap}\)</span></p>
<p>1.6李超树</p>
<p>17.线段树分治，半动态线段树分治（一边分治一边得到加边的范围）</p>
<p>1.7<span class="math inline">\(\text{K-D Tree}\)</span></p>
<p>1.8树套树，<span
class="math inline">\(\text{CDQ}\)</span>分治，高维问题</p>
<p>1.9莫队二次离线</p>
<span id="more"></span>
<p>2.特殊型：</p>
<p>2.1单调栈/单调队列，<span
class="math inline">\(\text{Sparse\_Table}\)</span>，笛卡尔树</p>
<p>2.2并查集，按秩合并，可持久化并查集</p>
<p>(2.3猫树，珂朵莉树)</p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="dp">dp</h3>
<p>1.决策单调性</p>
<p>分治决策单调性，四边形不等式</p>
<p>2.斜率优化</p>
<p>单调栈/单调队列维护凸包，单调队列查询或者二分单调栈</p>
<p>以及李超树暴力维护</p>
<p>3.分数规划</p>
<p>形如求<span
class="math inline">\(\displaystyle(\frac{p}{q})_{max}\)</span>的，二分答案<span
class="math inline">\(k\)</span>然后求<span
class="math inline">\((p-kq)_{max}\)</span>，称为分数规划</p>
<p>4.数位dp</p>
<p>注意 正向/逆向dp 的大小判断方法</p>
<p>5.插头dp</p>
<p>熟悉二进制维护状态的方法</p>
<p>6.有限自动机上的<span class="math inline">\(dp\)</span>状态定义</p>
<p>7.花样容斥</p>
<p>7.1奇偶容斥<span
class="math inline">\((-1)^{j-i}\)</span>，二项式反演</p>
<p>7.2<span class="math inline">\(\text{MinMax}\)</span>容斥 [ZJOI2020]
抽卡70分做法</p>
<p>7.3分层图容斥(巨神兵)</p>
<p>8.状态割裂 (COCI20162017 Contest#6 F)</p>
<p>9.二项展开/斯特林数展开求<span
class="math inline">\((\sum)^k\)</span></p>
<p>10.<a
href="https://www.cnblogs.com/chasedeath/p/13538059.html">小体积的背包问题</a></p>
<p>11.降阶子问题[HDU-6848]</p>
<p>12.<span class="math inline">\(dp\)</span>套<span
class="math inline">\(dp\)</span></p>
<p>13.无限问题的循环节<span class="math inline">\(dp\)</span> 「CTS2019
| CTSC2019」重复</p>
<p>14.树上动态<span class="math inline">\(dp\)</span></p>
<p>15.<span class="math inline">\(\text{dfs}\)</span>序<span
class="math inline">\(dp\)</span> [HDU-5909]
「清华集训2016」连通子树</p>
<p>16.斯坦纳树 「THUSCH 2017」巧克力</p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="树上">树上</h3>
<p>1.倍增，树剖，<span class="math inline">\(\text{tarjan
LCA}\)</span>，<span class="math inline">\(\text{Euler}\)</span>序<span
class="math inline">\(\text{LCA}\)</span></p>
<p>2.合并连通块的直径</p>
<p>3.<span class="math inline">\(\text{DSU on Tree}\)</span></p>
<p>4.点分治/边分治，动态点分治</p>
<p>边分治：将多度点建立虚边，下分为二叉树，然后找到边中心</p>
<p>5.虚树</p>
<p>6.树<span class="math inline">\(\text{hash}\)</span></p>
<p>7.<span class="math inline">\(\text{Kruskal}\)</span>重构树</p>
<p>8.<span class="math inline">\(\text{Prufer}\)</span>序列<span
class="math inline">\((n^{n-2})\)</span></p>
<p>9.最小树形图[朱-刘算法]</p>
<p>10.多树问题：点分治+虚树+数据结构</p>
<p>11.<span class="math inline">\(\text{LCT}\)</span></p>
<p>(12.<span class="math inline">\(\text{Top Tree}\)</span>)</p>
<p>(13.树分块)</p>
<h3 id="图论线性规划">图论/线性规划</h3>
<p><span class="math inline">\(G=(V,E)\)</span></p>
<p>1.点双，边双</p>
<p>2.基环树</p>
<p>3.仙人掌，圆方树</p>
<p>4.<span
class="math inline">\(\text{SPFA,Dijkstra,Johnson}\)</span></p>
<p>5.差分约束</p>
<p>6.网络流，预流推进，费用流，<span
class="math inline">\(\text{Dijkstra}\)</span>费用流，上下界网络流，最大流/最小割树，(<span
class="math inline">\(\text{Stoer-Wagner}\)</span>算法)</p>
<p>7.二分图匈牙利，一般图带花树，带权<span
class="math inline">\(\text{Kuhn–Munkres}\)</span>(注意复习Luogu/UOJ上的<span
class="math inline">\(\text{BFS}\)</span>版本)</p>
<p>8.<span
class="math inline">\(2-\text{sat}\)</span>，注意方案输出方法</p>
<p>9.欧拉回路(UOJ模板)，(哈密顿路？)</p>
<p>10.平面图的欧拉定理</p>
<p>(11.弦图)</p>
<p>12.对偶</p>
<p>13.单纯形</p>
<p>14.拟阵交</p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="字符串">字符串</h3>
<p>1.<span class="math inline">\(\text{hash,kmp,AC
Automaton}\)</span></p>
<p>2.<span
class="math inline">\(\text{Manacher}\)</span>(马拉车。。)，<span
class="math inline">\(\text{Palindrome
Automaton}\)</span>(回文自动机)</p>
<p>3.<span
class="math inline">\(SA\)</span>后缀数组(倍增,DC3,SAIS)，<span
class="math inline">\(SAM\)</span>后缀自动机，广义<span
class="math inline">\(\text{SAM}\)</span>(多串)</p>
<p><span class="math inline">\(\text{SA}:\)</span>常见：按照<span
class="math inline">\(\text{LCP}\)</span>大小分段进行统计</p>
<p><span class="math inline">\(\text{SAM}:\)</span>结合树，<span
class="math inline">\(\text{LCA}\)</span></p>
<p>4.<span class="math inline">\(\text{Trie}\)</span>即可持久化</p>
<p>5.<span class="math inline">\(\text{Period,Border}\)</span></p>
<p>6.(<span class="math inline">\(\text{Exkmp}(Z\)</span>函数<span
class="math inline">\()\)</span>)</p>
<p>7.<span class="math inline">\(\text{Lyndon}\)</span>分解</p>
<p>8.最小循环同构<span class="math inline">\(O(n)\)</span></p>
<p>9.<span class="math inline">\(\text{Runs}\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="贪心博弈结论">贪心/博弈/结论</h3>
<p>1.<span class="math inline">\(\text{Nim}\)</span>，反<span
class="math inline">\(\text{Nim}\)</span>，<span
class="math inline">\(k\)</span>进制<span
class="math inline">\(\text{Nim}\)</span> (CodeChef November
Challenge2019 Winning Ways)</p>
<p>2.威佐夫博弈</p>
<ol start="3" type="1">
<li></li>
</ol>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="数学">数学</h3>
<p><span class="math inline">\(\text{Matrix-Tree}\)</span>定理即扩展</p>
<p>11.<span class="math inline">\(\text{DAG}\)</span>的<span
class="math inline">\(\text{LGV}\)</span>引理 [HDU-5852]</p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%E7%9A%84%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<hr />
<p>title: '线性递推的求解（Berlekamp-Massey）' date: 'Sat Aug 12
11:05:23 2023 categories: - oi-notes'</p>
<h1
id="线性递推的求解berlekamp-massey">线性递推的求解（Berlekamp-Massey）</h1>
<p>参考文献：2019集训队论文，钟子谦《两类递推数列的性质和应用》</p>
<p>这篇文章介绍如何求解，线性递推的应用更多在<a href="">这里</a></p>
<p>数列 <span class="math inline">\(\{a_0,a_1,\cdots \}\)</span>，</p>
<p>向量序列 <span
class="math inline">\(\{v_0,v_1,\cdots\}\)</span>，</p>
<p>矩阵序列 <span
class="math inline">\(\{M_0,M_1,\cdots\}\)</span>。</p>
<p>的线性递推</p>
<p>序列 <span class="math inline">\(a_0,a_1,\cdots,a_n\)</span>
的线性递推的定义为：</p>
<ol type="1">
<li><p>对于一个常数列 <span
class="math inline">\(r_0,r_1,\cdots,r_m(r_0=1)\)</span></p></li>
<li><p>记 <span
class="math inline">\(\lambda(i,r)=\sum_{j=1}^{m}a_{i-j}r_j\)</span></p>
<p><span class="math inline">\(\Delta(i,r)=\sum_{j=0}^m
a_{i-j}\)</span></p></li>
</ol>
<p>则满足 <span class="math inline">\(\forall i\ge
m,\Delta(i,r)=0\)</span> 的序列为一个线性递推序列。</p>
<p>稍作变换可以得到更加符合常理的形式：<span
class="math inline">\(a_i=\sum_{j=1}^m r&#39;_j \cdot
a_{i-j}\)</span>。</p>
<span id="more"></span>
<p><br></p>
<h2
id="求解序列的最短线性递推-berlekamp-massey-算法">求解序列的最短线性递推:
Berlekamp-Massey 算法</h2>
<p>对于一个 <span class="math inline">\(n\)</span> 个元素的数列 <span
class="math inline">\(a_{1,\cdots,
n}\)</span>，求出它的<strong>最短线性递推式</strong>。</p>
<p>为了便于理解约定下文求出的是最小的 <span
class="math inline">\(m\)</span> 和对应的 <span
class="math inline">\(r_1,\cdots r_m\)</span> 使得 <span
class="math inline">\(\forall i\in
[m+1,n],a_i=\sum_{j=1}^{m}a_{i-j}r_j\)</span>。</p>
<p>很显然使用<strong>高斯消元</strong>可以在 <span
class="math inline">\(O(n^3)\)</span> 的时间内求解。</p>
<p>而 <span class="math inline">\(\text{Berlekamp-Massey(BM)}\)</span>
算法是通过依次对于前 <span class="math inline">\(i\)</span> 项构造，</p>
<p>添加每一项时在 <span class="math inline">\(O(n)\)</span>
的时间内找到一个可行的构造方法，将复杂度降低到了 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p><br></p>
<p><br></p>
<h3 id="算法过程">算法过程</h3>
<p>为了更好描述，设 <span class="math inline">\(r\)</span> 的阶为 <span
class="math inline">\(d(r)\)</span>。</p>
<p>考虑依次加入每个数 <span class="math inline">\(a_i\)</span>，设当前
<span class="math inline">\(d(r)=m\)</span>，上一次的递推是 <span
class="math inline">\(p\)</span>,<span class="math inline">\(p\)</span>
出现不匹配的位置是 <span class="math inline">\(f\)</span>。</p>
<p>特别的，初始状态的递推是 <span
class="math inline">\(r=\{\},f=0\)</span>。</p>
<ol type="1">
<li><p><span
class="math inline">\(\Delta(i,r)=0\)</span>，那么不需要扩展。</p></li>
<li><p><span class="math inline">\(\Delta(i,r)\ne 0\)</span>，</p>
<ol type="1">
<li><p><span
class="math inline">\(m=0\)</span>，此时只有一种情况即插入了第一个 <span
class="math inline">\(a_i\ne 0\)</span>，唯一的递推序列就是 <span
class="math inline">\(d(r&#39;)=i,r_j=0(j&gt;0)\)</span>，此时显然成立</p></li>
<li><p><span class="math inline">\(m\ne 0\)</span>，构造思路是找到一个
<span class="math inline">\(r&#39;\)</span> 使得 <span
class="math inline">\(\forall
j\in[d(r&#39;),i-1],\lambda(j,r&#39;)=0\and \lambda
(n,r&#39;)=\Delta(i-1,r)\)</span>。</p>
<p>那么当前合法的转移就是 <span
class="math inline">\(r+r&#39;\)</span>。</p>
<p>设 <span
class="math inline">\(t=\frac{\Delta(n,r)}{\Delta(f,p)}\)</span>。</p>
<p>构造 <span class="math inline">\(r&#39;=t \cdot
x^{i-f-1}(1-p)\)</span>。</p>
<p>写出来就是:</p></li>
</ol></li>
</ol>
<p><span class="math inline">\(r&#39;=\{\underbrace{0,\cdots,0},t\cdot
(1-p)\}\)</span></p>
<p>$         i-f-1$个<span class="math inline">\(0\)</span></p>
<p><span
class="math inline">\(r&#39;=\{\underbrace{0,\cdots,0},t,-t\cdot
p_{1},-t\cdot p_{2}\cdots,-t\cdot p_{d(p)}\}\)</span></p>
<p>$         i-f-1$个<span class="math inline">\(0\)</span></p>
<p>此时，<span class="math inline">\(d(r&#39;)=i-f+d(p)\)</span>。</p>
<p>当 <span class="math inline">\(j\in [d(r&#39;)+1,i-1]\)</span>
时，<span
class="math inline">\(\lambda(j,r&#39;)=\sum_{k=i-f}^{d(r&#39;)}a_{j-k}r&#39;_k=t\cdot(
a_{j-(i-f)}-\lambda(j-(i-f),p))\)</span>。</p>
<p>由于 <span class="math inline">\(p\)</span> 对于 <span
class="math inline">\(j\in[d(r&#39;)+1-(i-f),i-1-(i-f)]=[d(p)+1,f-1]\)</span>，<span
class="math inline">\(p\)</span> 这个递推式成立。</p>
<p>即 <span class="math inline">\(\lambda(j,r&#39;)=0\)</span>。</p>
<p>当 <span class="math inline">\(j=i\)</span> 时，</p>
<p><span class="math inline">\(\lambda(i,r&#39;)=t\cdot
(a_{i-(i-f)}+\lambda(i-(i-f),p))=t\cdot \Delta(f,p)\)</span></p>
<p>即 <span class="math inline">\(\lambda
(i,r&#39;)=\Delta(n,r)\)</span>。</p>
<p>完成了我们想要的构造，所以每次记录上一次的失配位置，即可找到最小递推式。</p>
<p>关于为什么求得的就是最小递推，可以看论文里的证明。</p>
<h2 id="求解向量序列的线性递推">求解向量序列的线性递推</h2>
<p>对于长度为 <span class="math inline">\(n\)</span> 的向量序列 <span
class="math inline">\(\{v_0,v_1,\cdots\}\)</span>。</p>
<p>在模 <span class="math inline">\(P\)</span> 意义下，随机一个向量
<span class="math inline">\(u\)</span>，构造标量序列 <span
class="math inline">\(\{v_0u,v_1u,\cdots\}\)</span>。</p>
<p>构造和求解这个标量序列的线性递推，复杂度均为 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>求得的线性递推也为向量序列的线性递推的概率为 <span
class="math inline">\(1-\frac{n}{P}\)</span>，通常认为不会错。</p>
<p><del>（可以认为复杂度与读入同阶?）</del></p>
<p><br></p>
<h2 id="求解矩阵序列的线性递推">求解矩阵序列的线性递推</h2>
<p>对于长度为 <span class="math inline">\(n\)</span> 的矩阵序列 <span
class="math inline">\(\{M_0,M_1,\cdots\}\)</span>。</p>
<p>同样在模 <span class="math inline">\(P\)</span> 意义下，随机两个向量
<span class="math inline">\(u,v\)</span>，构造标量序列 <span
class="math inline">\(\{uM_0v,uM_1v,\cdots\}\)</span>。</p>
<p>求解线性递推的复杂度为 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>但是构造标量序列需要计算 <span class="math inline">\(n\)</span>
次向量与矩阵的乘法，复杂度为 <span
class="math inline">\(O(n^3)\)</span>。</p>
<p><del>（可以认为复杂度与读入同阶?）</del></p>
]]></content>
  </entry>
  <entry>
    <title># 组合数公式</title>
    <url>/oi-notes/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    <content><![CDATA[<hr />
<p>组合数 <span class="math inline">\(\displaystyle
C(n,m)=C_n^m=\binom{n}{m}\)</span>.</p>
<h3 id="递推式">递推式</h3>
<p><span class="math inline">\(C(n,m)=C(n-1,m-1)+C(n-1,m)\)</span>.</p>
<hr />
<h3 id="组合数完全累和">组合数完全累和</h3>
<p><span class="math inline">\(\displaystyle \sum_{i=0}^n C(n,i)
=2^n\)</span>.</p>
<hr />
<h3 id="奇偶累和">奇偶累和</h3>
<p><span class="math inline">\(\displaystyle \sum_0^n (-1)^i
C(n,i)=[n=0]\)</span>.</p>
<span id="more"></span>
<hr />
<h3 id="sumcdotssum-rightarrow-c-型"><span
class="math inline">\(\sum\cdots\sum \rightarrow C()\)</span> 型</h3>
<p>我们熟知的有：</p>
<p><span class="math inline">\(\displaystyle \sum_{i=1}^{n}1=n =
C(n,1)\)</span></p>
<p><span class="math inline">\(\displaystyle\sum _{i=1}^{n}
\sum_{j=i+1}^{n} 1= \frac{n(n-1)}{2}\)</span></p>
<p>更一般的：</p>
<p><span class="math inline">\(\displaystyle\underbrace {\sum \sum ...
\sum} 1 =C(n,k)\)</span></p>
<p><span class="math inline">\((k个\sum) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
\ \ \ \ \)</span></p>
<hr />
<h3 id="cni-型">$ ...  C(n,i)$ 型</h3>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum i \cdot C(n,i)
\\
=&amp; \sum {i \cdot  \frac{n!}{i! \cdot (n-i)!}}
\\
=&amp; \sum {  \frac{n!}{(i-1)! \cdot (n-i)!}}
\\
=&amp;\sum {n \cdot \frac {(n-1)!} {(i-1)! \cdot (n-i)!}}
\\
=&amp;n\cdot \sum  C(n-1,i-1)
\end{aligned}
\]</span></p>
<p>同理的：</p>
<p><span class="math inline">\(\sum i\cdot (i-1)\cdot C(n,i)=n \cdot
(n-1) \cdot \sum C(n-2,i-2)\)</span></p>
<p>带入还能得到：</p>
<p><span class="math inline">\(\sum i^2 \cdot C(n,i) = n \cdot (n-1)
\cdot \sum C(n-2,i-2)+n \cdot \sum C(n-1,i-1)\)</span>。</p>
<p>更一般的，可以表示成 <span class="math inline">\(\sum C(i,k) \cdot
C(n,i) =C(n,k) \cdot \sum C(n-k,i-k)\)</span>。</p>
<hr />
<h3 id="多组合数相乘型">多组合数相乘型</h3>
<p><span class="math inline">\(\displaystyle \sum_{i=0}^{k} C(n,i)\cdot
C(m,k-i) = C(n+m,k)\)</span></p>
<p>其实就是两个组合问题的组合，可以直接通过实际意义得到</p>
<hr />
<h3 id="lucas定理">Lucas定理</h3>
<p>$ C(n,m) p = C(n p,m p) C( {p}, {p}) p$</p>
<p>预处理阶乘逆元后，可以用于解决模数较小而<span
class="math inline">\(n,m\)</span>较大的组合数问题</p>
<hr />
<h2 id="前缀和">前缀和</h2>
<h3 id="列">列</h3>
<p><span class="math inline">\(\displaystyle \sum_{i=0}^n
\binom{i}{m}=\binom{n+1}{m+1}\)</span></p>
<p>由递推式 <span class="math inline">\(\displaystyle
\binom{i}{m}=\binom{i-1}{m}+\binom{i-1}{m-1}\)</span> 容易迭代发现：</p>
<p><br></p>
<h3 id="行">行</h3>
<p>令 <span class="math inline">\(S(n,m)=\sum_{i=0}^{m}
C(n,i)\)</span></p>
<p><span class="math display">\[
\begin{aligned}
&amp;S(n,m)+S(n,m+1)
\\
=&amp;\sum_{i=0}^{m}(C(n,i)+C(n,i+1))+C(n,0)
\\
=&amp;\sum C(n+1,i+1)+C(n,0)
\\
=&amp;S(n+1,m+1)
\end{aligned}
\]</span></p>
<p>又 <span
class="math inline">\(S(n,m)+S(n,m+1)=2S(n,m+1)-C(n,m+1)\)</span>，故
<span class="math inline">\(S(n,m)=2S(n-1,m)-C(n-1,m)\)</span>。</p>
<p>(待补。。。)</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E8%8C%83%E5%BE%B7%E8%92%99%E5%BE%B7%E8%A1%8C%E5%88%97%E5%BC%8F/</url>
    <content><![CDATA[<hr />
<p>title: 'Vandermonde Determinant' date: 'Sat Aug 12 11:05:23 2023
categories: - oi-notes'</p>
<h1 id="vandermonde-determinant">Vandermonde Determinant</h1>
<p><span class="math display">\[
\begin{aligned}
&amp;\det\left(\begin{array}{cccc}
x_0^0 &amp; x_1^0 &amp; \cdots &amp; x_{n-1}^0\\
x_0^1 &amp; x_1^1 &amp; \cdots &amp; x_{n-1}^1\\
\vdots &amp; \vdots &amp; \vdots &amp;\vdots\\
x_0^{n-1} &amp; x_1^{n-1} &amp; \cdots &amp; x_{n-1}^{n-1}
\end{array}\right)
\\
\\
&amp; 第\ i\ 行减去第\ i-1\ 行乘\ x_0\ ，得到
\\
\\
=&amp;\det\left(\begin{array}{cccc}
1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\\
0 &amp; x_1^0(x_1-x_0) &amp; x_2^0(x_2-x_0) &amp; \cdots &amp;
x_{n-1}^0(x_{n-1}-x_0)\\
0 &amp; x_1^1(x_1-x_0) &amp; x_2^1(x_2-x_0) &amp; \cdots &amp;
x_{n-1}^1(x_{n-1}-x_0)\\
\vdots &amp; \vdots &amp; \vdots &amp;\vdots &amp; \vdots \\
0 &amp; x_1^{n-2}(x_1-x_0) &amp; x_2^{n-2}(x_1-x_0) &amp; \cdots &amp;
x_{n-1}^{n-2}(x_{n-1}-x_0)  
\end{array}\right)
\\
\\
&amp; 于是可以把第一行第一列去掉，然后剩下的每一列提取 x_i-x_0，得到
\\
\\
=&amp;\prod_{i&gt;1} (x_i-x_0) \left(\begin{array}{cccc}
x_1^0 &amp; x_2^0 &amp; \cdots &amp; x_{n-2}^0\\
x_1^1 &amp; x_2^1 &amp; \cdots &amp; x_{n-2}^1\\
\vdots &amp; \vdots &amp; \vdots &amp;\vdots\\
x_0^{n-2} &amp; x_1^{n-2} &amp; \cdots &amp; x_{n-2}^{n-2}
\end{array}\right)
\\
\\
&amp;   简单归纳知道答案就是
\\
=&amp;\prod_i\prod_j (x_i-x_j)
\end{aligned}
\]</span></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-notes/%E9%9B%86%E5%90%88%E5%B9%82%E7%BA%A7%E6%95%B0/</url>
    <content><![CDATA[<hr />
<p>title: '集合幂级数的 <span class="math inline">\(\ln,\exp\)</span>'
date: 'Sat Aug 12 11:05:23 2023 categories: - oi-notes'</p>
<h1 id="集合幂级数的-lnexp">集合幂级数的 <span
class="math inline">\(\ln,\exp\)</span></h1>
<p>起始：求联通子图个数。</p>
<p>令 <span class="math inline">\(F(x)\)</span>
为联通的生成子图个数的形式幂级数，可以简单求出 <span
class="math inline">\(G(x)\)</span> 为生成子图个数的形式幂级数。</p>
<span id="more"></span>
<p>下可能略写 <span class="math inline">\(F(x)\)</span> 为 <span
class="math inline">\(F\)</span>。</p>
<p>不连通的子图可以通过联通子图做集合并运算得到，即构造卷积：</p>
<p><span class="math display">\[
F\times G=\sum_{S\ne \empty}\sum_{T\ne \empty,S\cap T=\empty}
[x^S]F\cdot [x^T]G\cdot x^{S\cup T}
\]</span> 显然满足关系式 <span class="math inline">\(\displaystyle
G=\sum_{i\ge 1} \frac{F^i}{i!}=e^{F}-1\)</span>，<span
class="math inline">\(F=\ln (G+1)\)</span></p>
<p>计算集合幂级数 <span class="math inline">\(\ln\)</span>
的方法似乎非常抽象：</p>
<ol type="1">
<li><p>类似子集卷积，把所有项按照占位数（集合包含元素个数）分开，记录在第二维。</p></li>
<li><p>求出 <span class="math inline">\(\text{FMT}\)</span>。</p></li>
<li><p>对于集合幂级数每一位（现在是一个形式幂级数）求出其 <span
class="math inline">\(\ln\)</span> 的前 <span
class="math inline">\(n\)</span> 项。</p></li>
<li><p>求出 <span class="math inline">\(\text{IFMT}\)</span></p></li>
</ol>
<p>求出形式幂级数 <span class="math inline">\(\ln\)</span> 的 <span
class="math inline">\(n^2\)</span> 方法是。</p>
<p><span class="math inline">\(F=\ln (G+1)\)</span>，</p>
<p><span class="math inline">\(F&#39;=\frac{G&#39;}{G+1}\)</span>，</p>
<p><span class="math inline">\(F&#39;(G+1)=G&#39;\)</span>，</p>
<p><span
class="math inline">\(\begin{aligned}F&#39;_i=G&#39;_i-\sum_{j=1}G_jF&#39;_{i-j}\end{aligned}\)</span>。</p>
<p>类似的，可以计算集合幂级数的 <span
class="math inline">\(\exp\)</span>，即由上面的 <span
class="math inline">\(F\)</span> 求 <span
class="math inline">\(G\)</span>：<span
class="math inline">\(\displaystyle
G&#39;_i=F&#39;_i+\sum_{j=1}G_jF&#39;_{i-j}\)</span>。</p>
<p>可能在子图计数题中出现：</p>
<p><a href="https://loj.ac/problem/6729">LOJ6729</a></p>
<p><a href="https://loj.ac/problem/6719">LOJ6719</a></p>
<p><a href="https://loj.ac/problem/6730">LOJ6730</a></p>
<p>下面是代码实现上的参考：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> I[N];<span class="comment">// 模逆元</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMT</span><span class="params">(<span class="type">int</span> F[M][N],<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i&lt;&lt;=<span class="number">1</span>) <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;m;l+=i*<span class="number">2</span>) </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) <span class="keyword">if</span>(f==<span class="number">1</span>) <span class="built_in">rep</span>(d,<span class="number">1</span>,n) F[j+i][d]+=F[j][d],<span class="built_in">Mod1</span>(F[j+i][d]);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">rep</span>(d,<span class="number">1</span>,n) F[j+i][d]-=F[j][d],<span class="built_in">Mod2</span>(F[j+i][d]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ln</span><span class="params">(<span class="type">int</span> *a)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> b[N];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,i<span class="number">-1</span>) t=(t+<span class="number">1ll</span>*b[j]*a[i-j])%P;</span><br><span class="line">		b[i]=(<span class="number">1ll</span>*a[i+<span class="number">1</span>]*(i+<span class="number">1</span>)-t+P)%P;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) a[i]=<span class="number">1ll</span>*b[i<span class="number">-1</span>]*I[i]%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exp</span><span class="params">(<span class="type">int</span> *a)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> b[N];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) b[i]=<span class="number">1ll</span>*a[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> t=b[i];</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,i) t=(t+<span class="number">1ll</span>*a[j]*b[i-j])%P;</span><br><span class="line">		a[i+<span class="number">1</span>]=<span class="number">1ll</span>*t*I[i+<span class="number">1</span>]%P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ln</span><span class="params">(<span class="type">int</span> F[M][N])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">FMT</span>(F,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) <span class="built_in">Ln</span>(F[i]);</span><br><span class="line">	<span class="built_in">FMT</span>(F,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exp</span><span class="params">(<span class="type">int</span> F[M][N])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">FMT</span>(F,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) <span class="built_in">Exp</span>(F[i]);</span><br><span class="line">	<span class="built_in">FMT</span>(F,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/300iqcontest#2C%20Counting%20Cactus/</url>
    <content><![CDATA[<hr />
<p>title: '「300iq Contest 2」[LOJ 6719] 数仙人掌 Counting Cactus' date:
'Sat Aug 12 11:05:24 2023 categories: - oi-solutions'</p>
<h1 id="iq-contest-2loj-6719-数仙人掌-counting-cactus">「300iq Contest
2」[LOJ 6719] 数仙人掌 Counting Cactus</h1>
<p>LOJ上的 <span class="math inline">\(n\leq 18\)</span></p>
<p>如果把仙人掌上的树边看做二元环，那么可以认为仙人掌就是由很多环嵌套在一起的结构</p>
<h2 id="nleq-13"><span class="math inline">\(n\leq 13\)</span></h2>
<p>状压 <span class="math inline">\(dp\)</span>
，300iq的题解里给出了状态，但是也只告诉了你状态。。。</p>
<p>令 <span class="math inline">\(f(i,S)\)</span> 为 <span
class="math inline">\(i\)</span> 号节点为根，子树集合为 <span
class="math inline">\(S\)</span> 的方案数</p>
<p>令 <span class="math inline">\(g(i,S)\)</span> 为 <span
class="math inline">\(i\)</span> 号节点为根，子树集合为 <span
class="math inline">\(S\)</span> 的方案数，并且强制根上只接了一个环</p>
<p>令 <span class="math inline">\(dp(u,v,S)\)</span>
为钦定一个当前环的开头为 <span class="math inline">\(u\)</span>
，环尾扩展到了 <span class="math inline">\(v\)</span> ，当前包含 <span
class="math inline">\(S\)</span> 的方案数</p>
<p>由此得到转移为</p>
<ol type="1">
<li><p><span class="math inline">\(f(i,S)\cdot g(j,T)(S\cap
T=\empty)\rightarrow f(i,S\cup T)\)</span></p></li>
<li><p><span class="math inline">\(dp(u,v,S)\cdot f(d,T)(S\cap
T=\empty,(u,v)\in E) \rightarrow dp(u,d,S\cup T)\)</span></p></li>
<li><p><span class="math inline">\(dp(u,v,S) ((u,v)\in E)\rightarrow
g(u,S)\)</span></p></li>
</ol>
<p>实际上涉及到很多计算重复，因此需要在转移过程中加入一些调整:</p>
<p>1.在转移环时，<strong>钦定的环开头节点下方不应该接有任何其他节点</strong></p>
<p>2.转移1中 <span class="math inline">\(S,T\)</span>
合并上来时，可以保证 <span class="math inline">\(S&lt;T\)</span>
来避免集合加入顺序的重复</p>
<p>3.当环长&gt;2时，同一个环，同一个开始位置会由于环遍历顺序的不同被转移两次</p>
<p>对于这个问题我的解决方法是: 让 <span
class="math inline">\(\frac{dp(u,v,S)}{2}\rightarrow g(u,S)\)</span>
，然后把环长为2的部分加上去</p>
<p>转移过程中涉及到集合运算都是枚举子集，因此复杂度一个很松的上限为
<span class="math inline">\(O(n^33^n)\)</span></p>
<p>转移顺序不难解决，代码比较丑</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">13</span>,M=<span class="number">1</span>&lt;&lt;N|<span class="number">3</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> G[N];</span><br><span class="line"><span class="type">int</span> f[M][N],g[M][N];</span><br><span class="line"><span class="type">int</span> dp[M][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>()<span class="number">-1</span>,v=<span class="built_in">rd</span>()<span class="number">-1</span>;</span><br><span class="line">		G[u]|=<span class="number">1</span>&lt;&lt;v,G[v]|=<span class="number">1</span>&lt;&lt;u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> A=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) g[<span class="number">1</span>&lt;&lt;i][i]=<span class="number">1</span>,dp[<span class="number">1</span>&lt;&lt;i][i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(S,<span class="number">1</span>,A) &#123;</span><br><span class="line">		<span class="comment">// dp[S][u][v]转移</span></span><br><span class="line">		<span class="built_in">rep</span>(u,<span class="number">0</span>,n<span class="number">-1</span>) <span class="built_in">rep</span>(v,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(S&amp;(<span class="number">1</span>&lt;&lt;u) &amp;&amp; S&amp;(<span class="number">1</span>&lt;&lt;v)) &#123;</span><br><span class="line">			<span class="type">int</span> R=S^(<span class="number">1</span>&lt;&lt;u);</span><br><span class="line">			<span class="keyword">if</span>(u!=v) R^=(<span class="number">1</span>&lt;&lt;v);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> T=R&amp;(R<span class="number">-1</span>);;T=(T<span class="number">-1</span>)&amp;R)&#123;</span><br><span class="line">				<span class="type">int</span> X=T|(<span class="number">1</span>&lt;&lt;u)|(<span class="number">1</span>&lt;&lt;v),Y=S^X;</span><br><span class="line">				<span class="keyword">if</span>(dp[X][u][v]) <span class="built_in">rep</span>(d,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(f[Y][d] &amp;&amp; G[v]&amp;(<span class="number">1</span>&lt;&lt;d)) </span><br><span class="line">					dp[S][u][d]=(dp[S][u][d]+<span class="number">1ll</span>*dp[X][u][v]*f[Y][d])%P;</span><br><span class="line">				<span class="keyword">if</span>(!T) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// dp反馈给g</span></span><br><span class="line">		<span class="built_in">rep</span>(u,<span class="number">0</span>,n<span class="number">-1</span>) <span class="built_in">rep</span>(v,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(dp[S][u][v] &amp;&amp; G[u]&amp;(<span class="number">1</span>&lt;&lt;v)) </span><br><span class="line">			g[S][u]=(g[S][u]+<span class="number">1ll</span>*(P+<span class="number">1</span>)/<span class="number">2</span>*dp[S][u][v])%P;</span><br><span class="line">		<span class="comment">// 特判环长为2的情况</span></span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(i!=j &amp;&amp; S&amp;(<span class="number">1</span>&lt;&lt;i) &amp;&amp; S&amp;(<span class="number">1</span>&lt;&lt;j) &amp;&amp; G[i]&amp;(<span class="number">1</span>&lt;&lt;j)) </span><br><span class="line">			g[S][i]=(g[S][i]+<span class="number">1ll</span>*(P+<span class="number">1</span>)/<span class="number">2</span>*f[S^(<span class="number">1</span>&lt;&lt;i)][j])%P;</span><br><span class="line">		<span class="comment">// f[S][i]合并</span></span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) f[S][i]+=g[S][i],<span class="built_in">Mod1</span>(f[S][i]);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(S&amp;(<span class="number">1</span>&lt;&lt;i)) &#123;</span><br><span class="line">			<span class="type">int</span> R=S^(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> T=R&amp;(R<span class="number">-1</span>);T;T=(T<span class="number">-1</span>)&amp;R) &#123;</span><br><span class="line">				<span class="type">int</span> X=T,Y=T^R;</span><br><span class="line">				<span class="keyword">if</span>(X&gt;Y) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="comment">// 防止转移顺序重复</span></span><br><span class="line">				f[S][i]=(f[S][i]+<span class="number">1ll</span>*f[X|(<span class="number">1</span>&lt;&lt;i)][i]*g[Y|(<span class="number">1</span>&lt;&lt;i)][i])%P;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[A][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nleq-18"><span class="math inline">\(n\leq 18\)</span></h2>
<p>前置知识：<a
href="https://www.cnblogs.com/chasedeath/p/13891189.html">集合幂级数的
<span class="math inline">\(\ln ,\exp\)</span></a></p>
<p>同样上面的，一颗仙人掌可以看做若干 <span class="math inline">\(\ge
2\)</span> 环，两两之间在某一个节点上相接构成</p>
<p>不妨先求出环的集合幂级数，枚举环上编号最小的点，然后走环，复杂度为
<span class="math inline">\(O(n^32^n)\)</span> ，常数较小</p>
<p>接下来当然想到枚举环的交点 <span class="math inline">\(i\)</span>
，将当前所有包含 <span class="math inline">\(i\)</span> 的项取出，去掉
<span class="math inline">\(i\)</span> 后求出 <span
class="math inline">\(\exp\)</span> ，然后放回去，就能计算相交在 <span
class="math inline">\(i\)</span> 上的方案</p>
<p>两部分复杂度均为 <span class="math inline">\(O(n^32^n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="keyword">enum</span>&#123;N=<span class="number">20</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">18</span>|<span class="number">10</span>,P=<span class="number">998244353</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">U</span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">U</span>()&#123;&#125; <span class="built_in">U</span>(<span class="type">int</span> x):<span class="built_in">x</span>(x)&#123;&#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> += (<span class="type">const</span> U &amp;t)&#123; x+=t.x,x&gt;=P&amp;&amp;(x-=P); &#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> -= (<span class="type">const</span> U &amp;t)&#123; x-=t.x,x&lt;<span class="number">0</span>&amp;&amp;(x+=P); &#125;</span><br><span class="line">	<span class="keyword">inline</span> U <span class="keyword">operator</span> * (<span class="type">const</span> U &amp;t)&#123; <span class="keyword">return</span> <span class="built_in">U</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(x)*t.x%P); &#125;</span><br><span class="line">&#125;I[N],F[M][N],H[M][N];</span><br><span class="line"><span class="type">int</span> n,m,G[N],C[M],B[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;m;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">				<span class="keyword">if</span>(f==<span class="number">1</span>) <span class="built_in">rep</span>(d,<span class="number">1</span>,n) F[j+i][d]+=F[j][d];</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">rep</span>(d,<span class="number">1</span>,n) F[j+i][d]-=F[j][d];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exp</span><span class="params">(U *a)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> U b[N];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) b[i]=a[i+<span class="number">1</span>]*(i+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">		U t=b[i];</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,i) t+=a[j]*b[i-j];</span><br><span class="line">		a[i+<span class="number">1</span>]=t*I[i+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x,y;m--;) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),x--,y--,G[x]|=<span class="number">1</span>&lt;&lt;y,G[y]|=<span class="number">1</span>&lt;&lt;x;</span><br><span class="line">	I[<span class="number">0</span>]=I[<span class="number">1</span>]=<span class="number">1</span>,m=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) B[<span class="number">1</span>&lt;&lt;i]=i;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n) I[i]=<span class="built_in">U</span>(P-P/i)*I[P%i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) C[i]=C[i&amp;(i<span class="number">-1</span>)]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(st,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">		H[<span class="number">1</span>&lt;&lt;st][st]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(S,<span class="number">0</span>,m<span class="number">-1</span>) <span class="built_in">rep</span>(i,st,n<span class="number">-1</span>) <span class="keyword">if</span>(H[S][i].x) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> T=G[i]&amp;~S;T;T&amp;=T<span class="number">-1</span>) </span><br><span class="line">				H[S|(T&amp;-T)][B[T&amp;-T]]+=H[S][i];</span><br><span class="line">			<span class="keyword">if</span>(G[i]&amp;(<span class="number">1</span>&lt;&lt;st)) F[S][C[S]]+=H[S][i]*I[<span class="number">1</span>+(C[S]&gt;<span class="number">2</span>)];</span><br><span class="line">			H[S][i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FWT</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;m;l+=i*<span class="number">2</span>) <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">			<span class="built_in">rep</span>(k,<span class="number">1</span>,n) F[j+i][k]-=F[j][k];</span><br><span class="line">			<span class="built_in">Exp</span>(F[j+i]+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">rep</span>(k,<span class="number">1</span>,n) F[j+i][k]+=F[j][k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FWT</span>(<span class="number">-1</span>),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,F[m<span class="number">-1</span>][n].x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/BalticOI2021%20Day1%20T3/</url>
    <content><![CDATA[<hr />
<p>title: '' date: 'Sat Aug 12 11:05:24 2023 categories: -
oi-solutions'</p>
<p>令 <span class="math inline">\(dis_{u,s}\)</span> 表示 在 <span
class="math inline">\(\mod L=s\)</span> 到达 <span
class="math inline">\(u\)</span> 的最小时间，其中 <span
class="math inline">\(L\)</span> 表示 <span
class="math inline">\(u\)</span> 所在环。</p>
<p>对于状态 <span class="math inline">\(dis_{u,s}\)</span>
，考虑所有的边 <span class="math inline">\((u,v)\)</span> 。</p>
<p>当 <span class="math inline">\(u,v\)</span>
有一个不在环上时，转移可以分为：</p>
<ol type="1">
<li>如果能过去就直接过去。</li>
<li>等到 <span class="math inline">\(v\)</span>
被占据之后再跟过去（跟在守卫后面）。</li>
</ol>
<p>当 <span class="math inline">\((u,v)\)</span>
为一条环边时，则只需要考虑能否直接走环边。</p>
<p>当 <span class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span>
都在环上时，可以将转移压缩为以下几种：</p>
<ol type="1">
<li><p>令 <span class="math inline">\(t\)</span> 表示 <span
class="math inline">\(v\)</span> 下一个被占据的时刻，如果 <span
class="math inline">\(t\)</span> 时刻 <span
class="math inline">\(u\)</span> 没有被占据，则可以采取以下方式：</p>
<ol type="1">
<li>通过这条边到达 <span class="math inline">\(v\)</span> 。</li>
<li>在 <span class="math inline">\(t\)</span> 时刻回到 <span
class="math inline">\(u\)</span> 。</li>
<li>然后在 <span class="math inline">\(t+1\)</span> 时刻去 <span
class="math inline">\(v\)</span> 。</li>
</ol>
<p>最后就可以跟在 <span class="math inline">\(v\)</span>
环的守卫后面。</p></li>
<li><p>如果 <span class="math inline">\(t\)</span> 时刻 <span
class="math inline">\(v\)</span> 被占据了：</p>
<p>令 <span class="math inline">\(t&#39;\)</span> 表示 <span
class="math inline">\(t\)</span> 时刻以后，下一个回到 <span
class="math inline">\(\mod L=s\)</span> 的时刻，用 <span
class="math inline">\(t&#39;+1\)</span> 更新。</p>
<p>令 <span class="math inline">\(t&#39;&#39;\)</span> 表示 <span
class="math inline">\(t&#39;\)</span> 时刻以后，下一个 <span
class="math inline">\(v\)</span> 被占据的时刻，再次检查能否用 <span
class="math inline">\(1\)</span> 中的方案。
此时由于要多留一轮，需要判断</p></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/EZEC10%20-%20D/</url>
    <content><![CDATA[<hr />
<p>title: '' date: 'Sat Aug 12 11:05:26 2023 categories: -
oi-solutions'</p>
<p>设 <span class="math inline">\(\displaystyle C(x)=\sum_{i=0}^{\infty}
C_i\)</span></p>
<p>易知 <span class="math inline">\(xC^2=C-1\)</span></p>
<p>设 <span
class="math inline">\(F_{n,m}=[x^m](C-1)^n,F_n(x)=(C-1)^n\)</span></p>
<p>知 <span class="math inline">\(F_n(x)=(C-1)^n=xC^2 (C-1)^{n-1}=x
((C-1)^{n+1}+2(C-1)^n+(C-1)^{n-1})\)</span></p>
<p>即 <span
class="math inline">\(F_{n,m}=F_{n+1,m-1}+2F_{n,m-1}+F_{n-1m-1}\)</span></p>
<p>即 <span
class="math inline">\(F_{n,m}=F_{n-1,m+1}-2F_{n-1,m}-F_{n-2,m}\)</span></p>
<p>进一步规约，得到答案的表达式</p>
<p><span class="math inline">\(\displaystyle Ans_i=[x^n] (C(x)-1)^i
[y^i] e^{\varphi}\)</span></p>
<p>其中 <span class="math inline">\(\displaystyle \varphi=\sum _{i\ge
1}2(i+1) \cdot (C(x)-1) y^i\)</span></p>
<p><span class="math inline">\(\displaystyle \varphi=\sum _{i\ge
1}2(i+1) \cdot (C(x)-1) y^i\)</span></p>
<p><span class="math inline">\(\displaystyle \int \varphi\ dy
=\sum_{i\ge 1} 2(C(x)-1) y^{i+1}=\sum_{i\ge 2} 2(C(x)-1)
y^i\)</span></p>
<p><span class="math inline">\(\displaystyle \int \varphi\ dy =
2(C(x)-1) \frac{y^2}{1-y}\)</span></p>
<p><span class="math inline">\(\displaystyle \varphi=2(C(x)-1)
(\frac{y^2}{1-y})&#39;=2(C(x)-1) \frac{2y-y^2}{(1-y)^2}\)</span></p>
<p><span class="math inline">\(G_{n,m}\)</span> 为 <span
class="math inline">\(n\)</span> 个白格， <span
class="math inline">\(m\)</span> 为总格数的权值</p>
<p><span class="math inline">\(\displaystyle G_{n}(x)=(\sum_{i\ge 2} 2i
x^i)^n\)</span></p>
<p>设 <span class="math inline">\(\displaystyle \varphi(x)=\sum_{i\ge 2}
2i x^i\)</span></p>
<p><span class="math inline">\(\displaystyle \varphi(x)=2x(\sum_{i\ge 2}
x^i)&#39;=2x^2 \frac{2-x}{1-x}\)</span></p>
<p><span class="math inline">\(G_n(x)=\varphi^n(x)\)</span></p>
<p><span class="math inline">\(Ans_i\)</span> 表示有 <span
class="math inline">\(i\)</span> 个白格的答案</p>
<p><span class="math inline">\(Ans_i=\displaystyle \sum_j G_{i,j}
F_{j,n}\)</span></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/Sprinklers%202%20Return%20of%20the%20Alfalfa%20P/</url>
    <content><![CDATA[<hr />
<p>title: 'Sprinklers 2: Return of the Alfalfa P' date: 'Sat Aug 12
11:05:28 2023 categories: - oi-solutions'</p>
<h1 id="sprinklers-2-return-of-the-alfalfa-p">Sprinklers 2: Return of
the Alfalfa P</h1>
<p>条件是:
每个点都要被覆盖，且不能被两种覆盖，那么最后覆盖的情况一定是形如下图的</p>
<p><img
src="http://10.220.121.203/judge/tutorial/php/../uploads/20200927043851_95341.png" /></p>
<p>其中红色和黄色的点表示<strong>关键的</strong>覆盖点，其他点按照其所属的颜色可以选择放或者不放</p>
<p>那么考虑从上到下，依次对于每一层 <span
class="math inline">\(dp\)</span> 竖线的位置，那么有两种转移方法</p>
<p>1.保留上层竖线，两边空白位置的可行点用2的幂次乘进答案即可</p>
<p>2.将当前层的竖线右移，必须选择两个位置，其他位置依然按照2的幂次加入答案</p>
<p>直接转移是 <span class="math inline">\(O(n^3)\)</span>
的，对于第2中转移应用前缀和优化即可做到 <span
class="math inline">\(O(n^2)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ldb;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">    T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> A[N][N];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="type">int</span> c[N][N],rc[N][N]; </span><br><span class="line"><span class="type">int</span> Pow[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,A[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) c[i][j]=c[i][j<span class="number">-1</span>]+(A[i][j]==<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">drep</span>(j,n,<span class="number">1</span>) rc[i][j]=rc[i][j+<span class="number">1</span>]+(A[i][j]==<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,Pow[<span class="number">0</span>]=<span class="number">1</span>,n) Pow[i]=Pow[i<span class="number">-1</span>]*<span class="number">2</span>%P;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,n) &#123;</span><br><span class="line">            dp[i][j]=(dp[i][j]+<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j]*Pow[c[i][j]+rc[i<span class="number">-1</span>][j+<span class="number">1</span>]])%P;</span><br><span class="line">            <span class="comment">// 空白位置的可行点按照2的幂次加入答案</span></span><br><span class="line">            <span class="keyword">if</span>(A[i][j]!=<span class="string">&#x27;W&#x27;</span>) dp[i][j]=(dp[i][j]+<span class="number">1ll</span>*s*(j?Pow[c[i][j]<span class="number">-1</span>]:<span class="number">1</span>))%P;</span><br><span class="line">            <span class="comment">//把两个强制选择的关键点分开，在累入前缀和 和 从前缀和中拿出时考虑即可</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(A[i<span class="number">-1</span>][j+<span class="number">1</span>]!=<span class="string">&#x27;W&#x27;</span>) s=(s+<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j]*(i&gt;<span class="number">1</span>&amp;&amp;j&lt;n?Pow[rc[i<span class="number">-1</span>][j+<span class="number">1</span>]<span class="number">-1</span>]:<span class="number">1</span>))%P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n) <span class="keyword">if</span>(A[n][i+<span class="number">1</span>]!=<span class="string">&#x27;W&#x27;</span>) ans=(ans+<span class="number">1ll</span>*(i&lt;n?Pow[rc[n][i+<span class="number">1</span>]<span class="number">-1</span>]:<span class="number">1</span>)*dp[n][i])%P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/UR#23%20%E5%9B%BD%E7%8E%8B/</url>
    <content><![CDATA[<hr />
<p>title: 'UR#23 国王' date: 'Sat Aug 12 11:05:28 2023 categories: -
oi-solutions'</p>
<h1 id="ur23-国王">UR#23 国王</h1>
<p><span class="math inline">\(\sum_{i=0}^w \binom{w}{i}(t-A\cdot
i)^n\)</span></p>
<p><span class="math inline">\(\sum_{i=0}^T (X+A\cdot i)^n
()\)</span></p>
<p><span class="math inline">\(x^n=\sum_{i=0}^n i! S(n,i)
\binom{x}{i}\)</span></p>
<p>$$ F_W(x)=e<sup>{Ex}<em>{i=0}^W
(e<sup>{Ax}+e</sup>{Bx}-2)<sup>i2</sup>{W-i}) \
F_W(x)=e<sup>{Ex}2</sup>W</em>{i=0}</sup>W (-1)^i \
F_W(x)=e<sup>{Ex}<em>{i=0}^n (-1)^i ^W \ [x^n]F_W(x)=</em>{i=0}</sup>n
[x^n]e<sup>{Ex}(-1)</sup>i ^W \ [x^n]F_W(x) [x^m]G_{T-W}(x) = \
<em>{i=0}^n [x^n]e<sup>{Ex}(-1)</sup>i </em>{j=0}^m
[x^m]e<sup>{Fx}(-1)</sup>j \ <sup>W</sup>{T-W} \ <em>{W=0}^T [x^n]F_W(x)
[x^m]G</em>{T-W}(x)= \ 2^T n! m!<em>{i=0}^n [x^n]e<sup>{Ex}(-1)</sup>i
</em>{j=0}^m [x^n]e<sup>{Fx}(-1)</sup>j \ \ =2^T n! m!<em>{i=0}^n
[x^n]e<sup>{Ex}(e</sup>{Ax}+e<sup>{Bx}-2)</sup>i </em>{j=0}^m
[x^m]e<sup>{Fx}(e</sup>{Cx}+e<sup>{Dx}-2)</sup>j \ 设 f_i=<a
href="e%5E%7BAx%7D+e%5E%7BBx%7D-2">x^n</a>^i=_{j,k} (-2)^{i-j}[x^n]
(e<sup>{Ax}+e</sup>{Bx})^j \ 设g_i=<a
href="e%5E%7BAx%7D+e%5E%7BBx%7D">x^n</a>^i \</p>
<p>\ $$</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/Szprotki%20i%20szczupaki/</url>
    <content><![CDATA[<hr />
<p>title: '「PA 2019」Szprotki i szczupaki' date: 'Sat Aug 12 11:05:28
2023 categories: - oi-solutions'</p>
<h1 id="pa-2019szprotki-i-szczupaki">「PA 2019」Szprotki i
szczupaki</h1>
<p>根据题意模拟，得到一种浅显的贪心方法是:
每次选择能吃的最大的一个吃掉</p>
<p>如果用set维护，就能得到一个 <span class="math inline">\(O(n^2\log
n)\)</span> 的算法!</p>
<p>考虑用加速这个贪心:</p>
<p>设当前重量为 <span class="math inline">\(now\)</span> ，目标是 <span
class="math inline">\(des\)</span></p>
<p>每次找到存在 <span class="math inline">\(\ge now\)</span>
的最小的一条鱼 <span class="math inline">\(nxt\)</span></p>
<p>那么这一次决策的目标就是吃最少的鱼让自己能够吃掉 <span
class="math inline">\(nxt\)</span> 或者直接达到 <span
class="math inline">\(des\)</span></p>
<p>在达到这一次的决策目标之前，能够吃的鱼的集合都是一样的</p>
<p>那么就可以找到最短的一段以 <span class="math inline">\(now-1\)</span>
为右端点的区间使得区间的和达到目标</p>
<p>发现每做一次决策之后，下一次吃一条鱼就会翻倍，所以只有 <span
class="math inline">\(\log 10^{18}\)</span> 次决策</p>
<p>那么考虑如何用数据结构维护这个目标</p>
<p>注意一个比较难维护的问题，每次决策之后，被吃掉的鱼应当<strong>暂时消失</strong></p>
<p>暂时消失的问题，常见的思路可能是:可持久化 或者 删除之后存下来回撤</p>
<h3 id="平衡树">平衡树</h3>
<p>涉及到插入，删除，二分区间，删除区间和复原区间</p>
<p>可以用 <span class="math inline">\(\text{Splay}\)</span> 或者非旋
<span class="math inline">\(\text{Treap}\)</span> 维护这个问题</p>
<p>复原区间的过程可以写成一个伪平衡树合并的样子</p>
<p><del>非常慢</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">    T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll U=<span class="number">1e12</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> rt,c[N],ls[N],rs[N],key[N],ma[N],mi[N];</span><br><span class="line">ll s[N],val[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123; <span class="keyword">return</span> val[x]!=val[y]?val[x]&lt;val[y]:x&gt;y; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    s[p]=s[ls[p]]+s[rs[p]]+val[p];</span><br><span class="line">    c[p]=c[ls[p]]+c[rs[p]]+<span class="number">1</span>;</span><br><span class="line">    ma[p]=mi[p]=p;</span><br><span class="line">    <span class="keyword">if</span>(ma[ls[p]] &amp;&amp; <span class="built_in">cmp</span>(ma[p],ma[ls[p]])) ma[p]=ma[ls[p]];</span><br><span class="line">    <span class="keyword">if</span>(ma[rs[p]] &amp;&amp; <span class="built_in">cmp</span>(ma[p],ma[rs[p]])) ma[p]=ma[rs[p]];</span><br><span class="line">    <span class="keyword">if</span>(mi[ls[p]] &amp;&amp; <span class="built_in">cmp</span>(mi[ls[p]],mi[p])) mi[p]=mi[ls[p]];</span><br><span class="line">    <span class="keyword">if</span>(mi[ls[p]] &amp;&amp; <span class="built_in">cmp</span>(mi[ls[p]],mi[p])) mi[p]=mi[rs[p]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls[x]) <span class="built_in">Show</span>(ls[x]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d,%lld,%lld) &quot;</span>,x,val[x],s[x]);</span><br><span class="line">    <span class="keyword">if</span>(rs[x]) <span class="built_in">Show</span>(rs[x]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span>(key[x]&lt;key[y]) <span class="keyword">return</span> rs[x]=<span class="built_in">Union</span>(rs[x],y),<span class="built_in">Up</span>(x),x;</span><br><span class="line">    <span class="keyword">return</span> ls[y]=<span class="built_in">Union</span>(x,ls[y]),<span class="built_in">Up</span>(y),y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Pii <span class="title">Split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[x]&lt;=k) <span class="keyword">return</span> <span class="built_in">mp</span>(x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!x || !k) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">0</span>,x);</span><br><span class="line">    <span class="keyword">if</span>(c[ls[x]]+<span class="number">1</span>&lt;=k) &#123;</span><br><span class="line">        Pii y=<span class="built_in">Split</span>(rs[x],k-c[ls[x]]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> rs[x]=y.first,<span class="built_in">Up</span>(x),<span class="built_in">mp</span>(x,y.second);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Pii y=<span class="built_in">Split</span>(ls[x],k);</span><br><span class="line">        <span class="keyword">return</span> ls[x]=y.second,<span class="built_in">Up</span>(x),<span class="built_in">mp</span>(y.first,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Pii <span class="title">Split2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(ma[x],k)) <span class="keyword">return</span> <span class="built_in">mp</span>(x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(k,mi[x])) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">0</span>,x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(x,k)) &#123;</span><br><span class="line">        Pii y=<span class="built_in">Split2</span>(rs[x],k);</span><br><span class="line">        <span class="keyword">return</span> rs[x]=y.first,<span class="built_in">Up</span>(x),<span class="built_in">mp</span>(x,y.second);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Pii y=<span class="built_in">Split2</span>(ls[x],k);</span><br><span class="line">        <span class="keyword">return</span> ls[x]=y.second,<span class="built_in">Up</span>(x),<span class="built_in">mp</span>(y.first,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Pii <span class="title">Split3</span><span class="params">(<span class="type">int</span> x,ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(s[x]&lt;=k) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">0</span>,x);</span><br><span class="line">    <span class="keyword">if</span>(s[rs[x]]&gt;=k) &#123;</span><br><span class="line">        Pii y=<span class="built_in">Split3</span>(rs[x],k);</span><br><span class="line">        <span class="keyword">return</span> rs[x]=y.first,<span class="built_in">Up</span>(x),<span class="built_in">mp</span>(x,y.second);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Pii y=<span class="built_in">Split3</span>(ls[x],k-s[rs[x]]-val[x]);</span><br><span class="line">        <span class="keyword">return</span> ls[x]=y.second,<span class="built_in">Up</span>(x),<span class="built_in">mp</span>(y.first,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    val[++n]=<span class="built_in">rd</span>&lt;ll&gt;(),s[n]=val[n],ma[n]=mi[n]=n,c[n]=<span class="number">1</span>,key[n]=<span class="built_in">rand</span>();</span><br><span class="line">    Pii t=<span class="built_in">Split2</span>(rt,n); </span><br><span class="line">    rt=<span class="built_in">Union</span>(<span class="built_in">Union</span>(t.first,n),t.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pii x=<span class="built_in">Split2</span>(rt,<span class="number">0</span>);</span><br><span class="line">    Pii y=<span class="built_in">Split</span>(x.second,<span class="number">1</span>);</span><br><span class="line">    rt=<span class="built_in">Union</span>(x.first,y.second);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> T[N],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="built_in">rd</span>()) <span class="built_in">Insert</span>();</span><br><span class="line">    <span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> opt=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">2</span>) <span class="built_in">Insert</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">3</span>) val[<span class="number">0</span>]=<span class="built_in">rd</span>&lt;ll&gt;()<span class="number">-1</span>,<span class="built_in">Erase</span>();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ll now=<span class="built_in">rd</span>&lt;ll&gt;(),des=<span class="built_in">rd</span>&lt;ll&gt;(),ans=cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(now&lt;des) &#123;</span><br><span class="line">                val[n+<span class="number">1</span>]=now;</span><br><span class="line">                Pii x=<span class="built_in">Split2</span>(rt,n+<span class="number">1</span>);</span><br><span class="line">                ll nxt=x.second?val[mi[x.second]]+<span class="number">1</span>:<span class="number">1e18</span>;</span><br><span class="line">                <span class="built_in">cmin</span>(nxt,des);</span><br><span class="line">                ll d=nxt-now;</span><br><span class="line">                Pii y=<span class="built_in">Split3</span>(x.first,d);</span><br><span class="line">                now+=s[y.second],ans+=c[y.second];</span><br><span class="line">                rt=<span class="built_in">Union</span>(y.first,x.second);</span><br><span class="line">                T[++cnt]=y.second;</span><br><span class="line">                <span class="keyword">if</span>(now&lt;nxt) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">drep</span>(i,cnt,<span class="number">1</span>) &#123;</span><br><span class="line">                Pii x=<span class="built_in">Split2</span>(rt,T[i]); </span><br><span class="line">                rt=<span class="built_in">Union</span>(<span class="built_in">Union</span>(x.first,T[i]),x.second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now&gt;=des) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段树">线段树</h2>
<p>离线之后写，让每个位置只包含一个数会更好写</p>
<p>关于用线段树维护暂时删除的问题，有很多写法</p>
<p>1.强行标记，把被标记的节点全部存下来然后复原</p>
<ol start="2" type="1">
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%5BBZOJ2688%5DGreen%20Hackenbush/</url>
    <content><![CDATA[<hr />
<p>title: '[BZOJ2688]Green Hackenbush' date: 'Sat Aug 12 11:05:28 2023
categories: - oi-solutions'</p>
<h1 id="bzoj2688green-hackenbush">[BZOJ2688]Green Hackenbush</h1>
<p>题意: 有 <span class="math inline">\(n\)</span>
棵随机的二叉树，每棵只知道大小为 <span
class="math inline">\(a_i\)</span></p>
<p>博弈:每次选取一个子树删掉，只剩根不能操作，求先手获胜概率</p>
<p>考虑这个博弈，求出一棵树的 <span
class="math inline">\(\text{SG}\)</span> 值</p>
<p>显然有:</p>
<p>1.只有一个点的树的 <span class="math inline">\(\text{SG}\)</span>
值为0</p>
<p>2.多个树组合的问题为 <span class="math inline">\(\text{SG}\)</span>
值异或</p>
<p>暴力 <span class="math inline">\(dp\)</span> ，对于树 <span
class="math inline">\(T\)</span> 求答案，设 <span
class="math inline">\(T\)</span> 所有可行的后继状态集合为 <span
class="math inline">\(N(T)\)</span> ，则得到 <span
class="math inline">\(\text{SG}\)</span> 值的表达式为</p>
<p><span class="math inline">\(\text{SG}(T)=\text{mex}_{R\in
N(T)}\lbrace\text{SG(R)}\rbrace\)</span></p>
<p>直接求解复杂度过高，考虑归纳性质</p>
<p>性质:</p>
<p>1.一棵根节点只有一个儿子的树，其 <span
class="math inline">\(\text{SG}\)</span> 值为儿子的 <span
class="math inline">\(\text{SG}\)</span> 值+1</p>
<p>考虑归纳证明:</p>
<p>设子树为 <span class="math inline">\(T\)</span> ，令 <span
class="math inline">\(T+u\)</span> 表示 <span
class="math inline">\(T\)</span> 子树上面接上自己作为根，问题变为求证
<span class="math inline">\(\text{SG}(T+u)=\text{SG}(T)+1\)</span></p>
<p>设已经归纳证明所有 <span class="math inline">\(T\)</span>
的子联通块成立</p>
<p>我们要求 <span class="math inline">\(\text{SG}(T+u)\)</span></p>
<p><span
class="math inline">\(\text{SG}(T+u)=\text{mex}\{\text{SG}(u),\forall
_{R\in N(T)}\text{SG}(R+u)\}\)</span></p>
<p>由归纳的性质有</p>
<p><span class="math inline">\(\forall _{R\subsetneq
T}\text{SG}(R+T)=\text{SG}(R)+1\)</span></p>
<p>又因为 <span class="math inline">\(\text{SG}(u)=0\)</span>
，看做把所有儿子的情况平移了1，0的位置由自己占据，因而上式成立</p>
<p>2.多叉树的问题可以归纳为 <strong>根分别接上每个儿子得到的树</strong>
的问题的组合</p>
<p>因为儿子之间实际互不干扰，比较容易理解</p>
<p>由此得到，一棵树的 <span class="math inline">\(\text{SG}\)</span>
值为其所有儿子的 <span class="math inline">\(\text{SG}\)</span>
值+1的异或和</p>
<p>令 <span class="math inline">\(dp_{n,i}\)</span> 为一棵 <span
class="math inline">\(n\)</span> 个节点的二叉树 <span
class="math inline">\(\text{SG}\)</span> 值为 <span
class="math inline">\(i\)</span> 的概率，为了便于转移，设空树的 <span
class="math inline">\(\text{SG}\)</span> 值为-1</p>
<p>考虑直接枚举两棵子树的大小和 <span
class="math inline">\(\text{SG}\)</span> 值</p>
<p>考虑对于 <span class="math inline">\(n\)</span>
个节点的二叉树，设其左儿子为 <span class="math inline">\(i\)</span>
时的总概率为 <span class="math inline">\(F_i\)</span></p>
<p>得到的 <span class="math inline">\(\text{dp}\)</span> 转移是</p>
<p><span class="math inline">\(dp_{n,(a+1)\oplus (b+1)}\leftarrow
{dp_{i,a}\cdot dp_{n-i-1,b}\cdot F_i}\)</span></p>
<p>我们知道 <span class="math inline">\(n\)</span>
个节点的二叉树方案数为 <span
class="math inline">\(Catalan(n)=\frac{(2n)!}{n!(n+1)!}\)</span></p>
<p>由此得到 <span class="math inline">\(\begin{aligned}
F_i=\frac{Catalan(i)Catalan(n-i-1)}{Catalan(n)}\end{aligned}\)</span></p>
<p>此题范围可以直接带入 <span class="math inline">\(Catalan(i)\)</span>
求解，但是依然要提一下递推的做法（似乎精度更有保障?）</p>
<p><span class="math inline">\(\begin{aligned}
F_i=\frac{\frac{(2i)!}{i!(i+1)!}\cdot
\frac{(2n-i-2)!}{(n-i-1)!(n-i)!}}{\frac{(2n)}{n!(n+1)!}}\end{aligned}\)</span></p>
<p>递推求解 <span class="math inline">\(F_i\)</span> ，每次 <span
class="math inline">\(i\)</span> 改变一阶乘只会改变1或者2，因此由 <span
class="math inline">\(F_{i-1}\)</span> 得到 <span
class="math inline">\(F_i\)</span> 的递推式为</p>
<p><span class="math inline">\(F_i=\left\{
\begin{aligned}\frac{n(n+1)}{2n(2n-1)}&amp;&amp; i=0\\ F_{i-1}\cdot
\frac{2i(2i-1)}{(i+1)i}\frac{(n-i+1)(n-i)}{2(n-i)(2n-2i-1)} &amp;&amp;
i\in[1,n-1]\end{aligned}\right.\)</span></p>
<p>化简之后应该是</p>
<p><span class="math inline">\(F_i=\left\{
\begin{aligned}\frac{(n+1)}{2(2n-1)}&amp;&amp; i=0\\ F_{i-1}\cdot
\frac{(2i-1)}{(i+1)}\frac{(n-i+1)}{(2n-2i-1)} &amp;&amp;
i\in[1,n-1]\end{aligned}\right.\)</span></p>
<p>至此得到一个朴素的 <span class="math inline">\(O(n^4)\)</span>
预处理，由于是异或，可以用 <span
class="math inline">\(\text{FWT}_{\oplus}\)</span> 求解，复杂度为 <span
class="math inline">\(O(n^3)\)</span></p>
<p>对于输入的每棵树，类似背包地叠加概率即可，复杂度为 <span
class="math inline">\(O(n^3)\)</span></p>
<p>以下是朴素dp代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">db dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(db *a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;j++)&#123;</span><br><span class="line">				db t=a[j+i];</span><br><span class="line">				a[j+i]=a[j]-t;</span><br><span class="line">				a[j]+=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>) <span class="built_in">rep</span>(i,<span class="number">0</span>,N<span class="number">-1</span>) a[i]/=N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db F[N],G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>,dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,<span class="number">100</span>) &#123;</span><br><span class="line">		F[<span class="number">0</span>]=<span class="number">1.0</span>/(<span class="number">2</span>*i)/(<span class="number">2</span>*i<span class="number">-1</span>)*(i+<span class="number">1</span>)*i;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) &#123;</span><br><span class="line">			F[j]=F[j<span class="number">-1</span>] *  (<span class="number">2</span>*j)*(<span class="number">2</span>*j<span class="number">-1</span>)/(j+<span class="number">1</span>)/j   * <span class="number">1.0</span>/(<span class="number">2</span>*(i-j))/(<span class="number">2</span>*(i-j)<span class="number">-1</span>)*(i-j+<span class="number">1</span>)*(i-j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(a,<span class="number">0</span>,i<span class="number">-1</span>) <span class="built_in">rep</span>(h1,<span class="number">0</span>,N<span class="number">-1</span>) <span class="keyword">if</span>(dp[a][h1]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">rep</span>(h2,<span class="number">0</span>,N<span class="number">-1</span>) <span class="keyword">if</span>(dp[i-a<span class="number">-1</span>][h2]) &#123;</span><br><span class="line">				<span class="type">int</span> nxt=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(a&gt;<span class="number">0</span>) nxt^=h1+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(i<span class="number">-1</span>-a&gt;<span class="number">0</span>) nxt^=h2+<span class="number">1</span>;</span><br><span class="line">				dp[i][nxt]+=dp[a][h1]*dp[i-a<span class="number">-1</span>][h2]*F[a];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,N<span class="number">-1</span>) F[i]=<span class="number">0</span>;</span><br><span class="line">	F[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,N<span class="number">-1</span>) G[j]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,N<span class="number">-1</span>) <span class="keyword">if</span>(F[j]) <span class="built_in">rep</span>(k,<span class="number">0</span>,N<span class="number">-1</span>) G[j^k]+=F[j]*dp[x][k];</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,N<span class="number">-1</span>) F[j]=G[j];</span><br><span class="line">	&#125;</span><br><span class="line">	db ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) ans+=F[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以下是FWT优化代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">db dp[N][N],T[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(db *a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;N;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;j++)&#123;</span><br><span class="line">				db t=a[j+i];</span><br><span class="line">				a[j+i]=a[j]-t;</span><br><span class="line">				a[j]+=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>) <span class="built_in">rep</span>(i,<span class="number">0</span>,N<span class="number">-1</span>) a[i]/=N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db F[N],G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>,dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	T[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>,T[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">FWT</span>(T[<span class="number">0</span>],<span class="number">1</span>),<span class="built_in">FWT</span>(T[<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,<span class="number">100</span>) &#123;</span><br><span class="line">		F[<span class="number">0</span>]=<span class="number">1.0</span>/(<span class="number">2</span>*i)/(<span class="number">2</span>*i<span class="number">-1</span>)*(i+<span class="number">1</span>)*i;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) &#123;</span><br><span class="line">			F[j]=F[j<span class="number">-1</span>] *  (<span class="number">2</span>*j)*(<span class="number">2</span>*j<span class="number">-1</span>)/(j+<span class="number">1</span>)/j   * <span class="number">1.0</span>/(<span class="number">2</span>*(i-j))/(<span class="number">2</span>*(i-j)<span class="number">-1</span>)*(i-j+<span class="number">1</span>)*(i-j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,i<span class="number">-1</span>) <span class="built_in">rep</span>(k,<span class="number">0</span>,N<span class="number">-1</span>) dp[i][k]+=T[j][k]*T[i-j<span class="number">-1</span>][k]*F[j];</span><br><span class="line">		<span class="built_in">FWT</span>(dp[i],<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,N<span class="number">-2</span>) T[i][j+<span class="number">1</span>]=dp[i][j];</span><br><span class="line">		<span class="built_in">FWT</span>(T[i],<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	n=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,N<span class="number">-1</span>) F[i]=<span class="number">0</span>;</span><br><span class="line">	F[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,N<span class="number">-1</span>) G[j]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,N<span class="number">-1</span>) <span class="keyword">if</span>(F[j]) <span class="built_in">rep</span>(k,<span class="number">0</span>,N<span class="number">-1</span>) G[j^k]+=F[j]*dp[x][k];</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,N<span class="number">-1</span>) F[j]=G[j];</span><br><span class="line">	&#125;</span><br><span class="line">	db ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) ans+=F[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%5BBJ%20United%20Round%20#3%5D%20%E6%8A%BC%E9%9F%B5/</url>
    <content><![CDATA[<hr />
<p>title: '[BJ United Round #3] 押韵' date: 'Sat Aug 12 11:05:28 2023
categories: - oi-solutions'</p>
<h1 id="bj-united-round-3-押韵">[BJ United Round #3] 押韵</h1>
<p>先%%%%%%%%%%%%%%%%% EI</p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p>下文默认模数为 <span class="math inline">\(P\)</span></p>
<p>简要题意：求：用 <span class="math inline">\(k\)</span>
种元素，每种元素使用 <span class="math inline">\(d\)</span>
的倍数次，排成一个长度为 <span class="math inline">\(nd\)</span> 的序列
的方案数</p>
<p>这个题目的设定就让人想到两个离不开的元素 ：
<del>(模数暗示了？)</del></p>
<p>指数型生成函数 + 单位根反演</p>
<p>显然可以得到每一种元素的指数型生成函数为</p>
<p><span class="math inline">\(\begin{aligned}
\text{EGF(Element)}=F(x)=\sum_{d|i}
\frac{x^i}{i!}\end{aligned}\)</span></p>
<p>带入单位根反演 <span class="math inline">\(\begin{aligned}\
[d|n]=\frac{\sum_0^{d-1} \omega_d^{in}}{d}\end{aligned}\)</span></p>
<p>即 <span class="math inline">\(F(x)=\begin{aligned}\frac{1}{d}\cdot
\sum_{i=0}^{d-1}e^{\omega_d^ix}\end{aligned}\)</span></p>
<p>而总的生成函数就是 <span
class="math inline">\(G(x)=F^k(x)\)</span></p>
<p>即 <span class="math inline">\(\begin{aligned}
G(x)=\frac{1}{d^k}\cdot
(\sum_{i=0}^{d-1}e^{\omega_d^ix})^k\end{aligned}\)</span></p>
<p>其中的和式幂次展开会得到一个 <span class="math inline">\(k^d\)</span>
项的多项式，我们要求 <span class="math inline">\([x^n]G(x)\)</span>
，就需要展开得到每一项的幂系数</p>
<p>所以显然我们需要先合并同类项一下。。。</p>
<p>而幂系数是一个单位根之和的形式，这就需要我们寻找单位根之间的关系</p>
<p>这里得到一个思路：用 <span class="math inline">\(d\)</span>
次单位根中的 <span class="math inline">\(\varphi(d)\)</span>
个作为基底，以简单的 有理数/整系数 表示出所有的 <span
class="math inline">\(\omega_d^i\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p>对于 <span class="math inline">\(d=4\)</span> 的情况比较简单， <span
class="math inline">\(\varphi(d)=2\)</span> ，可以得到四个单位根分别为
<span class="math inline">\(1,\omega,-1,-\omega\)</span></p>
<p>可以枚举得到的和为 <span class="math inline">\(x+y\omega\)</span>
，然后求系数</p>
<p>优先考虑组合意义，可以发现就是在平面上每次可以走四个方向， <span
class="math inline">\(k\)</span> 步之后最终到达 <span
class="math inline">\((x,y)\)</span> 的方案数</p>
<p>两个维度分立的情况，还需要枚举每个维度走了几步，所以用一种巧妙的转化两个维度联系在一起</p>
<p>将平面旋转 <span class="math inline">\(\frac{\pi}{8}\)</span>
，并且扩大 <span class="math inline">\(\sqrt 2\)</span>
倍，得到新的坐标为 <span class="math inline">\((x-y,x+y)\)</span>
，新的行走方向是 <span
class="math inline">\((+1,+1),(-1,-1),(-1,+1),(+1,-1)\)</span></p>
<p>这样以来，每次每个维度都有行走，可以确定每个维度 <span
class="math inline">\(+1\)</span> 和 <span
class="math inline">\(-1\)</span> 的次数，直接组合数排列即可得到答案</p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p>对于 <span class="math inline">\(d=6\)</span>
，甚至是更一般的情况的情况</p>
<p>只在代数层面来看单位根似乎十分抽象，不如从复平面单位根上找一找灵感</p>
<p>下面是 <span class="math inline">\(d=6\)</span> 的情形</p>
<figure>
<img src="https://i.loli.net/2021/01/30/Bb3vJq1TGPgtfs2.png"
alt="planeomega.png" />
<figcaption aria-hidden="true">planeomega.png</figcaption>
</figure>
<p><span class="math inline">\(\varphi(6)=2\)</span> ，假设以 <span
class="math inline">\(\overrightarrow{OA},\overrightarrow{OB}\)</span>
作为基底，可以直观地得到基底表达</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 27%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><span class="math inline">\(\overrightarrow{OA}=1\)</span></th>
<th><span class="math inline">\(\overrightarrow{OB}=\omega\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span
class="math inline">\(\overrightarrow{OA}=\omega_6^0\)</span></td>
<td>1</td>
<td>0</td>
</tr>
<tr class="even">
<td><span
class="math inline">\(\overrightarrow{OB}=\omega_6^1\)</span></td>
<td>0</td>
<td>1</td>
</tr>
<tr class="odd">
<td><span
class="math inline">\(\overrightarrow{OC}=\omega_6^2\)</span></td>
<td>-1</td>
<td>1</td>
</tr>
<tr class="even">
<td><span
class="math inline">\(\overrightarrow{OD}=\omega_6^3\)</span></td>
<td>-1</td>
<td>0</td>
</tr>
<tr class="odd">
<td><span
class="math inline">\(\overrightarrow{OE}=\omega_6^4\)</span></td>
<td>0</td>
<td>-1</td>
</tr>
<tr class="even">
<td><span
class="math inline">\(\overrightarrow{OF}=\omega_6^5\)</span></td>
<td>1</td>
<td>-1</td>
</tr>
</tbody>
</table>
<p>由此我们得到了一个 <span class="math inline">\(\varphi(d)\)</span>
维数的表达方法</p>
<p>把每一维看做不同元，也就是说，得到了一个 <span
class="math inline">\(\varphi(d)\)</span> 维， <span
class="math inline">\(O(1)\)</span>
次的多项式，需要我们求高维多项式幂次</p>
<p>令 <span class="math inline">\(N=k^{\varphi(d)}\)</span></p>
<p>直接压位暴力多项式复杂度为 <span class="math inline">\(O(N\log
N-N\log^2N)\)</span> ，而且面临着模数难以处理，常数大的问题</p>
<p>所以 <span class="math inline">\(\text{EI}\)</span>
又用出了一个巧妙的暴力方法解决这个问题，以 <span
class="math inline">\(d=6\)</span>
为例，先做一下处理，得到要求的多项式</p>
<p><del>似乎每次 <span class="math inline">\(k\)</span>
次幂总是求导+递推？</del></p>
<p><span
class="math inline">\(f(x,y)=x^2y+xy^2+y^2+y+x+x^2,g(x,y)=f^k(x,y)\)</span></p>
<p><span class="math inline">\(g(x,y)\)</span> 对于 <span
class="math inline">\(x\)</span> 求偏导，得到 <span
class="math inline">\(g&#39;(x,y)=kf^{k-1}(x,y)f&#39;(x,y)\)</span></p>
<p>即 <span
class="math inline">\(g&#39;(x,y)f(x,y)=kg(x,y)f&#39;(x,y)\)</span></p>
<p><span class="math inline">\(f&#39;(x,y)=2xy+2x+y^2+1\)</span></p>
<p>然后我们要解这个方程，考虑乘积为 <span
class="math inline">\([x^ny^m]\)</span> 一项两边的系数</p>
<p>左边 <span
class="math inline">\(=[x^{n-2}y^{m-1}]+[x^{n-1}y^{m-2}]+[x^{n}y^{m-2}]+[x^{n}y^{m-1}]+[x^{n-1}y^{m}]+[x^{n-2}y^{m}]\)</span></p>
<p>换成 <span class="math inline">\(g(x,y)\)</span> 的系数应该是</p>
<p>左边 <span
class="math inline">\(=(n-1)[x^{n-1}y^{m-1}]+n[x^{n}y^{m-2}]+(n+1)[x^{n+1}y^{m-2}]+(n+1)[x^{n+1}y^{m-1}]+n[x^{n}y^{m}]+(n-1)[x^{n-1}y^{m}]\)</span></p>
<p>右边 <span
class="math inline">\(=2k[x^{n-1}y^{m-1}]+2k[x^{n-1}y^m]+k[x^ny^{m-2}]+k[x^ny^m]\)</span></p>
<p>其中 <span class="math inline">\([x^{n+1}y^{m-1}]\)</span>
只出现了一次，按照先 <span class="math inline">\(n\)</span> 递增再 <span
class="math inline">\(m\)</span> 递增的顺序进行递推，即</p>
<p><span class="math inline">\(\begin{aligned}\
[x^ny^m]=\frac{2k[x^{n-2}y^{m}]+2k[x^{n-2}y^{m+1}]+k[x^{n-1}y^{m-1}]+k[x^{n-1}y^{m+1}]}{n}\end{aligned}\)</span></p>
<p><span
class="math inline">\(\begin{aligned}-\frac{(n-2)[x^{n-2}y^{m}]+(n-1)[x^{n-1}y^{m-1}]+n[x^{n}y^{m-1}]+(n-1)[x^{n-1}y^{m+1}]+(n-2)[x^{n-2}y^{m+1}]}{n}\end{aligned}\)</span></p>
<p>边界条件是 <span class="math inline">\(\begin{aligned}\
[x^i]=[y^i](i\ge k)=\binom{k}{i-k}\end{aligned}\)</span> (由系数 <span
class="math inline">\(x,x^2\)</span> 或 <span
class="math inline">\(y,y^2\)</span> 得到)</p>
<p>由此带入递推即可</p>
<p>综上，得到的每项的系数的复杂度为 <span class="math inline">\(O(d\cdot
k^{\varphi(d)})\)</span> ，其中 <span class="math inline">\(d\)</span>
为递推每项需要的时间</p>
<p>由系数得到答案仍然需要一次快速幂，因此依然带一个 <span
class="math inline">\(\log P\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; a=<span class="built_in">min</span>(a,b); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; a=<span class="built_in">max</span>(a,b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>,P=<span class="number">1049874433</span>,G=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k,d;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">    k%=P<span class="number">-1</span>;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> w[<span class="number">100</span>],C[N][N],I[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>(),d=<span class="built_in">rd</span>();</span><br><span class="line">    w[<span class="number">0</span>]=<span class="number">1</span>,w[<span class="number">1</span>]=<span class="built_in">qpow</span>(G,(P<span class="number">-1</span>)/d);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,<span class="number">90</span>) w[i]=<span class="number">1ll</span>*w[i<span class="number">-1</span>]*w[<span class="number">1</span>]%P;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,k) <span class="built_in">rep</span>(j,C[i][<span class="number">0</span>]=<span class="number">1</span>,i) C[i][j]=C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>],<span class="built_in">Mod1</span>(C[i][j]);</span><br><span class="line">    I[<span class="number">0</span>]=I[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,k*<span class="number">2</span>) I[i]=<span class="number">1ll</span>*(P-P/i)*I[P%i]%P;</span><br><span class="line">    <span class="keyword">if</span>(d==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="built_in">qpow</span>(k,<span class="number">1ll</span>*d*n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(d==<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,k) ans=(ans+<span class="built_in">qpow</span>((<span class="number">1ll</span>*w[<span class="number">0</span>]*i+<span class="number">1ll</span>*w[<span class="number">1</span>]*(k-i))%P,<span class="number">1ll</span>*d*n)*C[k][i])%P;</span><br><span class="line">        ans=ans*<span class="built_in">qpow</span>(<span class="built_in">qpow</span>(d,k))%P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(d==<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,k) <span class="built_in">rep</span>(j,<span class="number">0</span>,k-i) </span><br><span class="line">            ans=(ans+<span class="built_in">qpow</span>((<span class="number">1ll</span>*w[<span class="number">0</span>]*i+<span class="number">1ll</span>*w[<span class="number">1</span>]*j+<span class="number">1ll</span>*w[<span class="number">2</span>]*(k-i-j))%P,<span class="number">1ll</span>*d*n)*C[i+j][i]%P*C[k][i+j])%P;</span><br><span class="line">        ans=ans*<span class="built_in">qpow</span>(<span class="built_in">qpow</span>(d,k))%P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(d==<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,-k,k) <span class="built_in">rep</span>(j,-k,k) <span class="keyword">if</span>(<span class="built_in">abs</span>(i)+<span class="built_in">abs</span>(j)&lt;=k &amp;&amp; (k-i-j)%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">            ll x=<span class="built_in">qpow</span>((<span class="number">1ll</span>*w[<span class="number">0</span>]*i+<span class="number">1ll</span>*w[<span class="number">1</span>]*j)%P,<span class="number">1ll</span>*d*n);</span><br><span class="line">            ll y=<span class="number">1ll</span>*C[k][(<span class="built_in">abs</span>(i-j)+k)/<span class="number">2</span>]*C[k][(k+<span class="built_in">abs</span>(i+j))/<span class="number">2</span>]%P;</span><br><span class="line">            ans=(ans+x*y)%P;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+P)*<span class="built_in">qpow</span>(<span class="built_in">qpow</span>(d,k))%P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> F[N*<span class="number">2</span>][N*<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,k*<span class="number">2</span>) <span class="built_in">rep</span>(j,<span class="built_in">max</span>(k-i,<span class="number">0</span>),<span class="built_in">min</span>(<span class="number">2</span>*k,<span class="number">3</span>*k-i)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) F[i][j]=C[k][j-k];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) F[i][j]=C[k][i-k];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> s=(<span class="number">2ll</span>*k*(i&gt;<span class="number">1</span>?F[i<span class="number">-2</span>][j]+F[i<span class="number">-2</span>][j+<span class="number">1</span>]:<span class="number">0</span>)+<span class="number">1ll</span>*k*(F[i<span class="number">-1</span>][j<span class="number">-1</span>]+F[i<span class="number">-1</span>][j+<span class="number">1</span>]))%P;</span><br><span class="line">                <span class="type">int</span> t=((i&gt;<span class="number">1</span>?<span class="number">1ll</span>*(i<span class="number">-2</span>)*(F[i<span class="number">-2</span>][j]+F[i<span class="number">-2</span>][j+<span class="number">1</span>]):<span class="number">0</span>)+</span><br><span class="line">                    <span class="number">1ll</span>*(i<span class="number">-1</span>)*F[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1ll</span>*i*F[i][j<span class="number">-1</span>]+<span class="number">1ll</span>*(i<span class="number">-1</span>)*F[i<span class="number">-1</span>][j+<span class="number">1</span>])%P;</span><br><span class="line">                F[i][j]=<span class="number">1ll</span>*(s-t+P)*I[i]%P;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=(ans+<span class="built_in">qpow</span>((<span class="number">1ll</span>*w[<span class="number">0</span>]*(i-k)+<span class="number">1ll</span>*w[<span class="number">1</span>]*(j-k))%P,<span class="number">1ll</span>*d*n)*F[i][j])%P;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+P)*<span class="built_in">qpow</span>(<span class="built_in">qpow</span>(d,k))%P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%5BLOJ6729%5D%20%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E7%94%9F%E6%88%90%E5%AD%90%E5%9B%BE%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<hr />
<p>title: 'LOJ6729. 点双连通生成子图计数 (集合幂级数)' date: 'Sat Aug 12
11:05:28 2023 categories: - oi-solutions'</p>
<h1 id="loj6729.-点双连通生成子图计数-集合幂级数">LOJ6729.
点双连通生成子图计数 (集合幂级数)</h1>
<p>基础： 由子图的集合幂级数取 <span class="math inline">\(\ln\)</span>
可以得到连通子图的集合幂级数，<a
href="https://www.cnblogs.com/chasedeath/p/13891189.html">可以参考?</a></p>
<p>根据点双连通的定义，我们先求得连通子图的集合幂级数</p>
<p>然后考虑枚举每个节点 <span class="math inline">\(i\)</span>
，把所有删去 <span class="math inline">\(i\)</span>
之后不连通的方案去掉</p>
<p>具体实现上，可以把所有包含 <span class="math inline">\(i\)</span>
的项提出，删除 <span class="math inline">\(i\)</span> 之后取 <span
class="math inline">\(\ln\)</span> 得到连通的方案数，然后替换回去</p>
<p>每次取 <span class="math inline">\(\ln\)</span> 的复杂度为 <span
class="math inline">\(O(n^22^n)\)</span> ，因此总复杂度为 <span
class="math inline">\(O(n^32^n)\)</span></p>
<p>常数优化：每次实际上只会修改包含 <span
class="math inline">\(i\)</span>
的项，不需要每次都把多项式莫比乌斯反演回去</p>
<p>刚开始进行一次莫比乌斯变换之后</p>
<p>每次可以直接从前缀和的作差得到这一项 除了 <span
class="math inline">\(i\)</span> 以外的位置
累和之后的结果，然后直接对于形式幂级数取 <span
class="math inline">\(\ln\)</span> ，具体实现见代码</p>
<p>注意去掉 <span class="math inline">\(i\)</span> 后，占位数量 <span
class="math inline">\(-1\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">18</span>|<span class="number">3</span>,P=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">U</span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">U</span>()&#123;&#125; <span class="built_in">U</span>(<span class="type">int</span> x):<span class="built_in">x</span>(x)&#123;&#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> += (<span class="type">const</span> U &amp;t)&#123; x+=t.x,x&gt;=P&amp;&amp;(x-=P); &#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> -= (<span class="type">const</span> U &amp;t)&#123; x-=t.x,x&lt;<span class="number">0</span>&amp;&amp;(x+=P); &#125;</span><br><span class="line">	<span class="keyword">inline</span> U <span class="keyword">operator</span> * (<span class="type">const</span> U &amp;t)&#123; <span class="keyword">return</span> <span class="built_in">U</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(x)*t.x%P); &#125;</span><br><span class="line">&#125; I[N],F[M][N],b[N];</span><br><span class="line"><span class="type">int</span> n,m,G[N],C[M],Pow[N*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i&lt;&lt;=<span class="number">1</span>) <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;m;l+=i*<span class="number">2</span>) </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) <span class="keyword">if</span>(f==<span class="number">1</span>) <span class="built_in">rep</span>(d,<span class="number">1</span>,n) F[j+i][d]+=F[j][d];</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">rep</span>(d,<span class="number">1</span>,n) F[j+i][d]-=F[j][d];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ln</span><span class="params">(U *a)</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">		U t=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,i<span class="number">-1</span>) t+=b[j]*a[i-j];</span><br><span class="line">		b[i]=a[i+<span class="number">1</span>]*(i+<span class="number">1</span>),b[i]-=t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) a[i]=b[i<span class="number">-1</span>]*I[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u,v;m--;) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v),u--,v--,G[u]|=<span class="number">1</span>&lt;&lt;v,G[v]|=<span class="number">1</span>&lt;&lt;u;</span><br><span class="line">	m=<span class="number">1</span>&lt;&lt;n,I[<span class="number">0</span>]=I[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) C[i]=C[i&amp;(i<span class="number">-1</span>)]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n) I[i]=<span class="built_in">U</span>(P-P/i)*I[P%i];</span><br><span class="line">	<span class="built_in">rep</span>(i,Pow[<span class="number">0</span>]=<span class="number">1</span>,N*N<span class="number">-1</span>) Pow[i]=Pow[i<span class="number">-1</span>]*<span class="number">2</span>%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) c+=C[G[j]&amp;i];</span><br><span class="line">		F[i][C[i]]=Pow[c/<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FWT</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) <span class="built_in">Ln</span>(F[i]);</span><br><span class="line">    <span class="comment">// 先取一次ln得到连通子图的集合幂级数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;m;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">				<span class="built_in">rep</span>(k,<span class="number">1</span>,n) F[j+i][k]-=F[j][k]; <span class="comment">// 前缀和作差得到</span></span><br><span class="line">				<span class="built_in">Ln</span>(F[j+i]+<span class="number">1</span>); <span class="comment">// 取出自己后大小-1</span></span><br><span class="line">				<span class="built_in">rep</span>(k,<span class="number">1</span>,n) F[j+i][k]+=F[j][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FWT</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,F[m<span class="number">-1</span>][n].x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%5BLOJ6719%5D%20300iq%20contest2%20%E6%95%B0%E4%BB%99%E4%BA%BA%E6%8E%8C%20%E5%8A%A0%E5%BC%BA%E7%89%88/</url>
    <content><![CDATA[<hr />
<p>title: 'LOJ 6719. 「300iq Contest 2」数仙人掌 加强版 (集合幂级数)'
date: 'Sat Aug 12 11:05:28 2023 categories: - oi-solutions'</p>
<h1 id="loj-6719.-300iq-contest-2数仙人掌-加强版-集合幂级数">LOJ 6719.
「300iq Contest 2」数仙人掌 加强版 (集合幂级数)</h1>
<p>前置知识：<a
href="https://www.cnblogs.com/chasedeath/p/13891189.html">集合幂级数的
<span class="math inline">\(\ln ,\exp\)</span></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="keyword">enum</span>&#123;N=<span class="number">20</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">18</span>|<span class="number">10</span>,P=<span class="number">998244353</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">U</span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">U</span>()&#123;&#125; <span class="built_in">U</span>(<span class="type">int</span> x):<span class="built_in">x</span>(x)&#123;&#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> += (<span class="type">const</span> U &amp;t)&#123; x+=t.x,x&gt;=P&amp;&amp;(x-=P); &#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> -= (<span class="type">const</span> U &amp;t)&#123; x-=t.x,x&lt;<span class="number">0</span>&amp;&amp;(x+=P); &#125;</span><br><span class="line">	<span class="keyword">inline</span> U <span class="keyword">operator</span> * (<span class="type">const</span> U &amp;t)&#123; <span class="keyword">return</span> <span class="built_in">U</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(x)*t.x%P); &#125;</span><br><span class="line">&#125;I[N],F[M][N],H[M][N];</span><br><span class="line"><span class="type">int</span> n,m,G[N],C[M],B[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;m;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">				<span class="keyword">if</span>(f==<span class="number">1</span>) <span class="built_in">rep</span>(d,<span class="number">1</span>,n) F[j+i][d]+=F[j][d];</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">rep</span>(d,<span class="number">1</span>,n) F[j+i][d]-=F[j][d];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exp</span><span class="params">(U *a)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> U b[N];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) b[i]=a[i+<span class="number">1</span>]*(i+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">		U t=b[i];</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,i) t+=a[j]*b[i-j];</span><br><span class="line">		a[i+<span class="number">1</span>]=t*I[i+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x,y;m--;) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),x--,y--,G[x]|=<span class="number">1</span>&lt;&lt;y,G[y]|=<span class="number">1</span>&lt;&lt;x;</span><br><span class="line">	I[<span class="number">0</span>]=I[<span class="number">1</span>]=<span class="number">1</span>,m=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) B[<span class="number">1</span>&lt;&lt;i]=i;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n) I[i]=<span class="built_in">U</span>(P-P/i)*I[P%i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) C[i]=C[i&amp;(i<span class="number">-1</span>)]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(st,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">		H[<span class="number">1</span>&lt;&lt;st][st]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(S,<span class="number">0</span>,m<span class="number">-1</span>) <span class="built_in">rep</span>(i,st,n<span class="number">-1</span>) <span class="keyword">if</span>(H[S][i].x) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> T=G[i]&amp;~S;T;T&amp;=T<span class="number">-1</span>) </span><br><span class="line">				H[S|(T&amp;-T)][B[T&amp;-T]]+=H[S][i];</span><br><span class="line">			<span class="keyword">if</span>(G[i]&amp;(<span class="number">1</span>&lt;&lt;st)) F[S][C[S]]+=H[S][i]*I[<span class="number">1</span>+(C[S]&gt;<span class="number">2</span>)];</span><br><span class="line">			H[S][i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FWT</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;m;l+=i*<span class="number">2</span>) <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">			<span class="built_in">rep</span>(k,<span class="number">1</span>,n) F[j+i][k]-=F[j][k];</span><br><span class="line">			<span class="built_in">Exp</span>(F[j+i]+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">rep</span>(k,<span class="number">1</span>,n) F[j+i][k]+=F[j][k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FWT</span>(<span class="number">-1</span>),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,F[m<span class="number">-1</span>][n].x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/olefin/</url>
    <content><![CDATA[<hr />
<p>title: 'olefin' date: 'Sat Aug 12 11:05:27 2023 categories: -
oi-solutions'</p>
<h1 id="olefin">olefin</h1>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的01字符串</p>
<p>烯烃不存在连续两个碳碳双键出现的情况，因此可以把原来的序列分成若干个01交替序列，相邻之间用多个0隔开，这些序列之间不会干扰</p>
<p>一个包含 <span class="math inline">\(n\)</span>
个碳碳双键的交替序列加成 <span class="math inline">\(k\)</span>
次的方案数为 <span class="math inline">\(\displaystyle
\binom{n+k}{n-k}\prod_{i=1}^{k} (2i-1)\)</span></p>
<p>证明思路：</p>
<p>一共有 <span class="math inline">\(\displaystyle
\binom{n+k}{n-k}\)</span> 种可能的结束状态</p>
<p>且任何一个合法状态均有 <span class="math inline">\(\prod_{i=1}^m
(2i-1)\)</span> 种可能的构造方法</p>
<p>可以从0次操作开始向上归纳，对于一个 <span
class="math inline">\(k\)</span> 次操作的状态，合法的逆操作一定是一段
<strong>两端是0的极长的</strong>
交替序列，容易通过次数分析发现此时合法的极长交替序列就只有 <span
class="math inline">\(2k-1\)</span> 个，即完成从上层的归纳</p>
<p>按照这个式子，分治 <span class="math inline">\(\text{NTT}\)</span>
即可</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/lojp6061/</url>
    <content><![CDATA[<hr />
<p>title: 'Loj6061. 「2017 山东一轮集训 Day1」Sim' date: 'Sat Aug 12
11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="loj6061.-2017-山东一轮集训-day1sim">Loj6061. 「2017 山东一轮集训
Day1」Sim</h1>
<p>离线，忽略删除操作之后，为每次插入的数编号（不考虑值，仅考虑位置）。</p>
<p>用树状数组+链表可以确定每一个被插入的数的位置。</p>
<p>接下来维护序列，每一个位置有两个值： <span
class="math inline">\((A_i,P_i)\)</span> 。其中 <span
class="math inline">\(A_i\)</span> 为权值， <span
class="math inline">\(P_i\)</span> 为这一个值上次出现的位置。</p>
<p>由于查询操作只考虑不同的元素，即对于区间 <span
class="math inline">\([l,r]\)</span> ，我们只考虑其中 <span
class="math inline">\(P_i&lt;l\)</span> 的部分。</p>
<p>如果一个位置还没有被加入序列，或者已经被删除，将其标记为 <span
class="math inline">\(P_i=\infty\)</span> 即可。用树状数组可定位 <span
class="math inline">\(l,r\)</span> 在重构序列中的位置。</p>
<p>此时，问题变成了单点修改，二维区间查询。</p>
<p>维护和，两个元素积的和，三个元素积的和即可处理操作1，操作5即数点。</p>
<p>动态二维数点可以通过分块或者树套树处理。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%5B%E5%AD%A6%E5%86%9B20201104CSP%E6%A8%A1%E6%8B%9F%E8%B5%9B%5D%20%E4%BA%8C%E7%BB%B4%E7%A0%81%20/</url>
    <content><![CDATA[<hr />
<p>title: '[学军20201104CSP模拟赛] 二维码' date: 'Sat Aug 12 11:05:28
2023 categories: - oi-solutions'</p>
<h1 id="学军20201104csp模拟赛-二维码">[学军20201104CSP模拟赛]
二维码</h1>
<p>简要题意：</p>
<p>对于 <span class="math inline">\(n\times m\)</span>
的网格图，初始时全部为白色，现在 通过下面的方法染色</p>
<p>每次选择一个行或者列，把它全部染成黑色或者全部染成白色</p>
<p>求任意操作的情况下，可以得到的不同网格图的数量 <span
class="math inline">\(\mod 998244353\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p>判定一个染色方案是否有解的条件是：</p>
<p>染色完成的矩阵不包含一个子矩阵满足四个角分别为</p>
<p>01</p>
<p>10</p>
<p>或者</p>
<p>10</p>
<p>01</p>
<p>但是这样看这个条件似乎比较抽象，如果具体对于一个行上考虑，就是满足</p>
<p>每一行<strong>所包含的1的位置</strong>的集合之间
<strong>互为子集</strong></p>
<p>显然一个方案可以任意交换行/列，不妨把按照每一行1的个数将每一行排序，设每一行有
<span class="math inline">\(a_i\)</span> 个1，边界条件为 <span
class="math inline">\(a_0=0\)</span></p>
<p>那么对于行上的1考虑排列，方案数为 <span
class="math inline">\(\begin{aligned} \prod
\binom{m-a_{i-1}}{a_i-a_{i-1}}\end{aligned}\)</span> ，即从空的 <span
class="math inline">\(m-a_{i-1}\)</span> 个位置里选出多出的 <span
class="math inline">\(a_i-a_{i-1}\)</span> 个位置</p>
<p>而对于列之间的排列需要考虑 <span class="math inline">\(a_i\)</span>
与 <span class="math inline">\(a_{i+1}\)</span> 的关系，因为如果 <span
class="math inline">\(a_i=a_{i+1}\)</span> 时，必然满足这两行相同</p>
<p>设所有的 <span class="math inline">\(a_i\)</span>
构成若干个相同的组，每一组包含 <span
class="math inline">\(b_i(i\in[1,k])\)</span> 个元素，则方案数显然为
<span class="math inline">\(\begin{aligned} \frac{n!}{\prod
b_i!}\end{aligned}\)</span></p>
<p>而组内的 <span class="math inline">\(a_i\)</span> 之间显然是没有
<span class="math inline">\(\begin{aligned} \sum
\binom{m-a_{i-1}}{a_i-a_{i-1}}\end{aligned}\)</span>
的贡献的，可以跳过</p>
<p>由此，不妨令 <span class="math inline">\(dp_{i,j}\)</span> 表示 <span
class="math inline">\(dp\)</span> 了前 <span
class="math inline">\(i\)</span> 行，最后一行 <span
class="math inline">\(a_i=j\)</span> ，每次枚举每个组 <span
class="math inline">\(b_i\)</span> 转移</p>
<p>复杂度为 <span class="math inline">\(O(n^4)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2010</span>,P=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n,m,C[N][N],dp[N][N],I[N],J[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,J[<span class="number">0</span>]=<span class="number">1</span>,N<span class="number">-1</span>) J[i]=<span class="number">1ll</span>*J[i<span class="number">-1</span>]*i%P;</span><br><span class="line">	I[N<span class="number">-1</span>]=<span class="built_in">qpow</span>(J[N<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">drep</span>(i,N<span class="number">-2</span>,<span class="number">0</span>) I[i]=<span class="number">1ll</span>*I[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,N<span class="number">-1</span>) <span class="built_in">rep</span>(j,C[i][<span class="number">0</span>]=<span class="number">1</span>,i) C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%P;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) dp[i][<span class="number">0</span>]=I[i]; <span class="comment">// 第一个块</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="built_in">rep</span>(a,<span class="number">0</span>,i<span class="number">-1</span>) <span class="built_in">rep</span>(b,<span class="number">0</span>,j<span class="number">-1</span>) &#123;</span><br><span class="line">			dp[i][j]=(dp[i][j]+<span class="number">1ll</span>*dp[a][b]*I[i-a]%P*C[m-b][j-b])%P;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,m) ans=(ans+dp[n][i])%P;</span><br><span class="line">	ans=<span class="number">1ll</span>*ans*J[n]%P;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：</p>
<p>发现两维 <span class="math inline">\(dp\)</span>
之间是相互独立的，分别是把 <span class="math inline">\(n,m\)</span>
分组</p>
<p>令 <span class="math inline">\(F_{i,j}\)</span> 表示把 <span
class="math inline">\(n\)</span> 分成了 <span
class="math inline">\(i\)</span> 个组，当前总和为 <span
class="math inline">\(j\)</span> 的方案数， <span
class="math inline">\(G_{i,j}\)</span> 表示把 <span
class="math inline">\(m\)</span> 分成 <span
class="math inline">\(i\)</span> 组，当前总和为 <span
class="math inline">\(j\)</span></p>
<p>按照上面的系数转移，最后 <span class="math inline">\(O(n)\)</span>
合并，复杂度为 <span class="math inline">\(O(n^3)\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p>进一步优化：</p>
<p>为了方便下面的叙述，不妨先整理一下 <span
class="math inline">\(a_i\)</span> 之间转移的系数，不妨设边界 <span
class="math inline">\(a_{n+1}=m\)</span></p>
<p><span class="math inline">\(\begin{aligned} \prod
\binom{m-a_{i-1}}{a_i-a_{i-1}}=\prod_{i=1}^n
\frac{(m-a_{i-1})!}{(a_i-a_{i-1})!(m-a_{i})!}=
\frac{m!}{\prod_{i=1}^{n+1} (a_{i}-a_{i-1})!}\end{aligned}\)</span></p>
<p>发现实际上和列之间的系数是类似的，每次枚举 <span
class="math inline">\(a_i-a_{i-1}\)</span> 即可</p>
<p>而实际上只有 <span class="math inline">\(k\)</span> 个 <span
class="math inline">\(b_i\)</span> 直接相交的位置 <span
class="math inline">\(a_{i}-a_{i-1}\)</span>
有效，因此行和列实际上分别是将 <span class="math inline">\(n,m\)</span>
分成了 <span class="math inline">\(k\)</span> 组</p>
<p>观察上面的转移系数，行构成的块，首个块大小可以为 <span
class="math inline">\(0\)</span> ，而列构成的块最后一个块大小可以为
<span class="math inline">\(0\)</span> ，所以这个并不是严格分成 <span
class="math inline">\(k\)</span> 组，下面会讨论这个问题</p>
<p>我们计算答案的复杂度消耗在计算分成若干块的方案，而实际上，把 <span
class="math inline">\(n\)</span> 分成 <span
class="math inline">\(k\)</span> 块的方案数就是 <span
class="math inline">\(\begin{Bmatrix} n\\ k\end{Bmatrix}\cdot
k!\)</span></p>
<p>用 <span class="math inline">\(n^2\)</span>
递推第二类斯特林数的方法即可计算</p>
<p>对于并不是严格分成 <span class="math inline">\(k\)</span>
组的问题，可以考虑把开头/结尾那一个大小为 <span
class="math inline">\(0\)</span> 的块删掉，即同时还要考虑 <span
class="math inline">\(\begin{Bmatrix}n \\
k-1\end{Bmatrix}(k-1)!\)</span></p>
<p>最后再枚举 <span class="math inline">\(k\)</span> ，复杂度为 <span
class="math inline">\(O(n^2)\)</span></p>
<p>更优化的就是 <span class="math inline">\(\text{NTT}\)</span>
计算斯特林数，带入通项公式</p>
<p><span class="math inline">\(\begin{aligned} \begin{Bmatrix}n\\
m\end{Bmatrix}m!=\sum_{i=0}^m i^n(-1)^{m-i}\binom{m}{i}
\end{aligned}\)</span></p>
<p>显然把组合数拆开 <span class="math inline">\(\text{NTT}\)</span>
即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">18</span>|<span class="number">10</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> I[N],J[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; </span><br><span class="line">	<span class="type">int</span> R=<span class="number">2</span>,c=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(R&lt;=n) R&lt;&lt;=<span class="number">1</span>,c++;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;c);</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> e[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=e[<span class="number">0</span>]=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		ll t=<span class="built_in">qpow</span>(f==<span class="number">1</span>?<span class="number">3</span>:(P+<span class="number">1</span>)/<span class="number">3</span>,(P<span class="number">-1</span>)/i/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j-=<span class="number">2</span>) e[j+<span class="number">1</span>]=(e[j]=e[j&gt;&gt;<span class="number">1</span>])*t%P;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">				<span class="type">int</span> t=<span class="number">1ll</span>*a[j+i]*e[j-l]%P;</span><br><span class="line">				a[j+i]=a[j]-t,<span class="built_in">Mod2</span>(a[j+i]);</span><br><span class="line">				a[j]+=t,<span class="built_in">Mod1</span>(a[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">		ll base=<span class="built_in">qpow</span>(n);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=a[i]*base%P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[N],B[N],C[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">if</span>(n&lt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">	<span class="built_in">rep</span>(i,J[<span class="number">0</span>]=<span class="number">1</span>,N<span class="number">-1</span>) J[i]=<span class="number">1ll</span>*J[i<span class="number">-1</span>]*i%P;</span><br><span class="line">	I[N<span class="number">-1</span>]=<span class="built_in">qpow</span>(J[N<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">drep</span>(i,N<span class="number">-2</span>,<span class="number">0</span>) I[i]=<span class="number">1ll</span>*I[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%P;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> R=<span class="built_in">Init</span>(n+n+<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) A[i]=<span class="built_in">qpow</span>(i,n)*I[i]%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) B[i]=(i&amp;<span class="number">1</span>)?P-I[i]:I[i];</span><br><span class="line">	<span class="built_in">NTT</span>(R,A,<span class="number">1</span>),<span class="built_in">NTT</span>(R,B,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) A[i]=<span class="number">1ll</span>*A[i]*B[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,A,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,n+<span class="number">1</span>,R) A[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,m) C[i]=<span class="built_in">qpow</span>(i,m)*I[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,C,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) C[i]=<span class="number">1ll</span>*C[i]*B[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,C,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,m+<span class="number">1</span>,R) C[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="built_in">min</span>(n,m)) ans=(ans+<span class="number">1ll</span>*(<span class="number">1ll</span>*A[i]*J[i]%P+<span class="number">1ll</span>*A[i+<span class="number">1</span>]*J[i+<span class="number">1</span>]%P)*(<span class="number">1ll</span>*C[i]%P*J[i]%P+<span class="number">1ll</span>*C[i+<span class="number">1</span>]*J[i+<span class="number">1</span>]%P))%P;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8C2020-2021%20%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A%E3%80%8DYet%20Another%20Permutation%20Problem/</url>
    <content><![CDATA[<hr />
<p>title: '「2020-2021 集训队作业」Yet Another Permutation Problem'
date: 'Sat Aug 12 11:05:28 2023 categories: - oi-solutions'</p>
<h1 id="集训队作业yet-another-permutation-problem">「2020-2021
集训队作业」Yet Another Permutation Problem</h1>
<h3 id="题目大意">题目大意</h3>
<p>对于一个初始为 <span class="math inline">\(1,2,\ldots n\)</span>
的排列，每次操作为选择一个数放到开头或者结尾，求 <span
class="math inline">\(k\)</span> 次操作能够生成的排列数</p>
<p>对于 <span class="math inline">\(k=0,1,\ldots ,n-1\)</span> 求解</p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="模型转化">模型转化</h3>
<p>容易发现，对于一个排列，生成它的最小次数取决于中间保留段的长度</p>
<p>而保留段实际上是任何一个上升子段</p>
<p>设一个排列的最长上升子段为 <span class="math inline">\(l\)</span>
，那么最少操作步骤就是 <span class="math inline">\(n-l\)</span></p>
<p>那么对于 <span class="math inline">\(k\)</span>
，合法的序列就是存在一个长度 <span class="math inline">\(\ge
n-k\)</span> 的上升子段</p>
<p>存在不好算，改为计算任何一个上升子段 <span
class="math inline">\(&lt;n-k\)</span> 的数量</p>
<p>为了便于描述，令下文的 <span
class="math inline">\(k=n-k-1\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="生成函数构造">生成函数构造</h3>
<p>考虑一个序列是由若干上升段构成的，设一个长度为 <span
class="math inline">\(l\)</span> 的上升段的权值为 <span
class="math inline">\([l\leq k]\)</span></p>
<p>那么排列的权值就是上升段权值之积</p>
<p>容易想到用 <span class="math inline">\(\text{EGF}\)</span>
合并上升段，但是直接的统计，我们无法保证上升段之间无法拼接</p>
<p>假设我们确定了一个单位上升段的 <span
class="math inline">\(\text{EGF}\)</span> 为 <span
class="math inline">\(G(x)\)</span> ， <span
class="math inline">\(\text{OGF}\)</span> 为 <span
class="math inline">\(F(x)\)</span></p>
<p>那么按照上面 <span class="math inline">\(\text{Naive}\)</span>
的计算，上升段之间的合并为有序拼接，即 <span
class="math inline">\(\displaystyle
\sum_{i=0}G^i(x)=\frac{1}{1-G(x)}\)</span></p>
<p>容易发现，这样的计算，会导致一个长度为 <span
class="math inline">\(l\)</span> 的极长上升段被分解成若干小段</p>
<p>也就是被计算了 <span class="math inline">\(\displaystyle
[x^l](\sum_{i=0}F^i(x))=[x^l]\frac{1}{1-F(x)}\)</span> 次</p>
<p>在合法的计算中，我们希望， <span
class="math inline">\([x^l]\frac{1}{1-F(x)}\)</span> 恰好为权值 <span
class="math inline">\([l\leq k]\)</span></p>
<p>也就是说，我们希望 <span class="math inline">\(\displaystyle
\frac{1}{1-F(x)}=H(x)=\sum_{i=0}^kx^i=\frac{x^{k+1}-1}{x-1}\)</span></p>
<p>那么可以反向由 <span class="math inline">\(H(x)\)</span>
构造出我们想要的 <span class="math inline">\(F(x)\)</span> ，从而得到
<span class="math inline">\(G(x)\)</span> ，再进行求解</p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="答案计算">答案计算</h3>
<p><span class="math inline">\(\displaystyle
F(x)=1-\frac{1}{H(x)}=1-\frac{x-1}{x^{k+1}-1}=\frac{x-x^{k+1}}{1-x^{k+1}}\)</span></p>
<p>可以爆算得到 <span class="math inline">\(F(x)\)</span> ，从而得到
<span class="math inline">\(G(x)\)</span> ，然后暴力求逆就是 <span
class="math inline">\(O(n^2)\)</span></p>
<p>优化：</p>
<p><span class="math inline">\(1-x^{k+1}\)</span> 的逆，只包含 <span
class="math inline">\(\frac{n}{k+1}\)</span> 项，所以 <span
class="math inline">\(G(x)\)</span> 只含 <span
class="math inline">\(2\frac{n}{k+1}\)</span> 项</p>
<p>即 <span class="math inline">\(\displaystyle
F(x)=\sum_{d=0}x^{d(k+1)+1}-\sum_{d=1}x^{d(k+1)}\)</span> ， <span
class="math inline">\(G(x)\)</span> 就是除一个阶乘</p>
<p>这样暴力求逆就是 <span class="math inline">\(O(n^2\ln n)\)</span></p>
<p><del>（不是你干嘛要真的求逆，直接进行 <span
class="math inline">\(G(x)\)</span> 的叠加就可以了）</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,P,I[N],J[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span></span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> F[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),P=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,*J=<span class="number">1</span>,n) J[i]=<span class="number">1ll</span>*J[i<span class="number">-1</span>]*i%P;</span><br><span class="line">	I[n]=<span class="built_in">qpow</span>(J[n]);</span><br><span class="line">	<span class="built_in">drep</span>(i,n,<span class="number">1</span>) I[i<span class="number">-1</span>]=<span class="number">1ll</span>*I[i]*i%P;</span><br><span class="line">	<span class="built_in">drep</span>(k,n,<span class="number">1</span>) &#123;</span><br><span class="line">		F[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,n) &#123;</span><br><span class="line">			F[j]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">1</span>;d&lt;=j;d+=k) F[j]=(F[j]+<span class="number">1ll</span>*F[j-d]*I[d])%P;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> d=k;d&lt;=j;d+=k) F[j]=(F[j]<span class="number">-1ll</span>*F[j-d]*I[d])%P;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">int</span>((<span class="number">1ll</span>*(P+<span class="number">1</span>-F[n])*J[n])%P));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8C2019%E4%BA%94%E6%A0%A1%E8%81%94%E8%80%83-%E9%9B%85%E7%A4%BC%E3%80%8D%E5%A4%A7%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91%20/</url>
    <content><![CDATA[<hr />
<p>title: '「2019五校联考-雅礼」大凯的疑惑' date: 'Sat Aug 12 11:05:28
2023 categories: - oi-solutions'</p>
<h1 id="五校联考-雅礼大凯的疑惑">「2019五校联考-雅礼」大凯的疑惑</h1>
<p>首先判断是否有无穷解，即判断 <span
class="math inline">\(\gcd(a,b)&gt;1\)</span> 时有无穷解</p>
<p>接下来我们由小凯的疑惑知道最大的无法表示的数是 <span
class="math inline">\(ab-a-b\)</span> ，这能确定一个上界</p>
<p>考虑计算 <span class="math inline">\([1,R](R&lt;ab)\)</span> 中能用
<span class="math inline">\(a,b\)</span> 表示出来的数</p>
<p>因为 <span class="math inline">\(\gcd(a,b)=1,R&lt;ab\)</span>
，所以每个数最多只有一种构成法，可以枚举其包含了几个 <span
class="math inline">\(b\)</span> ，剩下的部分直接任意放 <span
class="math inline">\(a\)</span></p>
<p>即得到计算能够被构成的个数的方法为 <span
class="math inline">\(\begin{aligned}\sum_{i=0}^{\lfloor
\frac{R}{a}\rfloor} \lfloor \frac{R-ib}{a}\rfloor+1
\end{aligned}\)</span></p>
<p>其中+1是计算了包含0个 <span class="math inline">\(a\)</span>
的情况</p>
<p>如果二分答案，复杂度为 <span class="math inline">\(O(a\log
(ab))\)</span> ，恐怕难以通过</p>
<p>优化：</p>
<p>我的思路是是先确定了 <span class="math inline">\(\lfloor
\frac{R}{a}\rfloor\)</span> ，那么此时确定了所有 <span
class="math inline">\(b\)</span> 的个数的贡献</p>
<p>那么考虑枚举，找到答案所属的 <span class="math inline">\(\lfloor
\frac{R}{a}\rfloor\)</span> 的区间，在这段区间里，判断一个数 <span
class="math inline">\(x\)</span> 是否可以被构成即:</p>
<p><span class="math inline">\(x\equiv ib\pmod a(i\leq \lfloor
\frac{R}{a}\rfloor)\)</span> ，即考虑了不同 <span
class="math inline">\(b\)</span> 的个数的贡献</p>
<p>用一个数组存下 <span class="math inline">\(ib\bmod a\)</span>
，那么可以 <span class="math inline">\(O(1)\)</span>
判断一个数是否合法，如果直接for过去是 <span
class="math inline">\(O(b)\)</span> 的</p>
<p>显然这在一段中，构成情况每 <span class="math inline">\(a\)</span>
个一循环，那么先快速跳循环即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e7</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll a,b,k;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123; <span class="keyword">return</span> b==<span class="number">0</span>?a:<span class="built_in">gcd</span>(b,a%b); &#125;</span><br><span class="line"><span class="type">bool</span> mk[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;math.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),<span class="built_in">freopen</span>(<span class="string">&quot;math.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;a,&amp;b,&amp;k);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">gcd</span>(a,b)!=<span class="number">1</span> || a==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a*b-a-b),<span class="number">0</span>;</span><br><span class="line">	ll s=(a<span class="number">-1</span>)*(b<span class="number">-1</span>)/<span class="number">2</span>,c=<span class="number">0</span>; <span class="comment">// s为总的个数</span></span><br><span class="line">	<span class="keyword">if</span>(s&lt;k) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	k=s-k+<span class="number">1</span>; <span class="comment">// 改为求第k小</span></span><br><span class="line">	<span class="type">int</span> p=mk[<span class="number">0</span>]=<span class="number">1</span>;  <span class="comment">// p为所属区间</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,a<span class="number">-1</span>) &#123;</span><br><span class="line">		c+=i*b/a;</span><br><span class="line">		ll t=i*(b<span class="number">-1</span>)-c; <span class="comment">// t为这段区间内无法被表示的个数</span></span><br><span class="line">		<span class="keyword">if</span>(t&gt;=k)&#123; p=i; <span class="keyword">break</span>; &#125;</span><br><span class="line">		mk[i*b%a]=<span class="number">1</span>;  <span class="comment">// 把区间内的ib mod a 放进去</span></span><br><span class="line">	&#125;</span><br><span class="line">	k-=(p<span class="number">-1</span>)*(b<span class="number">-1</span>)-(c-p*b/a); <span class="comment">//还需要做的个数</span></span><br><span class="line">	ll l=(p<span class="number">-1</span>)*b+<span class="number">1</span>,d=l%a; <span class="comment">//l为区间开始位置</span></span><br><span class="line">	ll i=l+(k<span class="number">-1</span>)/(a-p)*a; <span class="comment">// 每个长度为a的循环中已经有p个位置被标记，可以被表示，因此还有a-p个位置无法表示</span></span><br><span class="line">	k-=(k<span class="number">-1</span>)/(a-p)*(a-p); <span class="comment">// 跳过循环</span></span><br><span class="line">	<span class="keyword">for</span>(;;++i,d++,d==a&amp;&amp;(d=<span class="number">0</span>)) <span class="keyword">if</span>(!mk[d] &amp;&amp; --k==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,i),<span class="number">0</span>; <span class="comment">// 暴力for最后a个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8C2020NOIP%E6%A8%A1%E6%8B%9F%E9%A2%98-%E5%B9%BF%E5%A4%A7%E9%99%84%E4%B8%AD%E3%80%8DC%20/</url>
    <content><![CDATA[<hr />
<p>title: '「2020NOIP模拟题-广大附中」C' date: 'Sat Aug 12 11:05:28 2023
categories: - oi-solutions'</p>
<h1 id="noip模拟题-广大附中c">「2020NOIP模拟题-广大附中」C</h1>
<p>首先分析单对于LIS,LDS简单分析一下性质</p>
<p>不妨把选出的每个数 <span class="math inline">\(i,a_i\)</span>
视为一个二维坐标系上的点，则显然在最优方案中</p>
<p>对于任意相邻的数，以 <span
class="math inline">\((i,a_i),(i+1,a_{i+1})\)</span>
为顶点的矩形中不存在在任何一个未被选择的点</p>
<p>接下来分析选出的两个序列：</p>
<p>推论1：两个方案的位置关系</p>
<p>这两个序列不论是在 <span class="math inline">\(x\)</span> 还是在
<span class="math inline">\(y\)</span> 上都不能被剖成两个分离的段</p>
<p>实际上作出两条描述方案的折线，<strong>它们必然有交点</strong></p>
<p>推论2：交点的性质</p>
<p>只有两种情况，其中一种为</p>
<figure>
<img src="https://i.loli.net/2020/11/19/CU5nRugpPOHXWEk.png"
alt="QQ截图20201119145027.png" />
<figcaption aria-hidden="true">QQ截图20201119145027.png</figcaption>
</figure>
<p>相交的两个相邻折线，构成的矩形一定是这样的</p>
<figure>
<img src="https://i.loli.net/2020/11/19/zboEaZCkXdMq67f.png"
alt="QQ截图20201119145225.png" />
<figcaption aria-hidden="true">QQ截图20201119145225.png</figcaption>
</figure>
<p>即分别在 <span class="math inline">\(x,y\)</span>
上的范围有一个包含另一个</p>
<p>以这个交点为界，两个取出的序列值域独立，只需要找到这样的交叉处即可得到答案</p>
<p>接下来的问题分两步</p>
<h3 id="part1-找到候选折线">Part1 找到候选折线</h3>
<p>对于LIS来说一个点的转移前驱构成一个递减的子序列，显然我们需要找到这个序列中下标最小的</p>
<p>LDS相反</p>
<p>用树状数组即可</p>
<h3 id="part2-判断是否合法">Part2 判断是否合法</h3>
<p>满足两个维度上分别包含看起来像是一个奇怪的二维问题</p>
<p>但是实际上可以现，不管是LIS还是LDS，在查询的矩形中间是不会出现点的</p>
<p>所以可以转化为二维区间前缀问题，用离线树状数组解决</p>
<p>具体的，不妨对于LIS来考虑，设选出的点为 <span
class="math inline">\((x,a_x),(y,a_y)\)</span></p>
<p>设候选的LDS折线为 <span
class="math inline">\((u,a_u),(v,a_v)\)</span></p>
<p>我们需要知道的就是在下标上满足 <span
class="math inline">\(v&lt;y,u&gt;x\)</span></p>
<p>在值上满足 <span
class="math inline">\(a_u&gt;a_y,a_v&lt;a_x\)</span></p>
<p>可以分成4次查询完成，但是实际操作时和这个式子略有不同，见代码</p>
<p>存在两种包含关系，还需要反过来再做一次</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8C2020noip%E6%A8%A1%E6%8B%9F%E9%A2%98-%E8%92%8B%E5%87%8C%E5%AE%87%E3%80%8D%E5%B9%82/</url>
    <content><![CDATA[<hr />
<p>title: '「2020noip模拟题-蒋凌宇」幂' date: 'Sat Aug 12 11:05:28 2023
categories: - oi-solutions'</p>
<h1 id="noip模拟题-蒋凌宇幂">「2020noip模拟题-蒋凌宇」幂</h1>
<h3 id="analysis">Analysis</h3>
<p>计算 <span class="math inline">\(x\)</span>
出现的次数，可以转化为枚举每一个 <span class="math inline">\(x\)</span>
，计算剩余 <span class="math inline">\(n-1\)</span>
个位置合法括号序列个数</p>
<p>因此我们只需要计算合法括号序列个数</p>
<p>定义一个辅助计数：<strong>不可分割</strong> 的合法括号序列</p>
<p>这样的括号序列，满足：其恰好为 <span class="math inline">\(x\)</span>
，或者序列两端是一对匹配的左右括号</p>
<p>而实际要求的括号序列 的就是这样的 <strong>不可分割</strong>括号序列
去掉两端的匹配括号</p>
<p><span class="math display">\[\  \]</span></p>
<h2 id="solution">Solution</h2>
<p>设 <span class="math inline">\(a_n\)</span> 为长度为 <span
class="math inline">\(n\)</span> 的<strong>不可分割</strong>
的合法括号序列数量</p>
<p>括号序列并非排列问题，因此我们用普通生成函数计算</p>
<p>设 <span class="math inline">\(\text{OGF(a)}=A(x)\)</span> ， <span
class="math inline">\(A(x)\)</span> 容易发现 <span
class="math inline">\(A(x)\)</span> 满足下面的递归式</p>
<p><span class="math inline">\(\displaystyle
A(x)=x^2(\sum_{i=0}^{\infty} A^i(x))+x^1\)</span></p>
<p>其中 <span class="math inline">\(x^2\)</span>
表示在外层加一对匹配括号， <span
class="math inline">\(\sum_{i=0}^{\infty} A^i(x)\)</span>
枚举子括号中的分裂段， <span class="math inline">\(x^1\)</span> 表示单个
<span class="math inline">\(x\)</span></p>
<p>容易得到下面的化简过程</p>
<p><span class="math inline">\(\displaystyle
A(x)=\frac{x^2}{1-A(x)}+x\)</span></p>
<p><span class="math inline">\(A(x)-A^2(x)=x^2+xA(x)\)</span></p>
<p><span class="math inline">\(A^2(x)-(x+1)A(x)+x^2+x=0\)</span></p>
<p>带入求根公式，得到 <span class="math inline">\(A(x)\)</span> 的
<strong>收敛形式</strong></p>
<p><span class="math inline">\(\displaystyle
A_1(x)=\frac{x+1+\sqrt{-3x^2-2x+1}}{2},A_2(x)=\frac{x+1-\sqrt{-3x^2-2x+1}}{2}\)</span></p>
<p>令 <span class="math inline">\(\displaystyle
F(x)=-3x^2-2x+1,G(x)=\sqrt{F(x)}\)</span></p>
<p>容易手玩发现： <span class="math inline">\([x^0]G(x)=1\)</span></p>
<p>而根据定义，我们知道 <span class="math inline">\([x^0]A(x)=0\)</span>
，因此 <span class="math inline">\(A(x)=A_2(x)\)</span></p>
<p>接下来我们要求 <span class="math inline">\(\displaystyle
G(x)=F^\frac{1}{2}(x)\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p>下面介绍对于短多项式 <span class="math inline">\(F(x)\)</span> ，设
<span class="math inline">\(\text{deg}(F(x))=m\)</span> ，有理数 <span
class="math inline">\(k(k\ne 1)\)</span></p>
<p>求解 <span class="math inline">\(G(x)=F^k(x)\)</span> 的前 <span
class="math inline">\(n\)</span> 项的 <span
class="math inline">\(O(m^2+nm)\)</span> 递推做法</p>
<h4 id="变形">变形</h4>
<p><span class="math inline">\(G(x)=F^k(x)\)</span></p>
<p><span class="math inline">\(\displaystyle
G&#39;(x)=kF^{k-1}(x)F&#39;(x)\)</span></p>
<p><span
class="math inline">\(G&#39;(x)F(x)=kF^k(x)F&#39;(x)\)</span></p>
<p><span class="math inline">\(G&#39;(x)F(x)=kG(x)F&#39;(x)\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<h4 id="求解递推式">求解递推式</h4>
<p>对于等号两边，考虑 <span class="math inline">\([x^n]\)</span>
一项的系数，容易求出 <span
class="math inline">\(F&#39;(x)=-6x-2\)</span></p>
<p><span class="math inline">\(\displaystyle \sum_{i=0}^m
[x^{n-i}]G&#39;(x)F_i=k\sum_{i=0}^{m-1}[x^{n-i}]G(x)F&#39;_i\)</span></p>
<p><span class="math inline">\(\displaystyle \sum_{i=0}^m
[x^{n-i+1}](n-i+1)G(x)F_i=k\sum_{i=0}^{m-1}[x^{n-i}]G(x)F&#39;_i\)</span></p>
<p><span class="math inline">\(\displaystyle
(n+1)[x^{n+1}]G(x)=k\sum_{i=0}^{m-1}[x^{n-i}]G(x)F&#39;_i-\sum_{i=1}^m
[x^{n-i+1}](n-i+1)G(x)F_i\)</span></p>
<p>带入这题的 <span class="math inline">\(k\)</span> ，得到</p>
<p><span class="math inline">\(\displaystyle
[x^n]=\frac{3(n-3)[x^{n-2}]+(2n-3)[x^{n-1}]}{n}\)</span></p>
<p>递推边界 <span
class="math inline">\([x^0]G(x)=1,[x^1]G(x)=-1\)</span></p>
<p>然后由 <span class="math inline">\(G(x)\)</span> 得到 <span
class="math inline">\(A(x)\)</span> 再得到最终答案即可</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8CCodePlus%202017%2011%20%E6%9C%88%E8%B5%9B%E3%80%8DYazid%20%E7%9A%84%E6%96%B0%E7%94%9F%E8%88%9E%E4%BC%9A%20/</url>
    <content><![CDATA[<hr />
<p>title: '「CodePlus 2017 11 月赛」Yazid 的新生舞会' date: 'Sat Aug 12
11:05:28 2023 categories: - oi-solutions'</p>
<h1 id="codeplus-2017-11-月赛yazid-的新生舞会">「CodePlus 2017 11
月赛」Yazid 的新生舞会</h1>
<p>最基本的分析这里只保留： <span
class="math inline">\(cnt&gt;\frac{len}{2}\Rightarrow
2cnt&gt;len\)</span></p>
<p>对于每一个合法的区间，合法的众数显然只有一个</p>
<p>考虑对于每一个众数计算答案，把 <span class="math inline">\(x\)</span>
出现的位置拿出来成一个序列 <span class="math inline">\(A_i\)</span></p>
<p>如果选择的区间恰好包含 <span class="math inline">\(A_i,A_{i+1},\cdots
,A_j\)</span> ，那么合法的情况就是 <span
class="math inline">\(2(j-i+1)&gt;R-L+1,L\in[A_{i-1}+1,A_i],R\in[A_{j},A_{j},A_{j+1}-1]\)</span></p>
<p>参数分离得到 <span class="math inline">\(2j-R&gt;2i-L\)</span></p>
<p>如果对于每一个 <span class="math inline">\(L\)</span>
更新答案，那么更新的是一段区间，不妨设其为 <span
class="math inline">\(UL,UR\)</span></p>
<p>对于每个 <span class="math inline">\(R\)</span> 查询则是一段前缀 和
的区间</p>
<p>我们知道树状数组维护区间修改区间查询需要做一次差分，而这次是区间前缀和</p>
<p>也就是说是再高一维。。</p>
<p>不妨在 <span class="math inline">\(UL\)</span> 上加, <span
class="math inline">\(UR\)</span> 上减，那么在 <span
class="math inline">\(p\)</span> 处的更新对于在 <span
class="math inline">\(k\)</span> 处的查询的贡献是</p>
<p><span
class="math inline">\(\cfrac{(k-p+1)(k-p+2)}{2}=\cfrac{k^2+p^2-2pk+3k-3p+2}{2}\)</span></p>
<p>那么直接处理这个式子即可，需要维护 <span
class="math inline">\(updval,p\cdot updval,p^2\cdot updval\)</span></p>
<p>查询时加入 <span class="math inline">\(k\)</span> 的贡献</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>; <span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span>(c=<span class="built_in">getchar</span>(),c&lt;<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">do</span> s=s*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span>(c=<span class="built_in">getchar</span>(),c&gt;<span class="number">47</span>);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span>&#123;N=<span class="number">1000010</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; A[N];</span><br><span class="line">ll ans,s1[N],s2[N],s3[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> p,ll x)</span> </span>&#123;</span><br><span class="line">	p--; ll a=x,b=x*p,c=x*p*p;</span><br><span class="line">	<span class="keyword">for</span>(p+=n+<span class="number">1</span>;p&lt;=n*<span class="number">2</span>;p+=p&amp;-p) s1[p]+=a,s2[p]+=b,s3[p]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span> </span>&#123; <span class="built_in">Add</span>(l,x),<span class="built_in">Add</span>(r+<span class="number">1</span>,-x); &#125;</span><br><span class="line"><span class="function">ll <span class="title">Que</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	ll r1=<span class="number">0</span>,r2=<span class="number">0</span>,r3=<span class="number">0</span>,tp=p;</span><br><span class="line">	<span class="keyword">for</span>(p+=n;p;p-=p&amp;-p) r1+=s1[p],r2+=s2[p],r3+=s3[p];</span><br><span class="line">	<span class="keyword">return</span> ((tp*tp+tp)*r1-(<span class="number">2</span>*tp+<span class="number">1</span>)*r2+r3)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Que</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Que</span>(r)-<span class="built_in">Que</span>(l<span class="number">-1</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;party.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),n=<span class="built_in">rd</span>(),<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) A[<span class="built_in">rd</span>()].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="built_in">rep</span>(k,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(A[k].<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,A[k].<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> p=A[k][i],l=i?A[k][i<span class="number">-1</span>]:<span class="number">0</span>,r=i&lt;(<span class="type">int</span>)A[k].<span class="built_in">size</span>()<span class="number">-1</span>?A[k][i+<span class="number">1</span>]:n+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">Add</span>(<span class="number">2</span>*i-p+<span class="number">1</span>,<span class="number">2</span>*i-l,<span class="number">1</span>);</span><br><span class="line">			ans+=<span class="built_in">Que</span>(<span class="number">2</span>*(i+<span class="number">1</span>)-r,<span class="number">2</span>*(i+<span class="number">1</span>)-p<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,A[k].<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> p=A[k][i],l=i?A[k][i<span class="number">-1</span>]:<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">Add</span>(<span class="number">2</span>*i-p+<span class="number">1</span>,<span class="number">2</span>*i-l,<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">fopen</span>(<span class="string">&quot;party.out&quot;</span>,<span class="string">&quot;w&quot;</span>),<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8C2019%20%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BA%92%E6%B5%8B%20Day%201%E3%80%8D%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%20/</url>
    <content><![CDATA[<hr />
<p>title: '「2019 集训队互测 Day 1」最短路径 (点分治+NTT/FFT+线段树)'
date: 'Sat Aug 12 11:05:28 2023 categories: - oi-solutions'</p>
<h1 id="集训队互测-day-1最短路径-点分治nttfft线段树">「2019 集训队互测
Day 1」最短路径 (点分治+NTT/FFT+线段树)</h1>
<p>题意：给定了一棵基环树，求所有的 <span
class="math inline">\(d(u,v)^k\)</span> 的期望</p>
<p>当 <span class="math inline">\(k\)</span>
较小时，可以想到用斯特林数/二项式定理展开
维护+1操作，对于树的可以从儿子合并上来，对于环上可以枚举每个块求得答案</p>
<p>复杂度为 <span class="math inline">\(O(nk)\)</span></p>
<p>当图为一棵树时，由于不好处理 <span class="math inline">\(x^k\)</span>
，考虑直接求出 <span class="math inline">\(d(u,v)=i\)</span> 的数量</p>
<p>比较容易想到用用点分治+ <span
class="math inline">\(\text{NTT}\)</span> 求解，复杂度为 <span
class="math inline">\(O(n\log ^2n)\)</span></p>
<p>环上的情况比较麻烦，不妨为每个块标号 <span
class="math inline">\(1,2,\cdots m\)</span> ，每个块包含 <span
class="math inline">\(sz_i\)</span> 个结点</p>
<p>显然 <span class="math inline">\((i,j)\)</span> 的距离为 <span
class="math inline">\(\min\lbrace|i-j|,m-|i-j|\rbrace\)</span></p>
<p>考虑计算所有块 <span class="math inline">\((i,j)(i&lt;j)\)</span>
之间的贡献，令 <span class="math inline">\(d=\lfloor
\frac{m}{2}\rfloor\)</span> ，则对于 <span
class="math inline">\(j\in[i+1,i+d]\)</span> 在环上的距离为 <span
class="math inline">\(j-i\)</span> ，否则距离为 <span
class="math inline">\(m-(j-i)\)</span></p>
<p>对于两种情况分类讨论，这里以计算 <span
class="math inline">\(j\in[i+1,i+d]\)</span> 为例</p>
<p>因为是一段区间，考虑直接在线段树的 <span
class="math inline">\([i+1,i+d]\)</span> 加入 <span
class="math inline">\(i\)</span> ，然后对于线段树上每个结点计算</p>
<p>推论1：能够被添加到线段树结点 <span
class="math inline">\([l,r]\)</span> 上的 <span
class="math inline">\(i\)</span> 构成一段连续的区间</p>
<p>推论2：从区间 <span class="math inline">\([l,r]\)</span> 的一端出发，
<span class="math inline">\(\text{dfs}\)</span> 区间内的块得到的 <span
class="math inline">\(\max dis_u\leq \sum_{i=l}^r sz_i\)</span></p>
<p>因此同样考虑用 <span class="math inline">\(\text{NTT}\)</span>
维护该答案，每次更新答案可以看做是区间 <span
class="math inline">\([l1,r1],[l2,r2](r1&lt;l2)\)</span> 之间的贡献</p>
<p>分别从 <span class="math inline">\(r1,l2\)</span> 开始 <span
class="math inline">\(\text{dfs}\)</span> 得到 <span
class="math inline">\(dis_u\)</span> ，然后 <span
class="math inline">\(\text{NTT}\)</span> 合并，不把 <span
class="math inline">\([r1+1,l2-1]\)</span> 这一部分在环上的加入 <span
class="math inline">\(\text{NTT}\)</span> 大小</p>
<p>这样就能保证卷积大小 <span class="math inline">\(\leq
\sum_{i=l1}^{r1} sz_i+\sum_{i=l2}^{r2} sz_i\)</span></p>
<p>同理可以类似处理 <span class="math inline">\(j&gt;i+d\)</span>
的情况</p>
<p>分析复杂度：每个 <span class="math inline">\(i\)</span>
会出现在线段树上 <span class="math inline">\(\log n\)</span>
个位置，每个 <span class="math inline">\(j\)</span> 会在线段树上 <span
class="math inline">\(\log n\)</span> 层被计算</p>
<p>因此每个点被加入卷积大小的次数为 <span class="math inline">\(O(\log
n)\)</span> ，复杂度为 <span class="math inline">\(O(n\log ^2
n)\)</span> 与前面的点分治同阶</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Mbe;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">18</span>|<span class="number">10</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> A[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Pow[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> head[N],ecnt,deg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=ecnt,deg[v]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erep(u,i) for(int i=head[u];i;i=e[i].nxt)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> R=<span class="number">1</span>&lt;&lt;<span class="number">18</span>;</span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">qpow</span>(<span class="number">3</span>,(P<span class="number">-1</span>)/R);</span><br><span class="line">	w[R/<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,R/<span class="number">2</span>+<span class="number">1</span>,R<span class="number">-1</span>) w[i]=<span class="number">1ll</span>*w[i<span class="number">-1</span>]*t%P;</span><br><span class="line">	<span class="built_in">drep</span>(i,R/<span class="number">2</span><span class="number">-1</span>,<span class="number">1</span>) w[i]=w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rev[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> e[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=e[<span class="number">0</span>]=<span class="number">1</span>,t;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> *e=w+i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">				t=<span class="number">1ll</span>*a[j+i]*e[j-l]%P;</span><br><span class="line">				a[j+i]=a[j]-t,<span class="built_in">Mod2</span>(a[j+i]);</span><br><span class="line">				a[j]+=t,<span class="built_in">Mod1</span>(a[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">		ll base=<span class="built_in">qpow</span>(n);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=a[i]*base%P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> R=<span class="number">1</span>,c=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(R&lt;=n) R&lt;&lt;=<span class="number">1</span>,c++;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;c);</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Q[N],L,R,vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> pt1&#123; </span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line">	<span class="type">int</span> dis[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) dis[i]=<span class="number">-1</span>;</span><br><span class="line">		dis[Q[L=R=<span class="number">1</span>]=u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(L&lt;=R) &#123;</span><br><span class="line">			u=Q[L++];</span><br><span class="line">			<span class="built_in">erep</span>(u,i)&#123;</span><br><span class="line">				<span class="type">int</span> v=e[i].to;</span><br><span class="line">				<span class="keyword">if</span>(~dis[v]) <span class="keyword">continue</span>;</span><br><span class="line">				dis[v]=dis[u]+<span class="number">1</span>,Q[++R]=v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">2</span>,n) &#123;</span><br><span class="line">			<span class="built_in">Bfs</span>(i);</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) ans=(ans+Pow[dis[j]])%P;</span><br><span class="line">		&#125;</span><br><span class="line">		ans=ans*<span class="built_in">qpow</span>(n*(n<span class="number">-1</span>)/<span class="number">2</span>)%P;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Ans[N],sz[N];</span><br><span class="line"><span class="keyword">namespace</span> pt2&#123; </span><br><span class="line">	<span class="type">int</span> mi=<span class="number">1e9</span>,rt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">FindRt</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> u,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> ma=<span class="number">0</span>; sz[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">erep</span>(u,i) &#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(v==u || v==f || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">FindRt</span>(n,v,u),sz[u]+=sz[v],<span class="built_in">cmax</span>(ma,sz[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cmax</span>(ma,n-sz[u]);</span><br><span class="line">		<span class="keyword">if</span>(mi&gt;ma) mi=ma,rt=u;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> F[N],A[N],B[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 容斥型 点分治</span></span><br><span class="line">		<span class="type">int</span> R=<span class="built_in">Init</span>(n*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,R) F[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n) F[i]=A[i];</span><br><span class="line">		<span class="built_in">NTT</span>(R,F,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) F[i]=<span class="number">1ll</span>*F[i]*F[i]%P;</span><br><span class="line">		<span class="built_in">NTT</span>(R,F,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">1</span>) <span class="built_in">rep</span>(i,<span class="number">0</span>,n*<span class="number">2</span>) Ans[i]+=F[i],<span class="built_in">Mod1</span>(Ans[i]);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">rep</span>(i,<span class="number">0</span>,n*<span class="number">2</span>) Ans[i]-=F[i],<span class="built_in">Mod2</span>(Ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxd;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f,<span class="type">int</span> d=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">		A[d]++,sz[u]=<span class="number">1</span>,<span class="built_in">cmax</span>(maxd,d);</span><br><span class="line">		<span class="built_in">erep</span>(u,i) &#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(v==u || v==f || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u,d+<span class="number">1</span>),sz[u]+=sz[v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Divide</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">		mi=<span class="number">1e9</span>,<span class="built_in">FindRt</span>(n,u,<span class="number">0</span>),u=rt;</span><br><span class="line">		vis[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> D=<span class="number">0</span>;B[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">erep</span>(u,i) &#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">			maxd=<span class="number">0</span>,<span class="built_in">dfs</span>(v,u,<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">Solve</span>(maxd,<span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,maxd) B[j]+=A[j],A[j]=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">cmax</span>(D,maxd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,D) A[i]=B[i],B[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">Solve</span>(D,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,D) A[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">erep</span>(u,i) &#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">Divide</span>(sz[v],v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) vis[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">Divide</span>(n,<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) ans=(ans+<span class="number">1ll</span>*Ans[i]*Pow[i])%P;</span><br><span class="line">		ans=ans*<span class="built_in">qpow</span>(<span class="number">1ll</span>*n*(n<span class="number">-1</span>)%P)%P;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> QL[N&lt;&lt;<span class="number">2</span>],QR[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在线段树上加入结点</span></span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!QL[p]) QL[p]=x;</span><br><span class="line">		QR[p]=x;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) <span class="built_in">Add</span>(p&lt;&lt;<span class="number">1</span>,l,mid,ql,qr,x);</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;mid) <span class="built_in">Add</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,ql,qr,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> typ;</span><br><span class="line"><span class="type">int</span> X[N],Y[N],D;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> *C,<span class="type">int</span> u,<span class="type">int</span> f,<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cmax</span>(D,d),C[d]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt) &#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v==f || vis[v])  <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(C,v,u,d+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mark</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> l=A[i==<span class="number">1</span>?m:i<span class="number">-1</span>],r=A[i==m?<span class="number">1</span>:i+<span class="number">1</span>];</span><br><span class="line">	vis[l]=vis[r]=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(QL[p]) &#123;</span><br><span class="line">        <span class="comment">// 计算区间QL,QR到l,r的贡献</span></span><br><span class="line">		<span class="keyword">if</span>(typ==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> qr=QR[p];</span><br><span class="line">			<span class="built_in">rep</span>(x,QL[p],QR[p]) <span class="built_in">Mark</span>(x,<span class="number">1</span>),<span class="built_in">dfs</span>(X,A[x],<span class="number">0</span>,qr-x),<span class="built_in">Mark</span>(x,<span class="number">0</span>);</span><br><span class="line">			<span class="type">int</span> T=D; D=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">rep</span>(x,l,r) <span class="built_in">Mark</span>(x,<span class="number">1</span>),<span class="built_in">dfs</span>(Y,A[x],<span class="number">0</span>,x-l),<span class="built_in">Mark</span>(x,<span class="number">0</span>);</span><br><span class="line">			<span class="type">int</span> R=<span class="built_in">Init</span>(T+D+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">NTT</span>(R,X,<span class="number">1</span>),<span class="built_in">NTT</span>(R,Y,<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) X[i]=<span class="number">1ll</span>*X[i]*Y[i]%P;</span><br><span class="line">			<span class="built_in">NTT</span>(R,X,<span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,T+D) Ans[i+l-qr]+=X[i],<span class="built_in">Mod1</span>(Ans[i+l-qr]);</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,R) X[i]=Y[i]=<span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> ql=QL[p];</span><br><span class="line">			<span class="built_in">rep</span>(x,QL[p],QR[p]) <span class="built_in">Mark</span>(x,<span class="number">1</span>),<span class="built_in">dfs</span>(X,A[x],<span class="number">0</span>,x-ql),<span class="built_in">Mark</span>(x,<span class="number">0</span>); </span><br><span class="line">			<span class="type">int</span> T=D; D=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">rep</span>(x,l,r) <span class="built_in">Mark</span>(x,<span class="number">1</span>),<span class="built_in">dfs</span>(Y,A[x],<span class="number">0</span>,r-x),<span class="built_in">Mark</span>(x,<span class="number">0</span>);</span><br><span class="line">			<span class="type">int</span> R=<span class="built_in">Init</span>(T+D+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">NTT</span>(R,X,<span class="number">1</span>),<span class="built_in">NTT</span>(R,Y,<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) X[i]=<span class="number">1ll</span>*X[i]*Y[i]%P;</span><br><span class="line">			<span class="built_in">NTT</span>(R,X,<span class="number">-1</span>);</span><br><span class="line">			<span class="type">int</span> d=ql+m-r;</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,T+D) Ans[i+d]+=X[i],<span class="built_in">Mod1</span>(Ans[i+d]);</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,R) X[i]=Y[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		QL[p]=QR[p]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Get</span>(p&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">Get</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;path.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),<span class="built_in">freopen</span>(<span class="string">&quot;path.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) Pow[i]=<span class="built_in">qpow</span>(i,k);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">AddEdge</span>(u,v),<span class="built_in">AddEdge</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1000</span>) <span class="keyword">return</span> pt1::<span class="built_in">Solve</span>(),<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">Init</span>(),L=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 拓扑求环</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(deg[i]==<span class="number">1</span>) sz[Q[++R]=i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(L&lt;=R) &#123;</span><br><span class="line">		<span class="type">int</span> u=Q[L++]; vis[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(deg[v]&lt;=<span class="number">1</span>) sz[u]+=sz[v];</span><br><span class="line">			<span class="keyword">if</span>(--deg[v]==<span class="number">1</span>) Q[++R]=v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;++u) <span class="keyword">if</span>(!vis[u]) &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			vis[u]=<span class="number">1</span>,A[++m]=u;</span><br><span class="line">			<span class="type">int</span> nxt=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt) &#123;</span><br><span class="line">				<span class="type">int</span> v=e[i].to;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v]) nxt=v;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(nxt==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">			u=nxt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">1</span>) <span class="keyword">return</span> pt2::<span class="built_in">Solve</span>(),<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Circle Length =%d\n&quot;</span>,m);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) vis[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	k=m/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="built_in">Mark</span>(i,<span class="number">1</span>);</span><br><span class="line">		pt2::<span class="built_in">Divide</span>(sz[A[i]],A[i]);</span><br><span class="line">		<span class="built_in">Mark</span>(i,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) Ans[i]=<span class="number">1ll</span>*Ans[i]*(P+<span class="number">1</span>)/<span class="number">2</span>%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) vis[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) <span class="built_in">Add</span>(<span class="number">1</span>,<span class="number">1</span>,m,i+<span class="number">1</span>,<span class="built_in">min</span>(i+k,m),i);</span><br><span class="line">	typ=<span class="number">0</span>,<span class="built_in">Get</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m-k<span class="number">-1</span>) <span class="built_in">Add</span>(<span class="number">1</span>,<span class="number">1</span>,m,i+k+<span class="number">1</span>,m,i);</span><br><span class="line">	typ=<span class="number">1</span>,<span class="built_in">Get</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) ans=(ans+<span class="number">1ll</span>*Ans[i]*Pow[i])%P;</span><br><span class="line">	ans=ans*<span class="built_in">qpow</span>(<span class="number">1ll</span>*n*(n<span class="number">-1</span>)/<span class="number">2</span>%P)%P;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8C517%E6%A8%A1%E6%8B%9F%E8%B5%9B1%E3%80%8DABC%E9%9A%BE%E9%A2%98/</url>
    <content><![CDATA[<hr />
<p>title: '「517模拟赛1」ABC难题' date: 'Sat Aug 12 11:05:28 2023
categories: - oi-solutions'</p>
<h1 id="模拟赛1abc难题">「517模拟赛1」ABC难题</h1>
<p>Tips: 模数是 <span class="math inline">\(10^8+7\)</span></p>
<p>不妨令序列总长为 <span class="math inline">\(n\)</span> ，包含 <span
class="math inline">\(m\)</span> 种不同的数字</p>
<p>发现存在 <span class="math inline">\(ABC\)</span>
的子序列只需要满足最左边的 <span class="math inline">\(A\)</span>
和最右边的 <span class="math inline">\(C\)</span> 之间有一个 <span
class="math inline">\(B\)</span></p>
<p>由于可能出现多个 <span class="math inline">\(ABC\)</span>
，考虑计算不存在 <span class="math inline">\(ABC\)</span> 的情况</p>
<p>那么可以枚举最左边的 <span class="math inline">\(A\)</span>
和最右边的 <span class="math inline">\(C\)</span> 分别为 <span
class="math inline">\(X,Y\)</span> ，那么需要不存在 <span
class="math inline">\(ABC\)</span> ，并且枚举的 <span
class="math inline">\(X,Y\)</span> 合法 的充要条件是</p>
<p><span class="math inline">\([1,X-1]\)</span> 中不存在 <span
class="math inline">\(A\)</span> ， <span
class="math inline">\([X+1,Y-1]\)</span> 中不存在 <span
class="math inline">\(B\)</span> ， <span
class="math inline">\([Y+1,n]\)</span> 中不存在 <span
class="math inline">\(C\)</span></p>
<p>这三个限制，每一个限制会让一种颜色能够选择的字母数量-1</p>
<p>那么枚举 <span class="math inline">\(X\)</span> ，扫描每一个 <span
class="math inline">\(Y\)</span> (注意不一定满足 <span
class="math inline">\(X&lt; Y\)</span> )，同时记录每个数字是否出现在
<span class="math inline">\([1,X-1],[X+1,Y-1],[Y+1,n]\)</span> 中</p>
<p>在每次扫描时改变限制，同步统计出受到 <span
class="math inline">\(0,1,2,3\)</span> 个限制的数字的个数，然后答案就是
<span class="math inline">\((3-i)^k\)</span> 之积</p>
<p>然而这样还不够，因为可能根本不存在 <span
class="math inline">\(A,C\)</span> ，不存在 <span
class="math inline">\(A\)</span> 或者 <span
class="math inline">\(C\)</span> 的答案为 <span
class="math inline">\(2^m\)</span> ，同时不存在 <span
class="math inline">\(A,C\)</span> 的答案为 <span
class="math inline">\(1^m\)</span> ，容斥一下即可</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8CEZEC-7%E3%80%8D%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<hr />
<p>title: 'Luogu P7445「EZEC-7」线段树' date: 'Sat Aug 12 11:05:28 2023
categories: - oi-solutions'</p>
<h1 id="luogu-p7445ezec-7线段树">Luogu P7445「EZEC-7」线段树</h1>
<p>显然一个点是否被 <span
class="math inline">\(\text{push_down}\)</span>
仅取决于所有完全包含它的操作区间权值之和</p>
<p>那么可以考虑对于每个节点计算概率，然后累加</p>
<p>反向计算一个节点不被 <span
class="math inline">\(\text{push_down}\)</span> 的概率，即权值之和为
<span class="math inline">\(0\)</span> 的概率</p>
<p>而每个节点有自己被覆盖的概率，即 <span
class="math inline">\(p_i=\cfrac{l\cdot (n-r+1)}{n(n+1)/2}\)</span></p>
<p>而覆盖的次数 <span class="math inline">\(c\)</span>
决定了这个概率贡献的权值，即 <span
class="math inline">\(p_i^c(1-p_i)^{m-c}\)</span></p>
<p>由此得到一个思路：</p>
<p>先通过计算得到 <span class="math inline">\(k\)</span>
次覆盖权值为0的函数 <span class="math inline">\(A(x)\)</span></p>
<p>容易发现这样得到每个点的概率为： <span
class="math inline">\(A(\cfrac{p_i}{1-p_i})(1-p_i)^m\)</span></p>
<p>Naive地带入多点求值，就能暴力得到</p>
<p><br></p>
<p><br></p>
<h3 id="计算-k-次被覆盖权值和为0的方案数">计算 <span
class="math inline">\(k\)</span> 次被覆盖权值和为0的方案数</h3>
<p>容易发现就是</p>
<p><span class="math inline">\(\displaystyle [x^0](\sum_{i=-1}^V
x^i)^k=[x^0](x^{-1}\frac{1-x^{V+2}}{1-x})^k\)</span></p>
<p>暴力展开这个式子会需要对于 <span
class="math inline">\((x^{V+2}-1)^k\)</span> 有用的项只有 <span
class="math inline">\(\frac{k}{V+2}\)</span> 项</p>
<p>即原式 <span class="math inline">\(\displaystyle
=[x^k](\frac{1-x^{V+2}}{1-x})^k=\sum_{i=0}^{k}\binom{2k-i-1}{k-1}[x^i](1-x^{V+2})^k\)</span></p>
<p><span class="math inline">\(\displaystyle =\sum_{i=0}^{\frac{k}{V+2}}
\binom{2k-i(V+2)-1)}{k-1} (-1)^i \binom{k}{i}\)</span></p>
<p>(第一个组合数是组合意义插板，第二个是二项展开)</p>
<p>求 <span class="math inline">\(k\)</span> 的权值需要 <span
class="math inline">\(O(\frac{k}{V})\)</span> ，并不好直接卷积优化</p>
<p><br></p>
<p><br></p>
<p>由于涉及了类似 <span class="math inline">\([x^n]G^k(x)\)</span>
的形式，考虑用 "另类拉格朗日反演" 求解</p>
<p><a
href="https://www.cnblogs.com/chasedeath/p/14421599.html">如果想参考一下，但是EI的课件我是真的看不懂</a></p>
<p>处理一下 <span class="math inline">\(x\)</span> 的负指数，设 <span
class="math inline">\(\displaystyle F(x)=\sum _{i=0}^{V+1}x^i\)</span>
，转化为 <span
class="math inline">\([x^0](\frac{F(x)}{x})^k\)</span></p>
<p>然而不管是 <span class="math inline">\(F(x)\)</span> 还是 <span
class="math inline">\(\frac{F(x)}{x}\)</span> 都不存在复合逆，但是 <span
class="math inline">\(\frac{x}{F(x)}\)</span> 有</p>
<p>设 <span class="math inline">\(G(x)\)</span> 为 <span
class="math inline">\(\frac{x}{F(x)}\)</span> 的复合逆</p>
<p><span class="math inline">\(\displaystyle
[x^0](\frac{F(x)}{x})^k=[x^0](\frac{x}{F(x)})^{-k}=[x^{k}]\frac{xG&#39;(x)}{G(x)}\)</span></p>
<p>求解 <span class="math inline">\(G(x)\)</span> 即可得到所有 <span
class="math inline">\(k\)</span> 的值</p>
<p><span class="math inline">\(G(x)\)</span> 为 <span
class="math inline">\(\cfrac{x}{F(x)}=\cfrac{x
(x-1)}{x^{V+2}-1}\)</span> 的复合逆</p>
<p>即满足 <span
class="math inline">\(\cfrac{G(G-1)}{G^{V+2}-1}=x\)</span></p>
<p><span class="math inline">\(xG^{V+2}-G^2+G-x=0\)</span></p>
<p>这个形式还是比较易于进行牛顿迭代的</p>
<p><span class="math inline">\(f(z)=xz^{V+2}-z^2+z-x\)</span></p>
<p><span class="math inline">\(f&#39;(z)=(V+2)xz^{V+1}-2z+1\)</span></p>
<p><span class="math inline">\(\displaystyle
A=B-\frac{f(B)}{f&#39;(B)}=B-\frac{xB^{V+2}-B^2+B-x}{(V+2)xB^{V+1}-2B+1}\)</span></p>
<p>边界条件为 <span class="math inline">\([x^0]G(x)=0\)</span> ， <span
class="math inline">\([x^1]G(x)=1\)</span></p>
<p><del>结果牛顿迭代需要多项式快速幂</del></p>
<p><br></p>
<p><br></p>
<h3 id="有关多点求值的优化">有关多点求值的优化</h3>
<p>由于我们并不需要知道每个点被操作的概率，只需要一个求和，因此可以对于每一项求出</p>
<p>设 <span
class="math inline">\(a_i=\cfrac{p_i}{1-p_i},b_i=(1-p_i)^m\)</span>
，容易发现实际上求出的式子是</p>
<p><span class="math inline">\(A(\cfrac{p_i}{1-p_i})(1-p_i)^m=\sum
A_j\sum_i a_i^j b_i\)</span></p>
<p>对于每个 <span class="math inline">\(j\)</span> 求解，就是</p>
<p><span class="math inline">\(\displaystyle [x^j]\sum _i
\frac{b_i}{1-a_ix}\)</span></p>
<p>可以分治 <span class="math inline">\(\text{NTT}\)</span>
通分，也就是写成下式</p>
<p><span class="math inline">\(\displaystyle \frac{1}{\prod (1-a_ix)}
\sum b_i \prod_{i!=j} (1-a_jx)\)</span></p>
<p>右边就是一个经典的分治 <span
class="math inline">\(\text{NTT}\)</span> 问题，再加上一次求逆即可</p>
<p><del>好像也不一定快吧</del></p>
<p><br></p>
<p><br></p>
<p>接下来就是套板板时间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">19</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector &lt;<span class="type">int</span>&gt; V;</span><br><span class="line"><span class="type">int</span> rev[N],w[N];</span><br><span class="line"><span class="type">int</span> Inv[N+<span class="number">1</span>],I[N+<span class="number">1</span>],J[N+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init_w</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> N=<span class="number">1</span>; <span class="keyword">while</span>(N&lt;=<span class="built_in">max</span>(n,m+<span class="number">1</span>)*<span class="number">2</span>+<span class="number">4</span>) N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">qpow</span>(<span class="number">3</span>,(P<span class="number">-1</span>)/N);</span><br><span class="line">	w[N/<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,N/<span class="number">2</span>+<span class="number">1</span>,N<span class="number">-1</span>) w[i]=<span class="number">1ll</span>*w[i<span class="number">-1</span>]*t%P;</span><br><span class="line">	<span class="built_in">drep</span>(i,N/<span class="number">2</span><span class="number">-1</span>,<span class="number">1</span>) w[i]=w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	Inv[<span class="number">0</span>]=Inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,N) Inv[i]=<span class="number">1ll</span>*(P-P/i)*Inv[P%i]%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,*I=*J=<span class="number">1</span>,N) &#123;</span><br><span class="line">		I[i]=<span class="number">1ll</span>*I[i<span class="number">-1</span>]*Inv[i]%P;</span><br><span class="line">		J[i]=<span class="number">1ll</span>*J[i<span class="number">-1</span>]*i%P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> R=<span class="number">1</span>,c=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(R&lt;=n) R&lt;&lt;=<span class="number">1</span>,c++;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,R<span class="number">-1</span>) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;c);</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">被隐藏的部分:!!</span></span><br><span class="line"><span class="comment">NTT</span></span><br><span class="line"><span class="comment">operator *</span></span><br><span class="line"><span class="comment">operator +</span></span><br><span class="line"><span class="comment">operator -</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">V <span class="keyword">operator</span> ~ (V a) &#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> V&#123;(<span class="type">int</span>)<span class="built_in">qpow</span>(a[<span class="number">0</span>],P<span class="number">-2</span>)&#125;;</span><br><span class="line">	V b=a; b.<span class="built_in">resize</span>((n+<span class="number">1</span>)/<span class="number">2</span>); b=~b;</span><br><span class="line">	<span class="type">int</span> R=<span class="built_in">Init</span>(n*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">1</span>),<span class="built_in">NTT</span>(R,b,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) a[i]=(<span class="number">2</span><span class="number">-1ll</span>*a[i]*b[i]%P+P)*b[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">-1</span>),a.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exp_Solve</span><span class="params">(V &amp;A,V &amp;B,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> X[N],Y[N];</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		B[l]=<span class="number">1ll</span>*B[l]*Inv[l]%P;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Exp_Solve</span>(A,B,l,mid);</span><br><span class="line">	<span class="type">int</span> R=<span class="built_in">Init</span>(r-l+<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R) X[i]=Y[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,l,mid) X[i-l]=B[i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,r-l<span class="number">-1</span>) Y[i+<span class="number">1</span>]=A[i];</span><br><span class="line">	<span class="built_in">NTT</span>(R,X,<span class="number">1</span>),<span class="built_in">NTT</span>(R,Y,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) X[i]=<span class="number">1ll</span>*X[i]*Y[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,X,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,mid+<span class="number">1</span>,r) B[i]+=X[i-l],<span class="built_in">Mod1</span>(B[i]);</span><br><span class="line">	<span class="built_in">Exp_Solve</span>(A,B,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">Deri</span><span class="params">(V a)</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,a.<span class="built_in">size</span>()<span class="number">-1</span>) a[i<span class="number">-1</span>]=<span class="number">1ll</span>*i*a[i]%P;</span><br><span class="line">	a.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">Integ</span><span class="params">(V a)</span> </span>&#123;</span><br><span class="line">	a.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">drep</span>(i,a.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>) a[i]=<span class="number">1ll</span>*a[i<span class="number">-1</span>]*Inv[i]%P;</span><br><span class="line">	<span class="keyword">return</span> a[<span class="number">0</span>]=<span class="number">0</span>,a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V <span class="keyword">operator</span> &lt;&lt; (V A,<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(A.<span class="built_in">size</span>()+x);</span><br><span class="line">	<span class="built_in">drep</span>(i,A.<span class="built_in">size</span>()<span class="number">-1</span>,x) A[i]=A[i-x];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,x<span class="number">-1</span>) A[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> &gt;&gt; (V A,<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,x,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i-x]=A[i];</span><br><span class="line">	A.<span class="built_in">resize</span>(A.<span class="built_in">size</span>()-x);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">Ln</span><span class="params">(V a)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">	a=<span class="built_in">Deri</span>(a)*~a,a.<span class="built_in">resize</span>(n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Integ</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">Exp</span><span class="params">(V F)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=F.<span class="built_in">size</span>(); F=<span class="built_in">Deri</span>(F);</span><br><span class="line">	<span class="function">V <span class="title">A</span><span class="params">(n)</span></span>; A[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Exp_Solve</span>(F,A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">Pow</span><span class="params">(V x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> d=<span class="number">0</span>,n=x.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">while</span>(d&lt;n &amp;&amp; !x[d]) d++;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1ll</span>*d*k&gt;=n)&#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,x.<span class="built_in">size</span>()<span class="number">-1</span>) x[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	x=x&gt;&gt;d,x.<span class="built_in">resize</span>(n),x=<span class="built_in">Ln</span>(x);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) x[i]=<span class="number">1ll</span>*x[i]*k%P;</span><br><span class="line">	x=<span class="built_in">Exp</span>(x)&lt;&lt;(d*k),x.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">Evaluate</span><span class="params">(V F,V X)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> ls[N&lt;&lt;<span class="number">1</span>],rs[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line">	<span class="type">static</span> V T[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	<span class="type">static</span> <span class="keyword">auto</span> TMul=[&amp;] (V F,V G)&#123;</span><br><span class="line">		<span class="type">int</span> n=F.<span class="built_in">size</span>(),m=G.<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">reverse</span>(G.<span class="built_in">begin</span>(),G.<span class="built_in">end</span>());</span><br><span class="line">		<span class="type">int</span> R=<span class="built_in">Init</span>(n);</span><br><span class="line">		<span class="built_in">NTT</span>(R,F,<span class="number">1</span>),<span class="built_in">NTT</span>(R,G,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) F[i]=<span class="number">1ll</span>*F[i]*G[i]%P;</span><br><span class="line">		<span class="built_in">NTT</span>(R,F,<span class="number">-1</span>); <span class="function">V <span class="title">T</span><span class="params">(n-m+<span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n-m) T[i]=F[i+m<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">static</span> function &lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; Build=[&amp;](<span class="type">int</span> l,<span class="type">int</span> r) &#123;</span><br><span class="line">		<span class="type">int</span> u=++cnt; ls[u]=rs[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">			T[u]=V&#123;<span class="number">1</span>,P-X[l]&#125;;</span><br><span class="line">			<span class="keyword">return</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		ls[u]=<span class="built_in">Build</span>(l,mid),rs[u]=<span class="built_in">Build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">		T[u]=T[ls[u]]*T[rs[u]];</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> n=F.<span class="built_in">size</span>(),m=X.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">cmax</span>(n,m),F.<span class="built_in">resize</span>(n),X.<span class="built_in">resize</span>(n);</span><br><span class="line">	cnt=<span class="number">0</span>,<span class="built_in">Build</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	F.<span class="built_in">resize</span>(n*<span class="number">2</span>+<span class="number">1</span>),T[<span class="number">1</span>]=<span class="built_in">TMul</span>(F,~T[<span class="number">1</span>]);</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,cnt) <span class="keyword">if</span>(ls[i]) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(T[ls[i]],T[rs[i]]);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> R=<span class="built_in">Init</span>(T[i].<span class="built_in">size</span>()),n=T[i].<span class="built_in">size</span>(),m1=T[ls[i]].<span class="built_in">size</span>(),m2=T[rs[i]].<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">NTT</span>(R,T[i],<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">reverse</span>(T[ls[i]].<span class="built_in">begin</span>(),T[ls[i]].<span class="built_in">end</span>()); <span class="built_in">reverse</span>(T[rs[i]].<span class="built_in">begin</span>(),T[rs[i]].<span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">NTT</span>(R,T[ls[i]],<span class="number">1</span>); <span class="built_in">NTT</span>(R,T[rs[i]],<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,R<span class="number">-1</span>) &#123;</span><br><span class="line">			T[ls[i]][j]=<span class="number">1ll</span>*T[ls[i]][j]*T[i][j]%P;</span><br><span class="line">			T[rs[i]][j]=<span class="number">1ll</span>*T[rs[i]][j]*T[i][j]%P;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">NTT</span>(R,T[ls[i]],<span class="number">-1</span>); <span class="built_in">NTT</span>(R,T[rs[i]],<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,n-m1) T[ls[i]][j]=T[ls[i]][j+m1<span class="number">-1</span>];</span><br><span class="line">		T[ls[i]].<span class="built_in">resize</span>(n-m1+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,n-m2) T[rs[i]][j]=T[rs[i]][j+m2<span class="number">-1</span>];</span><br><span class="line">		T[rs[i]].<span class="built_in">resize</span>(n-m2+<span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">	&#125; <span class="keyword">else</span> X[p++]=T[i][<span class="number">0</span>];</span><br><span class="line">	X.<span class="built_in">resize</span>(m);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V <span class="keyword">operator</span> * (V A,<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="number">1ll</span>*A[i]*x%P;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">Newton</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> V&#123;<span class="number">0</span>,<span class="number">1</span>&#125;; </span><br><span class="line">	V G=<span class="built_in">Newton</span>((n+<span class="number">1</span>)/<span class="number">2</span>); G.<span class="built_in">resize</span>(n);</span><br><span class="line">	V T=<span class="built_in">Pow</span>(G,k+<span class="number">1</span>);</span><br><span class="line">	V A=((G*T)&lt;&lt;<span class="number">1</span>)-G*G+G-V&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,B=(T&lt;&lt;<span class="number">1</span>)*(k+<span class="number">2</span>)-G*<span class="number">2</span>+V&#123;<span class="number">1</span>&#125;;</span><br><span class="line">	A.<span class="built_in">resize</span>(n+<span class="number">1</span>),B.<span class="built_in">resize</span>(n+<span class="number">1</span>),A=A*~B,A.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> G-A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V X,Y;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> prob=<span class="number">1ll</span>*l*(n-r+<span class="number">1</span>)%P*Inv[n]%P*Inv[n+<span class="number">1</span>]%P*<span class="number">2</span>%P;</span><br><span class="line">	Y.<span class="built_in">pb</span>(P+<span class="number">1</span>-prob);</span><br><span class="line">	X.<span class="built_in">pb</span>(prob*<span class="built_in">qpow</span>(P+<span class="number">1</span>-prob)%P);</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Build</span>(l,mid),<span class="built_in">Build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>(),<span class="built_in">Init_w</span>();</span><br><span class="line">	V F=<span class="built_in">Newton</span>(m+<span class="number">1</span>); </span><br><span class="line">	F=<span class="built_in">Deri</span>(F)*~(F&gt;&gt;<span class="number">1</span>),F.<span class="built_in">resize</span>(m+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> t=<span class="number">1</span>,inv=<span class="built_in">qpow</span>(k+<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,m) &#123;</span><br><span class="line">		F[i]=<span class="number">1ll</span>*F[i]*t%P*J[m]%P*I[i]%P*I[m-i]%P;</span><br><span class="line">		t=<span class="number">1ll</span>*t*inv%P;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Build</span>(<span class="number">1</span>,n);</span><br><span class="line">	X=<span class="built_in">Evaluate</span>(F,X);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,X.<span class="built_in">size</span>()<span class="number">-1</span>) ans=(ans+P+<span class="number">1</span>-X[i]*<span class="built_in">qpow</span>(Y[i],m))%P;</span><br><span class="line">	<span class="built_in">Mod2</span>(ans),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(\displaystyle
F(x,z)=\frac{1}{\displaystyle 1-z\sum_{i=-1}^{V} x^i}\)</span></p>
<p>我们希望知道 <span class="math inline">\([x^0]F(x,z)\)</span>
，然后根据 <span class="math inline">\([z^k]\)</span> 就能得到 <span
class="math inline">\(k\)</span> 次操作权值和为 <span
class="math inline">\(0\)</span> 的方案数</p>
<p>考虑拉格朗日反演解二元函数</p>
<p>设 <span class="math inline">\(\displaystyle G(z)=z \sum_{i=-1}^V
x^i\)</span> ，转化为求 <span class="math inline">\(\displaystyle
[z^1]\frac{z}{1-G(z)}\)</span></p>
<p>设 <span class="math inline">\(H(z)\)</span> 为 <span
class="math inline">\(G(z)\)</span> 的复合逆，带入扩展拉格朗日反演</p>
<p><span class="math inline">\(\displaystyle
[z^1]\frac{z}{1-G(z)}=[z^0]\frac{1}{(1-z)^2}\frac{z}{H(z)}\)</span></p>
<p><span class="math inline">\(H(z)\)</span> 满足 <span
class="math inline">\(=z\)</span></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8CFJWC2020Day5-zzq%E3%80%8Dlg/</url>
    <content><![CDATA[<hr />
<p>title: '「FJWC2020Day5-zzq」lg' date: 'Sat Aug 12 11:05:28 2023
categories: - oi-solutions'</p>
<h1 id="fjwc2020day5-zzqlg">「FJWC2020Day5-zzq」lg</h1>
<p>设模数为 <span class="math inline">\(P\)</span></p>
<p>考虑对于每一个 <span class="math inline">\(\gcd\)</span> 计算 <span
class="math inline">\(\text{lcm}\)</span> 之积 <span
class="math inline">\(F(m)\)</span></p>
<p>那么可以想到强制每个数都是 <span class="math inline">\(\gcd\)</span>
的倍数，问题转化为求 <span class="math inline">\(\lfloor
\frac{m}{gcd}\rfloor\)</span> 以内所有 <span
class="math inline">\(\text{lcm}\)</span> 的积 <span
class="math inline">\(G(m)\)</span></p>
<p>那么对于每个质因数依次考虑,则得到一个简单的式子</p>
<p><span class="math display">\[G(m)=\begin{aligned}\prod
p_i^{\sum_{j=1}m^n-(m-\lfloor \frac{m}{p_i^j}\rfloor )^n}
\end{aligned}\]</span></p>
<p>其中枚举的 <span class="math inline">\(j\)</span> 是 <span
class="math inline">\(p_i\)</span> 至少出现 <span
class="math inline">\(j\)</span> 次的方案数，枚举的 <span
class="math inline">\(j\)</span> 是 <span class="math inline">\(\log
m\)</span> 级别的</p>
<p>肯定是先求出指数 <span class="math inline">\(\mod \varphi(P)\)</span>
，可以线性预处理出所有的 <span class="math inline">\(i^n \mod
\varphi(P)\)</span></p>
<p>对于每个 <span class="math inline">\(p_i\)</span>
求出指数后还要快速幂，复杂度就是 <span class="math inline">\(O(|p_i|\log
P)=O(m)\)</span> ，实际带有一些常数</p>
<p>那么求 <span class="math inline">\(G(m)\)</span> 的复杂度上界是 <span
class="math inline">\(O(m\log m)\)</span> ，实际上 <span
class="math inline">\(\lfloor \frac{m}{i}\rfloor\)</span>
有很多重复，复杂度要低很多</p>
<p>得到的每个 <span class="math inline">\(\gcd\)</span>
的答案还要把强制取出的 <span class="math inline">\(\gcd\)</span>
补上，是 $^</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8CGDOI2020%E6%A8%A1%E6%8B%9F%E8%B5%9Bday1%E3%80%8DPermutation%20/</url>
    <content><![CDATA[<hr />
<p>title: '「GDOI2020模拟赛day1」Permutation' date: 'Sat Aug 12 11:05:28
2023 categories: - oi-solutions'</p>
<h1
id="gdoi2020模拟赛day1permutation">「GDOI2020模拟赛day1」Permutation</h1>
<p>为了便于叙述，设原题中的 <span class="math inline">\(n\)</span> 为
<span class="math inline">\(N\)</span></p>
<h3 id="题目分析">题目分析</h3>
<p>要求一个 <span class="math inline">\(1-n\)</span>
的环排列，看成是一个环遍历</p>
<p>发现每条边的权值限制了遍历过程中穿过这条边的次数</p>
<p>取 <span class="math inline">\(1\)</span> 为根，强制从 <span
class="math inline">\(1\)</span>
开始遍历，考虑以一个个<strong>自由段</strong>（即未确定前后连接关系的子段）的形式维护
<span class="math inline">\(u\)</span> 子树中的序列段</p>
<p>那么，只需要满足 <span class="math inline">\(u\)</span>
子树中自由段的个数为 <span
class="math inline">\(\frac{w(u,fa_u)}{2}\)</span>
（每一个自由段的两端均对应一次跨越）即可</p>
<p>分析即可发现 <span class="math inline">\(w(u,fa_u)\)</span> 显然是
<span class="math inline">\(O(size_u)\)</span>
级别的，因此考虑树形背包</p>
<p>那么我们就需要支持合并两组自由段</p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="on3-n2log-n"><span class="math inline">\(O(N^3-N^2\log
N)\)</span></h3>
<p>设当前 <span class="math inline">\(1\ldots n\)</span>
个自由端，合并上 <span class="math inline">\(m\)</span>
个自由段(从子树合并上来是恰好 <span class="math inline">\(m\)</span>
个)</p>
<p>注意这些自由段之间是无序的</p>
<p>先考虑一个简单的模型：</p>
<p>把 <span class="math inline">\(n\)</span> 个无序自由段拼接成 <span
class="math inline">\(m\)</span> 个无序自由段，设方案数为 <span
class="math inline">\(W(n,m)\)</span> ，则考虑</p>
<p>先把 <span class="math inline">\(n\)</span> 个自由段排列，然后选出
<span class="math inline">\(n-m\)</span> 个间隔连接，然后除掉得到的
<span class="math inline">\(m\)</span> 个段之间的排列</p>
<p>得到 <span class="math inline">\(\begin{aligned}
W(n,m)=\frac{n!}{m!}\binom{n-1}{n-m} \end{aligned}\)</span></p>
<p>类似的，可以把 <span class="math inline">\(n+m\)</span>
个自由段排成一排，合并成若干段</p>
<p>但是显然存在的问题就是：可能在两组自由段之间形成了连接，这样的连接是非法的</p>
<p>因此考虑容斥</p>
<p><span class="math inline">\(\begin{aligned}
dp&#39;_{d}\longleftarrow\sum_{i=1}^ndp_{u,i}\sum_{j=1}^idp_v
(-1)^{i-j}W(i,j) \sum_{k=1}^m
(-1)^{m-k}W(m-1,k)\sum_{d=1}^{j+k}W(j+k,d)\end{aligned}\)</span></p>
<p>将上式分解为四步转移</p>
<p><span class="math inline">\(n,i\rightarrow j,O(n^2)\)</span></p>
<p><span class="math inline">\(m\rightarrow k,O(m)\)</span></p>
<p><span class="math inline">\(j,k\rightarrow j+k,O(nm)\)</span></p>
<p><span class="math inline">\(j+k\rightarrow d,O((n+m)^2)\)</span></p>
<p>其中 <span class="math inline">\(O(n^2,(n+m)^2)\)</span>
的部分如果用卷积优化，即可做到 <span class="math inline">\(O(N^2\log
N)\)</span></p>
<p>但是 <span class="math inline">\(O(N^3)\)</span> 就 <span
class="math inline">\(pts75\)</span> 了...</p>
<p>Tips:注意在将 <span class="math inline">\(1\)</span>
号节点加入序列时，用上面的方法无法保证它在序列首</p>
<p>需要特殊处理，始终强制它在第一个</p>
<h3 id="on2"><span class="math inline">\(O(N^2)\)</span></h3>
<p>当我发现这个做法不需要任何优化就可以做到 <span
class="math inline">\(O(N^2)\)</span> 的时候。。。。</p>
<p><del>把这个容斥的过程爆开</del></p>
<p>先对于每个儿子的 <span class="math inline">\(dp\)</span>
值按照容斥系数进行上文中 <span class="math inline">\(m\rightarrow
k\)</span> 的变换，复杂度为 <span
class="math inline">\(O(size_u)\)</span></p>
<p>然后进行背包合并，由树形背包的复杂度分析，总复杂度为 <span
class="math inline">\(O(N^2)\)</span></p>
<p>最后发现其实我们只需要知道 <span
class="math inline">\(dp_{u,w(u,fa_u)}\)</span> ，因此这里也只需要 <span
class="math inline">\(O(size_u)\)</span></p>
<p>综上，复杂度为 <span class="math inline">\(O(N^2)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T&amp; a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T&amp; a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DEBUG=<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Log(...) (DEBUG&amp;&amp;(fprintf(stderr,__VA_ARGS__)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Mbe;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,P;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span></span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> I[N],J[N],C[N][N],W[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125; e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sz[N],w[N],dp[N][N],T[N];</span><br><span class="line"><span class="type">int</span> A[N],B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	sz[u]=<span class="number">0</span>,dp[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">		w[v]=e[i].w,<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		<span class="built_in">rep</span>(a,<span class="number">0</span>,sz[u]) T[a]=dp[u][a],dp[u][a]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(a,<span class="number">0</span>,sz[u]) <span class="built_in">rep</span>(b,<span class="number">1</span>,sz[v]) dp[u][a+b]=(dp[u][a+b]+<span class="number">1ll</span>*T[a]*dp[v][b])%P;</span><br><span class="line">		sz[u]+=sz[v];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,w[u],sz[u]+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> e=W[i][w[u]];</span><br><span class="line">		<span class="keyword">if</span>(u==<span class="number">1</span>) e=<span class="number">1ll</span>*C[i<span class="number">-1</span>][i-w[u]]*J[i<span class="number">-1</span>]%P*I[w[u]<span class="number">-1</span>]%P;</span><br><span class="line">		s=(s+<span class="number">1ll</span>*e*dp[u][i<span class="number">-1</span>])%P;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 求出我们需要的点值</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">rep</span>(i,w[u]+<span class="number">1</span>,sz[u]) dp[u][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(!s) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>),<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 容斥系数变换</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,w[u]) &#123;</span><br><span class="line">		dp[u][i]=<span class="number">1ll</span>*s*W[w[u]][i]%P;</span><br><span class="line">		<span class="keyword">if</span>((w[u]-i)&amp;<span class="number">1</span>) dp[u][i]=P-dp[u][i];</span><br><span class="line">	&#125;</span><br><span class="line">	sz[u]=w[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Med;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Log</span>(<span class="string">&quot;Memory taken %.2lf\n&quot;</span>,(&amp;Med-&amp;Mbe)/<span class="number">1024.0</span>/<span class="number">1024.0</span>);</span><br><span class="line">	n=<span class="built_in">rd</span>(),P=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,J[<span class="number">0</span>]=<span class="number">1</span>,n) J[i]=<span class="number">1ll</span>*J[i<span class="number">-1</span>]*i%P;</span><br><span class="line">	I[n]=<span class="built_in">qpow</span>(J[n]);</span><br><span class="line">	<span class="built_in">drep</span>(i,n,<span class="number">1</span>) I[i<span class="number">-1</span>]=<span class="number">1ll</span>*I[i]*i%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) <span class="built_in">rep</span>(j,C[i][<span class="number">0</span>]=<span class="number">1</span>,i) C[i][j]=C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>],<span class="built_in">Mod1</span>(C[i][j]),W[i][j]=<span class="number">1ll</span>*C[i<span class="number">-1</span>][i-j]*J[i]%P*I[j]%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>(),w=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="keyword">if</span>(w&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="built_in">AddEdge</span>(u,v,w/=<span class="number">2</span>),<span class="built_in">AddEdge</span>(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(w[<span class="number">1</span>]=<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1ll</span>*dp[<span class="number">1</span>][<span class="number">1</span>]*n%P;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8CTJOI%20%20HEOI2016%E3%80%8D%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<hr />
<p>title: '「TJOI / HEOI2016」求和' date: 'Sat Aug 12 11:05:28 2023
categories: - oi-solutions'</p>
<h1 id="tjoi-heoi2016求和">「TJOI / HEOI2016」求和</h1>
<p>题目大意：</p>
<p>求 <span class="math inline">\(\displaystyle \sum_{i=0}^n\sum_{j=0}^i
\begin{Bmatrix}i\\ j\end{Bmatrix}2^j\cdot j!\)</span> 。</p>
<p>由于第二类斯特林数的生成函数 <span
class="math inline">\(S_m(x)=\cfrac{1}{m!}(e^x-1)^m\)</span> 。</p>
<p>所以求的东西就是 <span class="math inline">\(\displaystyle
F(x)=\sum_{i=0} (2e^x-2)^i=\frac{1}{3-2e^x}\)</span> 前 <span
class="math inline">\(n\)</span> 项系数。</p>
<span id="more"></span>
<p><del>可以暴力求逆</del></p>
<p>线性解法：<a
href="https://www.cnblogs.com/chasedeath/p/14633883.html">思路</a></p>
<p>要求 <span class="math inline">\(\displaystyle
\frac{1}{3-2e^x}\)</span> 的前 <span class="math inline">\(n\)</span> 项
<span class="math inline">\([x^i]\)</span> 乘 <span
class="math inline">\(i!\)</span> 的和。</p>
<p>设 <span class="math inline">\(\displaystyle
G(x)=e^x,F(x)=\frac{1}{3-2x}\)</span> 。</p>
<p>那么我们需要求得 <span class="math inline">\(\mathscr F(x+1)=F(x+1)
\mod x^{n+1}\)</span> 。</p>
<p><span class="math display">\[
\begin{aligned}
F(x+1)&amp;=\frac{1}{1-2x}=\sum_{i=0} (2x)^i
\\
F&#39;(x+1)&amp;=\sum_{i=0} 2(i+1) (2x)^i
\\
F(x+1)&amp;=\cfrac{1-2x}{2}F&#39;(x+1)
\\
\mathscr F(x+1)&amp;=\cfrac{1-2x}{2}\mathscr F&#39;(x+1)+(n+1)(2x)^n
\\
\mathscr F(x)&amp;=\cfrac{3-2x}{2}\mathscr F&#39;(x)+(n+1)(2x-2)^n
\end{aligned}
\]</span></p>
<p>那么得到：</p>
<p><span class="math display">\[
\begin{aligned}
[x^k]\mathscr F(x)&amp;=\frac{3}{2}(k+1)[x^{k+1}]\mathscr
F(x)-k[x^k]\mathscr F(x)+(n+1)2^{n}\binom{n}{k}(-1)^{n-k}
\\
\displaystyle \frac{3}{2}(k+1)[x^{k+1}]\mathscr
F(x)&amp;=(k+1)[x^k]\mathscr F(x)-(n+1)2^{n}\binom{n}{k}(-1)^{n-k}
\\
\displaystyle \frac{3}{2} [x^{k+1}]\mathscr F(x)&amp;=[x^k]\mathscr
F(x)-2^{n}\binom{n+1}{k+1}(-1)^{n-k}
\end{aligned}
\]</span></p>
<p>最后得到： <span class="math inline">\(\displaystyle \sum_{i=0}^n
[x^i]F(G(x))=\sum_{i=0}^n [x^i]\mathscr F(G(x))=\sum \mathscr F_i
\sum_{j=0}^n j! [x^j]G^k(x)\)</span> 。</p>
<p><span class="math inline">\(\displaystyle [x^0]\mathscr
F(x)=[x^0]\sum_{i=0}^n(2x-2)^i=\sum_{i=0}^n
(-2)^i=\frac{1-(-2)^{n+1}}{3}\)</span></p>
<p><span class="math inline">\(\sum_{j=0}^n j! [x^j]G^k(x)\)</span>
就是一个等比数列求和，可以用线性筛求 <span
class="math inline">\(i^k\)</span> 即可做到线性求解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> I[N],J[N],Inv[N],Pow[N],q[N],F[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span></span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sieve_Pow</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> notpri[N],pri[N],pc;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!notpri[i]) pri[++pc]=i,Pow[i]=<span class="built_in">qpow</span>(i,n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pc &amp;&amp; <span class="number">1ll</span>*i*pri[j]&lt;=n;++j) &#123;</span><br><span class="line">			notpri[i*pri[j]]=<span class="number">1</span>,Pow[i*pri[j]]=<span class="number">1ll</span>*Pow[i]*Pow[pri[j]]%P;</span><br><span class="line">			<span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*J[n]*I[m]%P*I[n-m]%P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),Inv[<span class="number">0</span>]=Inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n+<span class="number">1</span>) Inv[i]=<span class="number">1ll</span>*(P-P/i)*Inv[P%i]%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,*I=*J=<span class="number">1</span>,n+<span class="number">1</span>) I[i]=<span class="number">1ll</span>*I[i<span class="number">-1</span>]*Inv[i]%P,J[i]=<span class="number">1ll</span>*J[i<span class="number">-1</span>]*i%P;</span><br><span class="line">	<span class="built_in">Sieve_Pow</span>(n+<span class="number">1</span>);</span><br><span class="line">	ll p=<span class="built_in">qpow</span>(<span class="number">2</span>,n);</span><br><span class="line">	q[<span class="number">0</span>]=<span class="number">1</span>,q[<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n) q[i]=<span class="number">1ll</span>*(Pow[i]<span class="number">-1</span>)*Inv[i<span class="number">-1</span>]%P;</span><br><span class="line">	F[<span class="number">0</span>]=(((n&amp;<span class="number">1</span>)?P-p*<span class="number">2</span>%P:p*<span class="number">2</span>%P)+<span class="number">1</span>)*(P+<span class="number">1</span>)/<span class="number">3</span>%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> t=p%P*<span class="built_in">C</span>(n+<span class="number">1</span>,i+<span class="number">1</span>)%P;</span><br><span class="line">		<span class="keyword">if</span>((n-i+<span class="number">1</span>)&amp;<span class="number">1</span>) t=P-t;</span><br><span class="line">		F[i+<span class="number">1</span>]=(F[i]+t)*<span class="number">2ll</span>%P*(P+<span class="number">1</span>)/<span class="number">3</span>%P;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) ans=(ans+<span class="number">1ll</span>*F[i]*q[i])%P;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8CGDOI2020%E6%A8%A1%E6%8B%9F%E8%B5%9Bday2%E3%80%8D%E6%88%91%E7%9A%84%E6%9C%8B%E5%8F%8B%E4%BB%AC/</url>
    <content><![CDATA[<hr />
<p>title: '「GDOI2020模拟赛day2」我的朋友们' date: 'Sat Aug 12 11:05:28
2023 categories: - oi-solutions'</p>
<h1
id="gdoi2020模拟赛day2我的朋友们">「GDOI2020模拟赛day2」我的朋友们</h1>
<p>默认翻转了 <span class="math inline">\(a_i\)</span>
顺序，下文多项式省略 <span class="math inline">\((x)\)</span></p>
<p>设当前区间为 <span class="math inline">\((i-L,i]\)</span>
到最终结束的期望步数为 <span class="math inline">\(dp_i\)</span></p>
<p>令 <span class="math inline">\(A_i=a_ix+1-a_i\)</span></p>
<p>令 <span
class="math inline">\(P_i=\prod_{j\in(i-L,i]}A_j\)</span></p>
<p>令 <span class="math inline">\(F_i=\sum_{j=1}^i dp_jx^j\)</span></p>
<p>令 <span class="math inline">\(\displaystyle
G_i=F_{i-1}P_i,dp_i=\frac{[x^i]G_i}{coef_i}\)</span></p>
<p>其中常数 <span
class="math inline">\(coef_i=1-[x^0]P_i=1-\prod_{j\in(i-L,i]}(1-a_j)\)</span>
，容易预处理得到</p>
<p>用分治 <span class="math inline">\(\text{NTT}\)</span>
，过程中维护</p>
<p><span
class="math inline">\(P_{l,r}=\prod_{j\in(r-L,l]}A_j\)</span></p>
<p><span class="math inline">\(\displaystyle
G_{l,r}=F_{l-1}P_{l,r}\)</span></p>
<p>显然 <span class="math inline">\(G_{i,i}=G_i\)</span></p>
<p>分治转移如下：</p>
<p><span class="math inline">\(\displaystyle
G_{l,mid}=G_{l,r}\prod_{j\in (mid-L,min(l,r-L)]} A_j\)</span></p>
<p><span class="math inline">\(P_{l,mid}=P_{l,r}\prod_{j\in
(mid-L,min(l,r-L)]} A_j\)</span></p>
<p>先求出 <span class="math inline">\(G_{l,mid}\)</span></p>
<p><span class="math inline">\(P_{mid+1,r}=P_{l,r}\prod_{j\in
(max(r-L,l),mid+1]} A_j\)</span></p>
<p><span class="math inline">\(\displaystyle
G_{mid+1,r}=(G_{l,r}+(F_{mid}-F_{l-1})P_{l,r})\prod_{j\in
(max(r-L,l),mid+1]} A_j\)</span></p>
<p>归纳上述过程，发现实际上同步维护的部分只需要维护</p>
<p><span class="math inline">\(G_{l,r}\)</span> 的 <span
class="math inline">\([l-(r-l),r]\)</span> 项， <span
class="math inline">\(P_{l,r}\)</span> 的 <span
class="math inline">\([0,r-l]\)</span> 项</p>
<p>只需要实现</p>
<p>通过 <span class="math inline">\(G_{l,r}\)</span> 的 <span
class="math inline">\([l-(r-l),r]\)</span> 项得到 <span
class="math inline">\(G_{l,mid}\)</span> 的 <span
class="math inline">\([l-(mid-l),mid]\)</span> ，以及 <span
class="math inline">\(G_{mid+1,r}\)</span> 的 <span
class="math inline">\([l,r]\)</span></p>
<p>通过 <span class="math inline">\(P_{l,r}\)</span> 的 <span
class="math inline">\([0,r-l]\)</span> 得到 <span
class="math inline">\(P_{l,mid}\)</span> 的 <span
class="math inline">\([0,mid-l]\)</span> ， <span
class="math inline">\(P_{mid+1,r}\)</span> 的 <span
class="math inline">\([0,r-mid-1]\)</span></p>
<p>初始状态</p>
<p><span
class="math inline">\(P_{L,n}=\prod_{j\in(n-L,L]}A_j\)</span></p>
<p><span class="math inline">\(G_{L,n}=0\)</span></p>
<p>在分治过程中有非常多的 <span class="math inline">\(P_{l,r}\)</span>
都是空的。。</p>
<p>可以分治 <span class="math inline">\(\text{NTT}\)</span>
预处理出转移系数 <span class="math inline">\(\displaystyle \prod_{i=l}^r
A_i\)</span> ，或者用记忆化暴力求出，复杂度为 <span
class="math inline">\(O(n\log ^2n)\)</span></p>
<p>在转移过程中维护的部分长度与 <span class="math inline">\(r-l\)</span>
同阶，因此复杂度为 <span class="math inline">\(O(n\log^2 n)\)</span></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8C%E4%BD%99%E5%A7%9A%E4%B8%AD%E5%AD%A6%202019%20%E8%81%94%E6%B5%8B%20Day%204%E3%80%8D%E9%9A%8F%E6%9C%BA%E9%99%A4%E6%B3%95/</url>
    <content><![CDATA[<hr />
<p>title: '「余姚中学 2019 联测 Day 4」随机除法' date: 'Sat Aug 12
11:05:28 2023 categories: - oi-solutions'</p>
<h1 id="余姚中学-2019-联测-day-4随机除法">「余姚中学 2019 联测 Day
4」随机除法</h1>
<p>好题，难就难在转移的高位前缀和</p>
<p>首先是一个浅显的 <span class="math inline">\(\text{dp}\)</span>
状态，令 <span class="math inline">\(n=\Pi prime_i^{c_i}\)</span></p>
<p>则状态只跟 <span class="math inline">\(\{c_i\}\)</span>
有关，这是一个可重集合，强制定义 <span class="math inline">\(c_i\ge
c_{i-1}\)</span> 最小表示出所有不同状态</p>
<p>搜索一下 <span class="math inline">\(\text{dp}\)</span>
状态，发现只有 <span class="math inline">\(170000\)</span>
左右的状态数</p>
<p>直接枚举因数转移复杂度显然是升天的，直接枚举子集状态转移复杂度也很高，并且不好确定系数</p>
<p>所以用一个高位前缀和处理优化<strong>枚举因数的转移</strong></p>
<p>再说一遍，是高位前缀和<strong>枚举因数的转移</strong>，不同的因数可能对应同一个状态</p>
<p>常见的高位前缀和是 <span
class="math inline">\(dp_{i,S}=dp_{i-1,S}+dp_{i,S-\{S_i\}}\)</span></p>
<p>转移具有单调性，对于状态排序之后，定义辅助数组 <span
class="math inline">\(dp_{i,j}\)</span> 表示对于 <span
class="math inline">\(i\)</span> 这个状态</p>
<p>它的子集(注意这个子集是未排序的)中和它不同的最低位置 <span
class="math inline">\(\ge j\)</span> 的总和</p>
<p>计算高位前缀和时，每次转移只会对于一个位置改变</p>
<p>枚举状态时，取得位置是 <span class="math inline">\(j\)</span>
，调用时需要排序</p>
<p>而排完序之后 <span class="math inline">\(j\)</span>
可能会后移，所以需要定义成 <span class="math inline">\(\ge j\)</span>
的，否则会算多</p>
<p>比如转移 <span class="math inline">\((1,1,1)\leftarrow
(0,1,1),(1,0,1),(1,1,0)\)</span></p>
<p>如果定义成 <span class="math inline">\(\le j\)</span>
的状态，三种状态转移之后都变成 <span
class="math inline">\((1,1,0)\)</span></p>
<p>原先在这个状态里的三个位置编号是 <span
class="math inline">\((0,1,2)\)</span></p>
<p>如果都去 <span class="math inline">\((1,1,0)\)</span>
这个状态里转移过来，原先 <span class="math inline">\((0,1,2)\)</span>
对应的下标位置改变，变成</p>
<p><span class="math inline">\((1,2,0)\)</span></p>
<p><span class="math inline">\((0,2,1)\)</span></p>
<p><span class="math inline">\((0,1,2)\)</span></p>
<p>我们访问的时候访问的应该是子状态中不同位置 <span
class="math inline">\(\le j\)</span> 的总和</p>
<p>而从这个下标改变的状态里转移过来时，原先 <span
class="math inline">\(&gt;j\)</span> 的下标被移移动进 <span
class="math inline">\(\le j\)</span> 的范围</p>
<p>再转移就错了</p>
<p>所以正确定义状态之后就可以高位前缀和了</p>
<p>存储和访问状态可以用 <span
class="math inline">\(\text{Hash,Trie,int128}\)</span> 三种方法存储，
<span class="math inline">\(\text{int128}\)</span> 真香啊</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> __int128 Node;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">180000</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line">Node Max,st[N];</span><br><span class="line"><span class="type">int</span> m,a[<span class="number">100</span>],cnt,dp[N][<span class="number">20</span>],F[N],pri[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>&#125;;</span><br><span class="line"><span class="type">char</span> str[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(Node s)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">lower_bound</span>(st+<span class="number">1</span>,st+cnt+<span class="number">1</span>,s)-st; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Load</span><span class="params">(Node s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">20</span>) a[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span> &amp;&amp; s&gt;<span class="number">1</span>; ++i) <span class="keyword">while</span>(s%pri[i]==<span class="number">0</span>) s=s/pri[i],a[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> lst,Node s)</span> </span>&#123; </span><br><span class="line">	st[++cnt]=s;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,lst) &#123;</span><br><span class="line">		<span class="keyword">if</span>((s*=pri[p])&gt;Max) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(p+<span class="number">1</span>,i,s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;div.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),<span class="built_in">freopen</span>(<span class="string">&quot;div.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	Max=<span class="number">1e12</span>,Max=Max*Max;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr,<span class="string">&quot;States Number = %d\n&quot;</span>,cnt);</span><br><span class="line">	<span class="built_in">sort</span>(st+<span class="number">1</span>,st+cnt+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,cnt) &#123;</span><br><span class="line">		Node now; <span class="built_in">Load</span>(now=st[i]);</span><br><span class="line">		<span class="type">int</span> c=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">18</span>) c=<span class="number">1ll</span>*c*(a[i]+<span class="number">1</span>)%P;</span><br><span class="line">		<span class="built_in">drep</span>(j,<span class="number">18</span>,<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!a[j]) dp[i][j]=dp[i][j+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">int</span> k=j;</span><br><span class="line">				<span class="keyword">while</span>(k&gt;<span class="number">1</span> &amp;&amp; a[k<span class="number">-1</span>]==a[k]) --k;</span><br><span class="line">				<span class="type">int</span> p=<span class="built_in">Find</span>(now/pri[j]);</span><br><span class="line">				<span class="built_in">drep</span>(d,j,k) &#123;</span><br><span class="line">					dp[i][d]=dp[i][d+<span class="number">1</span>]+dp[p][d];</span><br><span class="line">					<span class="built_in">Mod1</span>(dp[i][d]);</span><br><span class="line">				&#125;</span><br><span class="line">				j=k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		F[i]=(dp[i][<span class="number">1</span>]+c)*<span class="built_in">qpow</span>(c<span class="number">-1</span>)%P;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,<span class="number">18</span>) dp[i][j]+=F[i],<span class="built_in">Mod1</span>(dp[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,str,&amp;m)) &#123;</span><br><span class="line">		Node n=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];++i) n=n*<span class="number">10</span>+(str[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">			<span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); a[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(n%x==<span class="number">0</span>) n=n/x,a[i]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>,greater &lt;<span class="type">int</span>&gt; ());</span><br><span class="line">		n=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">rep</span>(j,<span class="number">1</span>,a[i]) n=n*pri[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,F[<span class="built_in">Find</span>(n)]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8C%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD%202017%E3%80%8D%E5%B0%8F%20Y%20%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%20/</url>
    <content><![CDATA[<hr />
<p>title: '「清华集训 2017」小 Y 和二叉树' date: 'Sat Aug 12 11:05:29
2023 categories: - oi-solutions'</p>
<h1 id="清华集训-2017小-y-和二叉树">「清华集训 2017」小 Y 和二叉树</h1>
<p>原题数据好像没有卡这个情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">2 1 3</span><br><span class="line">3 2 4 5</span><br><span class="line">1 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<p>输出是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
<p>首先考虑一个 <span class="math inline">\(O(n^2)\)</span> 的暴力：</p>
<p>枚举一个点为根，向下展开树，此时只需要决策左儿子和右儿子的顺序</p>
<p>当两个子树都存在时，由于两个子树包含的元素不同，所以可以直接把
<strong>两个子树序列首较小</strong> (显然不会出现相同的情况)
的一个放在前面即可</p>
<p>实际上我们可以发现，这样得到的序列第一个元素必然是
<strong>编号最小的</strong> 、<strong>不同时包含左右儿子</strong>
的结点</p>
<p>不妨称固定根之后，这样的结点为叶子</p>
<p><span class="math display">\[ \ \]</span></p>
<p>显然的性质：任何一个度数 <span class="math inline">\(\leq 2\)</span>
的点可以作为答案序列的第一个点</p>
<p>设原树上最小的 <span class="math inline">\(\leq 2\)</span> 的点为
<span class="math inline">\(root\)</span> ，接下来对于 <span
class="math inline">\(root\)</span> 的不同情况讨论，要在强制 <span
class="math inline">\(root\)</span> 为序列首的情况下，求得最小的序列</p>
<p>不妨先预处理出结点 <span class="math inline">\(u\)</span>
子树里最小的叶子 <span class="math inline">\(mi_u\)</span></p>
<p>1.没有相邻结点，结束</p>
<p>2.有两个相邻结点，此时要使自己为序列首，必然有一个结点是自己的父亲，有一个结点是自己的右儿子</p>
<p>右儿子会被先遍历到，所以可以直接考虑比较两个相邻结点 作为
右儿子时谁的序列首 较小</p>
<p>即比较两个子树中最小的叶子即可</p>
<p>3.只有一个相邻结点，设其为 <span class="math inline">\(v\)</span></p>
<p>此时要使得自己为序列第一个，只有两种可能，此时同样可以考虑比较序列首元素</p>
<p>3-1.让相邻结点作为自己的父亲，此时下一个元素一定是 <span
class="math inline">\(v\)</span></p>
<p>3-2.让相邻结点作为自己的右儿子，此时下一个元素一定是 <span
class="math inline">\(mi_v\)</span></p>
<p>如果 <span class="math inline">\(v\ne mi_v\)</span> ，显然好决策</p>
<p>当 <span class="math inline">\(v=mi_v\)</span> 时，必然满足 <span
class="math inline">\(v\)</span> 是一个叶子，此时如果将 <span
class="math inline">\(v\)</span> 放在父亲上， <span
class="math inline">\(v\)</span> 的另一个相邻结点(如果存在)</p>
<p>可以放在 <span class="math inline">\(v\)</span> 的父亲或者是 <span
class="math inline">\(v\)</span> 的右子树，如果放在 <span
class="math inline">\(v\)</span> 的右子树，那么这种情况与 <span
class="math inline">\(v\)</span> 被放在 <span
class="math inline">\(u\)</span> 的子树等价</p>
<p>也就是说，把 <span class="math inline">\(v\)</span>
放在父亲可以决策出的序列情况，包含了把 <span
class="math inline">\(v\)</span> 放在右儿子的情况</p>
<p>所以这种情况也应当把 <span class="math inline">\(v\)</span>
放在父亲上</p>
<p>实现上，不妨用两个 <span class="math inline">\(dfs\)</span>
处理最后的决策，一个强制当前结点 <span class="math inline">\(u\)</span>
为序列首，一个求出 <span class="math inline">\(u\)</span>
子树的最优方案</p>
<p>在代码里就是 <span class="math inline">\(Solve,dfs\_get\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> c[N],s[N][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> mi[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	mi[u]=<span class="number">1e9</span>;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,c[u]<span class="number">-1</span>) <span class="keyword">if</span>(s[u][i]!=f) &#123;</span><br><span class="line">		<span class="type">int</span> v=s[u][i]; cnt++;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u),<span class="built_in">cmin</span>(mi[u],mi[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt&lt;=<span class="number">1</span>) <span class="built_in">cmin</span>(mi[u],u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_get</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">-1</span>,b=<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,c[u]<span class="number">-1</span>) <span class="keyword">if</span>(!vis[s[u][i]]) &#123;</span><br><span class="line">		<span class="type">int</span> v=s[u][i];</span><br><span class="line">		<span class="keyword">if</span>(~a) b=v;</span><br><span class="line">		<span class="keyword">else</span> a=v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,u);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(mi[a]&lt;u) <span class="built_in">dfs_get</span>(a),<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,u);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,u),<span class="built_in">dfs_get</span>(a);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(mi[a]&gt;mi[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">		<span class="built_in">dfs_get</span>(a),<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,u),<span class="built_in">dfs_get</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,c[u]<span class="number">-1</span>) <span class="keyword">if</span>(!vis[s[u][i]]) cnt++;</span><br><span class="line">	vis[u]=<span class="number">1</span>,<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,u);</span><br><span class="line">	<span class="keyword">if</span>(cnt==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,c[u]<span class="number">-1</span>) <span class="keyword">if</span>(!vis[s[u][i]]) &#123;</span><br><span class="line">			<span class="type">int</span> v=s[u][i];</span><br><span class="line">			<span class="keyword">if</span>(v&gt;mi[v]) <span class="built_in">dfs_get</span>(s[u][i]);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">Solve</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="type">int</span> a=<span class="number">-1</span>,b=<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,c[u]<span class="number">-1</span>) <span class="keyword">if</span>(!vis[s[u][i]]) &#123;</span><br><span class="line">			<span class="type">int</span> v=s[u][i];</span><br><span class="line">			<span class="keyword">if</span>(~a) b=v;</span><br><span class="line">			<span class="keyword">else</span> a=v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(mi[a]&gt;mi[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">		<span class="built_in">dfs_get</span>(a),<span class="built_in">Solve</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;binary.in&quot;,&quot;r&quot;,stdin),freopen(&quot;binary.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	n=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		c[i]=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="keyword">if</span>(c[i]&lt;=<span class="number">2</span>) <span class="built_in">cmin</span>(rt,i);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,c[i]<span class="number">-1</span>) s[i][j]=<span class="built_in">rd</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(rt,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">Solve</span>(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8C%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD%202017%E3%80%8D%E5%B0%8F%20Y%20%E5%92%8C%E6%81%90%E6%80%96%E7%9A%84%E5%A5%B4%E9%9A%B6%E4%B8%BB/</url>
    <content><![CDATA[<hr />
<p>title: '「清华集训 2017」小 Y 和恐怖的奴隶主' date: 'Sat Aug 12
11:05:29 2023 categories: - oi-solutions'</p>
<h1 id="清华集训-2017小-y-和恐怖的奴隶主">「清华集训 2017」小 Y
和恐怖的奴隶主</h1>
<p><del>是不是这题太水了都没人写啊</del></p>
<p><strong>本题官方题解提供的做法实际上复杂度非常高</strong></p>
<h2 id="part1">Part1</h2>
<p>很显然本题的 <span class="math inline">\(\text{dp}\)</span>
是存储每种血量的随从数量</p>
<p>设状态数量的上限是 <span class="math inline">\(S\)</span></p>
<p>当 <span class="math inline">\(m=3,k=8\)</span> 时，这样的状态一共有
<span class="math inline">\(S=165+1\)</span> 种</p>
<p>如果直接 <span class="math inline">\(dp\)</span> ，每次转移是 <span
class="math inline">\(O(1)\)</span> 的，可以做到 <span
class="math inline">\(O(n\cdot S)\)</span> ，显然无法处理 <span
class="math inline">\(n\)</span> 较大的情况</p>
<p>用矩阵优化 <span class="math inline">\(\text{dp}\)</span>
转移，朴素的实现可以做到 <span class="math inline">\(O(T\cdot \log
n\cdot S^3)\)</span></p>
<p>如果预处理出转移矩阵的幂次，每次查询时只有列向量与方阵的乘法，所以复杂度是
<span class="math inline">\(O(\log n\cdot S^3+T\log n\cdot
S^2)\)</span></p>
<p>实际极限的复杂度预估在 <span class="math inline">\(60\cdot
166^3+500\cdot 60\cdot 166^2\approx 11\cdot 10^8\)</span></p>
<p>官方题解提供的做法就是在在这个算法上进行常数优化，这<del>wtm</del></p>
<p><span class="math display">\[ \ \]</span></p>
<h2 id="part2">Part2</h2>
<p>对于已知 <span class="math inline">\(m,k\)</span> 来说，设每个 <span
class="math inline">\(n\)</span> 构成的答案数列为 <span
class="math inline">\(a_n\)</span></p>
<p>预先处理一部分的答案 <span class="math inline">\(a_1\cdots
a_n\)</span> ，使用 <span class="math inline">\(\text{Berlekamp-Massey
}\)</span> 算法求出序列的最短线性递推</p>
<p>发现总是在 <span class="math inline">\(O(S)\)</span>
的长度以后，递推序列不再改变，即总能得到一个长度为 <span
class="math inline">\(O(S)\)</span> 的全局线性递推</p>
<p>即总可以在 <span class="math inline">\(O(S^2)\)</span>
的时间内求出答案序列 <span class="math inline">\(a_n\)</span>
的<strong>线性递推式</strong></p>
<p>那么对于求得的线性递推式，问题转化为对于每个查询的 <span
class="math inline">\(n\)</span> ，求常系数线性递推数列的第 <span
class="math inline">\(n\)</span> 项答案</p>
<p>用<strong>特征多项式</strong>的做法，可以做到单组查询 <span
class="math inline">\(O(S\log n\log S)\)</span> 的之间求出</p>
<p>那么总复杂度就是 <span class="math inline">\(O(S^2+T\cdot S \log
S\log n)\)</span></p>
<p>理论上来说，复杂度上限应该只有 <span
class="math inline">\(166^2+500\cdot 166\cdot 10\cdot 60\approx 0.5\cdot
10^8\)</span></p>
<p>理论上来说，这个复杂度无论是不是渐进意义下都比矩阵快</p>
<p>但是实际实践中，由于多项式运算的大常数，不优秀的实现下甚至可能超时</p>
<p>考虑到本题多查询的性质，我改变了倍增的基数 <span
class="math inline">\(D\)</span> ，并且预处理出倍增用到的 <span
class="math inline">\(x^i\mod \lambda\)</span></p>
<p>预处理部分的复杂度是 <span class="math inline">\(O(\log_D^n \cdot
(D-1)\cdot S\log S)\)</span></p>
<p>查询部分的复杂度是 <span class="math inline">\(O(\log _D^n S\log
S)\)</span></p>
<p><del>由于我的多项式模板不够成熟</del></p>
<p>在LOJ上，经过这样的魔改，已经能跑得比矩阵块</p>
<p>但是在UOJ上，我同样的代码竟然慢了四倍，而<a
href="https://loj.ac/submission/108525">这份代码</a>在UOJ上的运行时间还略有提高</p>
<p>表示很是绝望。。</p>
<p>事实上，这种做法在 <span class="math inline">\(m,k\)</span>
较大时同样可行，在 <span class="math inline">\(S\)</span> 较大， <span
class="math inline">\(T\)</span>
较小的情况下，实际运行总能有更好的表现</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD%202018%20Day4%E3%80%8DMagic/</url>
    <content><![CDATA[<hr />
<p>title: '「雅礼集训 2018 Day4」Magic(分治NTT)' date: 'Sat Aug 12
11:05:29 2023 categories: - oi-solutions'</p>
<h1 id="雅礼集训-2018-day4magic分治ntt">「雅礼集训 2018
Day4」Magic(分治NTT)</h1>
<p>题目的条件简直无法计算恰好为 <span class="math inline">\(k\)</span>
的方案数，所以考虑计算 <span class="math inline">\(\ge k\)</span>
的方案数</p>
<p>所以可以强制有 <span class="math inline">\(k\)</span>
个相邻位置相同，但是不确定相同的是那些颜色</p>
<p>对每个颜色 <span class="math inline">\(a_i\)</span> 考虑，设把 <span
class="math inline">\(a_i\)</span> 这个颜色分成了 <span
class="math inline">\(b_i\)</span> 个联通块(即强制了 <span
class="math inline">\(a_i-b_i\)</span> 个相邻位置相同)</p>
<p>那方案数就是 <span class="math inline">\(C(a_i-1,b_i-1)\)</span>
(是一个简单的插板问题)</p>
<p>得到每种颜色的联通块个数 <span class="math inline">\(b_i\)</span>
，那么这些联通块之间排列的方案数就是 <span
class="math inline">\(\frac{(\sum b_i)!}{b_i!}\)</span></p>
<p>容易得到 <span class="math inline">\(a_i\rightarrow b_i\)</span>
的方案数，直接合并 <span class="math inline">\(b_i\)</span>
的方案数，是一个背包问题，所以考虑用分治 <span
class="math inline">\(NTT\)</span> 快速合并</p>
<p>那么得到了 <span class="math inline">\(\sum b_i=n-k\)</span>
的所有方案，复杂度 <span class="math inline">\(O(n\log n\log
m)\)</span></p>
<p>最后的容斥比较明显的是一个二项式反演的形式，可以 <span
class="math inline">\(O(n)\)</span> 计算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">17</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> Inv[N+<span class="number">1</span>],Fac[N+<span class="number">1</span>],FInv[N+<span class="number">1</span>];</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123; <span class="keyword">return</span> n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n&lt;m? <span class="number">0</span> : <span class="number">1ll</span>*Fac[n]*FInv[m]%P*FInv[n-m]%P; &#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span></span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector &lt;<span class="type">int</span>&gt; Poly;</span><br><span class="line"><span class="type">int</span> w[N|<span class="number">10</span>],rev[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Inv[<span class="number">0</span>]=Inv[<span class="number">1</span>]=Fac[<span class="number">0</span>]=Fac[<span class="number">1</span>]=FInv[<span class="number">0</span>]=FInv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,N)&#123;</span><br><span class="line">		Fac[i]=<span class="number">1ll</span>*Fac[i<span class="number">-1</span>]*i%P;</span><br><span class="line">		Inv[i]=<span class="number">1ll</span>*(P-P/i)*Inv[P%i]%P;</span><br><span class="line">		FInv[i]=<span class="number">1ll</span>*FInv[i<span class="number">-1</span>]*Inv[i]%P;</span><br><span class="line">	&#125;</span><br><span class="line">	w[N&gt;&gt;<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	ll t=<span class="built_in">qpow</span>(<span class="number">3</span>,(P<span class="number">-1</span>)/N);</span><br><span class="line">	<span class="built_in">rep</span>(i,(N&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>,N<span class="number">-1</span>) w[i]=w[i<span class="number">-1</span>]*t%P;</span><br><span class="line">	<span class="built_in">drep</span>(i,(N&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>,<span class="number">1</span>) w[i]=w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> R=<span class="number">1</span>,cc=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(R&lt;n) R&lt;&lt;=<span class="number">1</span>,cc++;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,R<span class="number">-1</span>) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;cc);</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,Poly &amp;a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">int</span>)a.<span class="built_in">size</span>()&lt;n) a.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> *e=w+i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">				<span class="type">int</span> t=<span class="number">1ll</span>*a[j+i]*e[j-l]%P;</span><br><span class="line">				a[j+i]=a[j]-t; <span class="built_in">Mod2</span>(a[j+i]);</span><br><span class="line">				a[j]+=t; <span class="built_in">Mod1</span>(a[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=<span class="number">1ll</span>*a[i]*Inv[n]%P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poly <span class="keyword">operator</span> * (Poly a,Poly b)&#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>()<span class="number">-1</span>,R=<span class="built_in">Init</span>(n);</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">1</span>),<span class="built_in">NTT</span>(R,b,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) a[i]=<span class="number">1ll</span>*a[i]*b[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">-1</span>),a.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Poly <span class="title">Solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="function">Poly <span class="title">F</span><span class="params">(x+<span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="built_in">rep</span>(y,<span class="number">1</span>,x) F[y]=<span class="built_in">C</span>(x<span class="number">-1</span>,y<span class="number">-1</span>)*FInv[y]%P;</span><br><span class="line">		<span class="keyword">return</span> F;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Solve</span>(l,mid)*<span class="built_in">Solve</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;magic.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),<span class="built_in">freopen</span>(<span class="string">&quot;magic.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="built_in">Init</span>(),n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>();</span><br><span class="line">	Poly dp=<span class="built_in">Solve</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">rep</span>(i,n,m) dp[i]=<span class="number">1ll</span>*dp[i]*Fac[i]%P;</span><br><span class="line">	<span class="type">int</span> i=m-k;</span><br><span class="line">	<span class="built_in">rep</span>(j,n,i<span class="number">-1</span>) dp[i]=(dp[i]+(((i-j)&amp;<span class="number">1</span>)?<span class="number">-1</span>:<span class="number">1</span>)*dp[j]*<span class="built_in">C</span>(m-j,m-i)%P+P)%P;</span><br><span class="line">	ll ans=(dp[i]%P+P)%P;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD%202018%20Day8%E3%80%8DB/</url>
    <content><![CDATA[<hr />
<p>title: '「雅礼集训 2018 Day8」B' date: 'Sat Aug 12 11:05:29 2023
categories: - oi-solutions'</p>
<h1 id="雅礼集训-2018-day8b">「雅礼集训 2018 Day8」B</h1>
<h3 id="solution1">Solution1</h3>
<p>设到达一个点的时间为 <span class="math inline">\(T_u\)</span>
，从这个点出去的时间为 <span class="math inline">\(T_u&#39;\)</span></p>
<p>那么显然满足 <span class="math inline">\(T_u\leq T_u&#39;\leq
T_u+t_u\)</span> ，答案就是 <span class="math inline">\(\sum
(t_u-(T&#39;_u-T_u))\cdot c_u\)</span></p>
<p>对于一条边满足 <span class="math inline">\(T_v\ge T&#39;_u\)</span>
，二分答案之后，容易发现这是一个线性规划问题</p>
<p>可以暴力单纯形解决掉(当然是水的，但是好像还挺快。。)</p>
<p><a href="https://loj.ac/s/1096230">Loj Submission</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) f|=IO==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">630</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,W,t[N],c[N];</span><br><span class="line"><span class="type">int</span> U[N],V[N];</span><br><span class="line">db A[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">Simplex</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">auto</span> Pivot=[&amp;](<span class="type">int</span> x,<span class="type">int</span> y) &#123;</span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> P[N],C;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n) A[y][i]=-A[x][i]/A[x][y];</span><br><span class="line">		A[y][x]=<span class="number">1</span>/A[x][y],A[y][y]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n) A[x][i]=<span class="number">0</span>;</span><br><span class="line">		C=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n) <span class="keyword">if</span>(<span class="built_in">abs</span>(A[y][i])&gt;eps) P[++C]=i;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n) <span class="keyword">if</span>(<span class="built_in">abs</span>(A[i][y])&gt;eps) &#123;</span><br><span class="line">			db t=A[i][y]; A[i][y]=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">1</span>,C) A[i][P[j]]+=t*A[y][P[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; V;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) V.<span class="built_in">pb</span>(i);</span><br><span class="line">	<span class="comment">//random_shuffle(V.begin(),V.end());</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:V) <span class="keyword">if</span>(!u || A[i][<span class="number">0</span>]&lt;A[u][<span class="number">0</span>]) u=i;</span><br><span class="line">		<span class="keyword">if</span>(A[u][<span class="number">0</span>]&gt;-eps) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:V) <span class="keyword">if</span>(A[u][i]&gt;eps) v=i;</span><br><span class="line">		<span class="keyword">if</span>(!v) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Infeasible&quot;</span>),<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">Pivot</span>(u,v);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:V) <span class="keyword">if</span>(!v || A[<span class="number">0</span>][i]&gt;A[<span class="number">0</span>][v]) v=i;</span><br><span class="line">		<span class="keyword">if</span>(A[<span class="number">0</span>][v]&lt;eps) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:V) <span class="keyword">if</span>(A[i][v]&lt;-eps) <span class="keyword">if</span>(!u || (A[i][<span class="number">0</span>]/A[i][v] &gt; A[u][<span class="number">0</span>]/A[u][v])) u=i;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Unbounded&quot;</span>),<span class="number">0</span>; </span><br><span class="line">		<span class="built_in">Pivot</span>(u,v); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> A[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> outd[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> lim)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="keyword">sizeof</span> A);</span><br><span class="line">	<span class="type">int</span> cnt=n*<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) A[<span class="number">0</span>][i+n]=c[i],A[<span class="number">0</span>][i]=-c[i],A[<span class="number">0</span>][<span class="number">0</span>]-=t[i]*c[i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		A[++cnt][i]=<span class="number">-1</span>; A[cnt][i+n]=<span class="number">1</span>;</span><br><span class="line">		A[++cnt][i]=<span class="number">1</span>; A[cnt][i+n]=<span class="number">-1</span>; A[cnt][<span class="number">0</span>]=t[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) A[++cnt][U[i]+n]=<span class="number">-1</span>,A[cnt][V[i]]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!outd[i]) A[++cnt][<span class="number">0</span>]=lim,A[cnt][i+n]=<span class="number">-1</span>;</span><br><span class="line">	db res=-<span class="built_in">Simplex</span>(cnt);</span><br><span class="line">	<span class="keyword">return</span> res&lt;=W+eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;soft.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),<span class="built_in">freopen</span>(<span class="string">&quot;soft.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),W=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,res=<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) t[i]=<span class="built_in">rd</span>(),r+=t[i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) c[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) U[i]=<span class="built_in">rd</span>(),V[i]=<span class="built_in">rd</span>(),outd[U[i]]++;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">Check</span>(mid)) r=mid<span class="number">-1</span>,res=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="solution2">Solution2</h3>
<p>二分答案 <span class="math inline">\(\text{lim}\)</span>
，问题转化为求最小花费</p>
<p>设每个点减少了 <span class="math inline">\(x_i\)</span></p>
<p>考虑限制有两种，一种是路径长度的限制，一种是每个点大小的限制</p>
<p><span class="math inline">\(\text{minimize:} \sum x_i\cdot
c_i\)</span></p>
<p><span class="math inline">\(\displaystyle \forall p\in paths , \sum
x_{p_i}\ge \sum t_{p_i}-\text{lim}\)</span></p>
<p><span class="math inline">\(-x_i\ge -t_i\)</span></p>
<p>对偶一下，设对于路径 <span class="math inline">\(p\)</span> ， <span
class="math inline">\(\sum x_{p_i}\)</span> 的对偶变量为 <span
class="math inline">\(y_p\)</span> ， <span
class="math inline">\(-x_i\)</span> 的对偶变量为 <span
class="math inline">\(z_i\)</span></p>
<p><span class="math inline">\(\text{maximize}:\sum y_p\cdot (\sum
t_{p_i}-\text{lim})-z_i\cdot t_i\)</span></p>
<p><span class="math inline">\(\displaystyle \forall i\in[1,n],
\sum_{p\in paths,i\in p} y_p-z_i\leq c\)</span></p>
<p>考虑对偶变量 <span class="math inline">\(y_p\)</span> 和 <span
class="math inline">\(z_i\)</span> 有什么意义</p>
<p>此时，选择一条路径 <span class="math inline">\(y_p\)</span> ，会使得
关于路径上的点的限制+1 ， 使得答案增加 <span class="math inline">\(\sum
t_{p_i}-\text{lim}\)</span></p>
<p><span class="math inline">\(z_i\)</span> 是关于每个单点的变量，可以用
<span class="math inline">\(t_i\)</span> 代价使得每个 <span
class="math inline">\(i\)</span> 的限制-1</p>
<p>那么可以考虑转化为一个路径覆盖问题，选择一条路径覆盖路径上的点，且得到
<span class="math inline">\(\sum t_{p_i}-\text{lim}\)</span> 的价值</p>
<p>限制式子转化为：每个点被覆盖次数大于 <span
class="math inline">\(c\)</span> 时，再选择就要付出 <span
class="math inline">\(t_i\)</span> 的代价令 <span
class="math inline">\(z_i\)</span> 加一</p>
<p>带权的路径覆盖容易转化为费用流模型，可以把每个点拆成入点出点，每个点被覆盖前
<span class="math inline">\(c_i\)</span> 次，价值为 <span
class="math inline">\(t_i\)</span> ，之后就为0</p>
<p>因此每个点的入点向出点连 <span
class="math inline">\((c_i,t_i),(\infty,0)\)</span> 两条边即可，路径的
<span class="math inline">\(\text{-lim}\)</span> 可以在源点前加入</p>
<p>求一次最大费用可行流，最终得到的答案是原问题的最小代价</p>
<p><a href="https://loj.ac/s/1096314"><del>是我EK写得太丑的说</del>: Loj
Submission</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) f|=IO==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span>&#123;N=<span class="number">10101</span>,INF=<span class="number">1</span>&lt;&lt;<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,W;</span><br><span class="line"><span class="type">int</span> c[N],t[N],X[N],Y[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt,w,c;</span><br><span class="line">&#125; e[N];</span><br><span class="line"><span class="type">int</span> head[N],ecnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> V,S,T;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> c)</span></span>&#123; e[++ecnt]=(Edge)&#123;v,head[u],w,c&#125;,head[u]=ecnt; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> c)</span></span>&#123; <span class="built_in">AddEdge</span>(u,v,w,c),<span class="built_in">AddEdge</span>(v,u,<span class="number">0</span>,-c); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pre[N],dis[N],inq[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,V) dis[i]=-INF;</span><br><span class="line">	<span class="type">static</span> queue &lt;<span class="type">int</span>&gt; que;</span><br><span class="line">	dis[S]=-lim,que.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u=que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>(),inq[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(!e[i].w || dis[v]&gt;=dis[u]+e[i].c) <span class="keyword">continue</span>;</span><br><span class="line">			dis[v]=dis[u]+e[i].c,pre[v]=i;</span><br><span class="line">			<span class="keyword">if</span>(!inq[v]) que.<span class="built_in">push</span>(v),inq[v]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[T]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">	S=++V,T=++V;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		<span class="built_in">Link</span>(S,++V,INF,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">Link</span>(V,V+<span class="number">1</span>,c[i],t[i]);</span><br><span class="line">		<span class="built_in">Link</span>(V,V+<span class="number">1</span>,INF,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">Link</span>(++V,T,INF,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">Link</span>(X[i]*<span class="number">2</span>+<span class="number">2</span>,Y[i]*<span class="number">2</span>+<span class="number">1</span>,INF,<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">SPFA</span>(lim))&#123;</span><br><span class="line">		<span class="type">int</span> w=INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>].to) <span class="built_in">cmin</span>(w,e[pre[i]].w);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=T;i!=S;i=e[pre[i]^<span class="number">1</span>].to) e[pre[i]].w-=w,e[pre[i]^<span class="number">1</span>].w+=w;</span><br><span class="line">		ans+=dis[T]*w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,V) head[i]=<span class="number">0</span>;</span><br><span class="line">	ecnt=<span class="number">1</span>,V=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ans&lt;=W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;soft.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),<span class="built_in">freopen</span>(<span class="string">&quot;soft.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),W=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,res=<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) r+=t[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) c[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) X[i]=<span class="built_in">rd</span>(),Y[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid;l&lt;=r;) <span class="built_in">Check</span>(mid=(l+r)&gt;&gt;<span class="number">1</span>)?r=mid<span class="number">-1</span>,res=mid:l=mid+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>【UER #9】赶路</title>
    <url>/oi-solutions/%E3%80%90UER%20#9%E3%80%91%E8%B5%B6%E8%B7%AF/</url>
    <content><![CDATA[<p>--一定有解。。</p>
<h3 id="x_1leq-x_ileq-x_n"><span class="math inline">\(x_1\leq x_i\leq
x_n\)</span></h3>
<p>将中间的点按照 <span class="math inline">\((x_i,y_i)\)</span>
排序，然后依次连过去即可</p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="x_1y_10-四个象限均存在点"><span
class="math inline">\(x_1=y_1=0\)</span> ，四个象限均存在点</h3>
<p>将所有点极角排序，然后走一圈即可</p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="onlog-n"><span class="math inline">\(O(n\log n)\)</span></h3>
<p>不妨设 <span class="math inline">\(x_1&lt;x_n\)</span></p>
<p>将 <span class="math inline">\(1,n\)</span>
以外所有点分成三部分，即左边| 1 | 中间 | n | 右边</p>
<p>左边右边考虑极角排序转圈走，中间按照 <span
class="math inline">\((x_i,y_i)\)</span> 走</p>
<p>发现两边极角排序之后转圈走不一定能够走到中间去，可能会与转圈时的路径相交</p>
<p>但是实际上画图就会发现，如果顺时针走的路径会相交，逆时针走一定不相交</p>
<p>因此对于左右枚举顺时针还是逆时针即可，4中情况，每种 <span
class="math inline">\(O(n)\)</span> 检查线段相交</p>
<p>总能构造一组合法解</p>
<p>预处理需要排序，因此复杂度为 <span class="math inline">\(O(n\log
n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) f|=IO==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	db x,y;</span><br><span class="line">	<span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Node</span>(db x,db y):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123; &#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node __) <span class="type">const</span> &#123; <span class="keyword">return</span> x!=__.x?x&lt;__.x:y&lt;__.y; &#125;</span><br><span class="line">	Node <span class="keyword">operator</span> - (<span class="type">const</span> Node &amp;t) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Node</span>(x-t.x,y-t.y); &#125;</span><br><span class="line">	db <span class="keyword">operator</span> * (<span class="type">const</span> Node &amp;t) <span class="type">const</span> &#123; <span class="keyword">return</span> x*t.x+y*t.y; &#125;</span><br><span class="line">	db <span class="keyword">operator</span> ^ (<span class="type">const</span> Node &amp;t) <span class="type">const</span> &#123; <span class="keyword">return</span> x*t.y-y*t.x; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">turn</span><span class="params">(db t)</span></span>&#123;</span><br><span class="line">		db a=x*<span class="built_in">cos</span>(t)-y*<span class="built_in">sin</span>(t),b=x*<span class="built_in">sin</span>(t)+y*<span class="built_in">cos</span>(t);</span><br><span class="line">		x=a,y=b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">db <span class="title">tan</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">atan2</span>(x,y); &#125;</span><br><span class="line">&#125; A[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Cross</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(((A[x]-A[y])^(A[a]-A[b]))==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	db l=(A[a]-A[x])^(A[y]-A[x]),r=(A[b]-A[x])^(A[y]-A[x]);</span><br><span class="line">	<span class="keyword">if</span>((l&lt;<span class="number">0</span>)^(r&gt;<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a,x),<span class="built_in">swap</span>(b,y);</span><br><span class="line">	l=(A[a]-A[x])^(A[y]-A[x]),r=(A[b]-A[x])^(A[y]-A[x]);</span><br><span class="line">	<span class="keyword">if</span>((l&lt;<span class="number">0</span>)^(r&gt;<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L[N],LC,R[N],RC,T[N],TC;</span><br><span class="line"><span class="type">int</span> P[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> C=<span class="number">0</span>;</span><br><span class="line">	P[++C]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,LC) P[++C]=L[i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,TC) P[++C]=T[i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,RC) P[++C]=R[i];</span><br><span class="line">	P[++C]=n;</span><br><span class="line">	<span class="keyword">if</span>(LC) <span class="built_in">rep</span>(i,<span class="number">2</span>,LC) <span class="keyword">if</span>(<span class="built_in">Cross</span>(P[LC+<span class="number">1</span>],P[LC+<span class="number">2</span>],P[i],P[i<span class="number">-1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(RC) <span class="built_in">drep</span>(i,n,n-RC+<span class="number">2</span>) <span class="keyword">if</span>(<span class="built_in">Cross</span>(P[n-RC],P[n-RC<span class="number">-1</span>],P[i],P[i<span class="number">-1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">Work</span>()) &#123;</span><br><span class="line">				<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,P[i]);</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">reverse</span>(R+<span class="number">1</span>,R+RC+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">reverse</span>(L+<span class="number">1</span>,L+LC+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>())&#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n=<span class="built_in">rd</span>()) A[i].x=<span class="built_in">rd</span>(),A[i].y=<span class="built_in">rd</span>();</span><br><span class="line">		db t=<span class="number">1.0</span>*(<span class="built_in">rand</span>()+<span class="number">2</span>)/(<span class="built_in">rand</span>()+<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) A[i].<span class="built_in">turn</span>(t);</span><br><span class="line">		<span class="keyword">if</span>(A[<span class="number">1</span>].x&gt;A[n].x) <span class="built_in">rep</span>(i,<span class="number">1</span>,n) A[i].x=-A[i].x;</span><br><span class="line">		LC=RC=TC=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">2</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(A[i].x&lt;A[<span class="number">1</span>].x-eps) L[++LC]=i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(A[i].x-eps&gt;A[n].x) R[++RC]=i;</span><br><span class="line">		<span class="keyword">else</span> T[++TC]=i;</span><br><span class="line">		<span class="built_in">sort</span>(T+<span class="number">1</span>,T+TC+<span class="number">1</span>,[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123; <span class="keyword">return</span> A[x].x&lt;A[y].x; &#125;);</span><br><span class="line">		<span class="built_in">sort</span>(L+<span class="number">1</span>,L+LC+<span class="number">1</span>,[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123; <span class="built_in">return</span> (A[x]-A[<span class="number">1</span>]).<span class="built_in">tan</span>()&lt;(A[y]-A[<span class="number">1</span>]).<span class="built_in">tan</span>(); &#125;);</span><br><span class="line">		<span class="built_in">sort</span>(R+<span class="number">1</span>,R+RC+<span class="number">1</span>,[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123; <span class="built_in">return</span> (A[x]-A[n]).<span class="built_in">tan</span>()&lt;(A[y]-A[n]).<span class="built_in">tan</span>(); &#125;);</span><br><span class="line">		<span class="built_in">Solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E6%9C%89%E6%A0%87%E5%8F%B7DAG%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<hr />
<p>title: '有标号DAG计数' date: 'Sat Aug 12 11:05:29 2023 categories: -
oi-solutions'</p>
<h1 id="有标号dag计数">有标号DAG计数</h1>
<p>题目大意：求 <span class="math inline">\(n\)</span>
个点有标号<strong>弱连通</strong> <span
class="math inline">\(\text{DAG}\)</span> 数量</p>
<p>如果你做过类似 <a href="https://loj.ac/p/3165">「CEOI2019」游乐园</a>
这样常见的 <span class="math inline">\(\text{DAG}\)</span> 计数问题</p>
<p>就会对于统计 <span class="math inline">\(\text{DAG}\)</span>
数量的这个容斥方法十分熟悉</p>
<p>枚举图分层，设当前已经确定的层中点集为 <span
class="math inline">\(S\)</span> ，下一层点集为 <span
class="math inline">\(T\)</span></p>
<p><span class="math inline">\(dp_{S+T}\leftarrow dp_{S}\times
2^{|S|\cdot |T|}(-1)^{|T|+1}\)</span></p>
<p>其中 <span class="math inline">\(|S|\cdot |T|\)</span>
为层间随意连的边数量， <span class="math inline">\((-1)^{|T|+1}\)</span>
是针对分层不唯一的容斥</p>
<p>当然这样统计出的 <span class="math inline">\(\text{DAG}\)</span>
是不连通的</p>
<p>那么我们先考虑用卷积来维护这样的一个图</p>
<p>设分层大小为 <span class="math inline">\(a_i,i\in[1,m],n=\sum
a_i\)</span> ，则上式的变化形式就是</p>
<p><span class="math inline">\(\displaystyle \frac{\displaystyle
n!2^{\binom{n}{2}}}{\displaystyle \prod
a_i!(-1)^{a_i+1}2^{\binom{a_i}{2}}}\)</span></p>
<p>其中 <span class="math inline">\(\displaystyle \binom{n}{2}-\sum
\binom{a_i}{2}\)</span> 就能得出层间边的数量</p>
<p>那么令 <span class="math inline">\(\displaystyle F(x)=\sum_{n\ge
1}\frac{(-1)^{n+1}}{n!2^{\binom{n}{2}}}\)</span>
，由于层间有序，答案是</p>
<p><span class="math inline">\(\displaystyle G(x)=\sum
F^i(x)=\frac{1}{1-F(x)}\)</span></p>
<p>求逆一次即可得到 <span class="math inline">\(G(x)\)</span>
，然后补上式子中的系数 <span class="math inline">\(\displaystyle
2^{\binom{n}{2}}\)</span></p>
<p>显然不连通的 <span class="math inline">\(\text{DAG}\)</span> 转为连通
<span class="math inline">\(\text{DAG}\)</span> 只需要再求一次 <span
class="math inline">\(\ln\)</span> 即可</p>
<p>注意计算的时候是以 <span class="math inline">\(\text{EGF}\)</span>
的形式，最后要补回阶乘</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="keyword">typedef</span> vector &lt;<span class="type">int</span>&gt; V;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(...) fprintf(stderr,__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(...) </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) f|=IO==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">18</span>,N=<span class="number">1</span>&lt;&lt;L|<span class="number">10</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> I[N],J[N];</span><br><span class="line"><span class="type">int</span> rev[N],w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	w[<span class="number">1</span>&lt;&lt;(L<span class="number">-1</span>)]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">qpow</span>(<span class="number">3</span>,(P<span class="number">-1</span>)&gt;&gt;L);</span><br><span class="line">	<span class="built_in">rep</span>(i,(<span class="number">1</span>&lt;&lt;(L<span class="number">-1</span>))+<span class="number">1</span>,<span class="number">1</span>&lt;&lt;L) w[i]=<span class="number">1ll</span>*w[i<span class="number">-1</span>]*t%P;</span><br><span class="line">	<span class="built_in">drep</span>(i,(<span class="number">1</span>&lt;&lt;(L<span class="number">-1</span>))<span class="number">-1</span>,<span class="number">1</span>) w[i]=w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">rep</span>(i,J[<span class="number">0</span>]=<span class="number">1</span>,N<span class="number">-1</span>) J[i]=<span class="number">1ll</span>*J[i<span class="number">-1</span>]*i%P;</span><br><span class="line">	I[N<span class="number">-1</span>]=<span class="built_in">qpow</span>(J[N<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">drep</span>(i,N<span class="number">-1</span>,<span class="number">1</span>) I[i<span class="number">-1</span>]=<span class="number">1ll</span>*I[i]*i%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> R=<span class="number">1</span>,c=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(R&lt;=n) R&lt;&lt;=<span class="number">1</span>,c++;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;c);</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,V &amp;A,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> ull a[N];</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">int</span>)A.<span class="built_in">size</span>()&lt;n) A.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[rev[i]]=A[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> *e=w+i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">				<span class="type">int</span> t=a[j+i]*e[j-l]%P;</span><br><span class="line">				a[j+i]=a[j]+P-t;</span><br><span class="line">				a[j]+=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=a[i]%P,<span class="built_in">Mod2</span>(A[i]);</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">reverse</span>(A.<span class="built_in">begin</span>()+<span class="number">1</span>,A.<span class="built_in">end</span>());</span><br><span class="line">		ll base=<span class="number">1ll</span>*I[n]*J[n<span class="number">-1</span>]%P;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=A[i]*base%P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V <span class="keyword">operator</span> + (V a,<span class="type">const</span> V &amp;b) &#123;</span><br><span class="line">	<span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>()) a.<span class="built_in">resize</span>(b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,b.<span class="built_in">size</span>()<span class="number">-1</span>) a[i]+=b[i],<span class="built_in">Mod1</span>(a[i]);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> - (V a,<span class="type">const</span> V &amp;b) &#123;</span><br><span class="line">	<span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>()) a.<span class="built_in">resize</span>(b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,b.<span class="built_in">size</span>()<span class="number">-1</span>) a[i]-=b[i],<span class="built_in">Mod2</span>(a[i]);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> * (V a,V b) &#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>()<span class="number">-1</span>,m=b.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> R=<span class="built_in">Init</span>(n+m);</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">1</span>),<span class="built_in">NTT</span>(R,b,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) a[i]=<span class="number">1ll</span>*a[i]*b[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">-1</span>),a.<span class="built_in">resize</span>(n+m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">println</span><span class="params">(<span class="type">const</span> V &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:a) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">read</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="function">V <span class="title">A</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> ~ (V a) &#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>(),m=(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> &#123;(<span class="type">int</span>)<span class="built_in">qpow</span>(a[<span class="number">0</span>])&#125;;</span><br><span class="line">	V b=a; b.<span class="built_in">resize</span>(m),b=~b;</span><br><span class="line">	<span class="type">int</span> R=<span class="built_in">Init</span>(n*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">1</span>),<span class="built_in">NTT</span>(R,b,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) a[i]=(P+<span class="number">2</span><span class="number">-1ll</span>*a[i]*b[i]%P)*b[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">-1</span>),a.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">Deriv</span><span class="params">(V a)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,a.<span class="built_in">size</span>()<span class="number">-2</span>) a[i]=<span class="number">1ll</span>*(i+<span class="number">1</span>)*a[i+<span class="number">1</span>]%P;</span><br><span class="line">	a.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">Integ</span><span class="params">(V a)</span></span>&#123;</span><br><span class="line">	a.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">drep</span>(i,a.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>) a[i]=<span class="number">1ll</span>*a[i<span class="number">-1</span>]*J[i<span class="number">-1</span>]%P*I[i]%P;</span><br><span class="line">	a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">Ln</span><span class="params">(V a)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">	a=<span class="built_in">Deriv</span>(a)*~a;</span><br><span class="line">	<span class="keyword">return</span> a.<span class="built_in">resize</span>(n<span class="number">-1</span>),<span class="built_in">Integ</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Div2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x&amp;<span class="number">1</span>?x+P:x)/<span class="number">2</span>; &#125;</span><br><span class="line"><span class="type">int</span> Pow[N],IPow[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">	Pow[<span class="number">0</span>]=Pow[<span class="number">1</span>]=IPow[<span class="number">0</span>]=IPow[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,x=<span class="number">2</span>,y=(P+<span class="number">1</span>)/<span class="number">2</span>;i&lt;N;i++,x*=<span class="number">2</span>,<span class="built_in">Mod1</span>(x),y=<span class="built_in">Div2</span>(y)) &#123;</span><br><span class="line">		Pow[i]=<span class="number">1ll</span>*Pow[i<span class="number">-1</span>]*x%P;</span><br><span class="line">		IPow[i]=<span class="number">1ll</span>*IPow[i<span class="number">-1</span>]*y%P;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">V <span class="title">F</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		F[i]=<span class="number">1ll</span>*I[i]*IPow[i]%P;</span><br><span class="line">		<span class="keyword">if</span>(~i&amp;<span class="number">1</span>) F[i]=-F[i],<span class="built_in">Mod2</span>(F[i]); <span class="comment">// 这个是容斥系数 </span></span><br><span class="line">		F[i]=P-F[i];<span class="comment">// 这个是1-F</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 这个是1-F</span></span><br><span class="line">	F[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	F=~F;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) F[i]=<span class="number">1ll</span>*F[i]*Pow[i]%P;</span><br><span class="line">    <span class="comment">// 补回系数，然后做一次ln</span></span><br><span class="line">	F=<span class="built_in">Ln</span>(F);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) F[i]=<span class="number">1ll</span>*F[i]*J[i]%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,F[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E6%9C%89%E6%A0%87%E5%8F%B7%E4%BA%8C%E5%88%86%E5%9B%BE%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<hr />
<p>title: '有标号二分图计数' date: 'Sat Aug 12 11:05:29 2023 categories:
- oi-solutions'</p>
<h1 id="有标号二分图计数">有标号二分图计数</h1>
<p>求 <span class="math inline">\(n\)</span> 个点的有标号二分图数目</p>
<p>容易想到一个会重复的计算方法：暴力把图剖成两个集合，然后集合间随意连边</p>
<p><span class="math inline">\(G_n=\displaystyle \sum_{i=0}^n
\binom{n}{i}2^{i(n-i)}\)</span></p>
<p>而如果一个二分图包含 <span class="math inline">\(t\)</span>
个连通块，那么在 <span class="math inline">\(G\)</span> 中它会被计算
<span class="math inline">\(2^t\)</span> 次</p>
<p>不妨设 <span class="math inline">\(\text{EGF}:\)</span></p>
<p><span class="math inline">\(H(x)\)</span> 为 <span
class="math inline">\(n\)</span> 个点连通的二分图的数目</p>
<p><span class="math inline">\(G(x)\)</span> 为 <span
class="math inline">\(G_n\)</span> 的生成函数</p>
<p><span class="math inline">\(F(x)\)</span> 为 <span
class="math inline">\(n\)</span> 个点二分图生成函数</p>
<p>容易发现 <span class="math inline">\(\displaystyle G(x)=\sum
\frac{H^i(x)2^i}{i!}=\text{exp}(2H(x))\)</span></p>
<p>而我们要求的答案生成函数 <span
class="math inline">\(F(x)=\text{exp}(H(x))\)</span></p>
<p>也就是说 <span class="math inline">\(F(x)=\sqrt {G(x)}\)</span></p>
<p>而根据组合意义容易发现 <span class="math inline">\(\displaystyle
i(n-i)=\binom{n}{2}-\binom{i}{2}-\binom{n-i}{2}\)</span>
，容易通过卷积得到 <span class="math inline">\(G(x)\)</span></p>
<p>然后开根即可，实际做的时候注意区分什么时候算的是 <span
class="math inline">\(\text{EGF}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">18</span>,N=<span class="number">1</span>&lt;&lt;L|<span class="number">10</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> I[N],J[N];</span><br><span class="line"><span class="type">int</span> rev[N],w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	w[<span class="number">1</span>&lt;&lt;(L<span class="number">-1</span>)]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">qpow</span>(<span class="number">3</span>,(P<span class="number">-1</span>)&gt;&gt;L);</span><br><span class="line">	<span class="built_in">rep</span>(i,(<span class="number">1</span>&lt;&lt;(L<span class="number">-1</span>))+<span class="number">1</span>,<span class="number">1</span>&lt;&lt;L) w[i]=<span class="number">1ll</span>*w[i<span class="number">-1</span>]*t%P;</span><br><span class="line">	<span class="built_in">drep</span>(i,(<span class="number">1</span>&lt;&lt;(L<span class="number">-1</span>))<span class="number">-1</span>,<span class="number">1</span>) w[i]=w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">rep</span>(i,J[<span class="number">0</span>]=<span class="number">1</span>,N<span class="number">-1</span>) J[i]=<span class="number">1ll</span>*J[i<span class="number">-1</span>]*i%P;</span><br><span class="line">	I[N<span class="number">-1</span>]=<span class="built_in">qpow</span>(J[N<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">drep</span>(i,N<span class="number">-1</span>,<span class="number">1</span>) I[i<span class="number">-1</span>]=<span class="number">1ll</span>*I[i]*i%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> R=<span class="number">1</span>,c=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(R&lt;=n) R&lt;&lt;=<span class="number">1</span>,c++;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;c);</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,V &amp;A,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> ll a[N];</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">int</span>)A.<span class="built_in">size</span>()&lt;n) A.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[rev[i]]=A[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> *e=w+i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">				<span class="type">int</span> t=a[j+i]*e[j-l]%P;</span><br><span class="line">				a[j+i]=a[j]-t;</span><br><span class="line">				a[j]+=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=a[i]%P,<span class="built_in">Mod2</span>(A[i]);</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">reverse</span>(A.<span class="built_in">begin</span>()+<span class="number">1</span>,A.<span class="built_in">end</span>());</span><br><span class="line">		ll base=<span class="number">1ll</span>*I[n]*J[n<span class="number">-1</span>]%P;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=A[i]*base%P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V <span class="keyword">operator</span> + (V a,<span class="type">const</span> V &amp;b) &#123;</span><br><span class="line">	<span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>()) a.<span class="built_in">resize</span>(b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,b.<span class="built_in">size</span>()<span class="number">-1</span>) a[i]+=b[i],<span class="built_in">Mod1</span>(a[i]);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> - (V a,<span class="type">const</span> V &amp;b) &#123;</span><br><span class="line">	<span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>()) a.<span class="built_in">resize</span>(b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,b.<span class="built_in">size</span>()<span class="number">-1</span>) a[i]-=b[i],<span class="built_in">Mod2</span>(a[i]);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> * (V a,V b) &#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>()<span class="number">-1</span>,m=b.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> R=<span class="built_in">Init</span>(n+m);</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">1</span>),<span class="built_in">NTT</span>(R,b,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) a[i]=<span class="number">1ll</span>*a[i]*b[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">-1</span>),a.<span class="built_in">resize</span>(n+m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">println</span><span class="params">(<span class="type">const</span> V &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:a) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">read</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="function">V <span class="title">A</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> ~ (V a) &#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>(),m=(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> &#123;(<span class="type">int</span>)<span class="built_in">qpow</span>(a[<span class="number">0</span>])&#125;;</span><br><span class="line">	V b=a; b.<span class="built_in">resize</span>(m),b=~b;</span><br><span class="line">	<span class="type">int</span> R=<span class="built_in">Init</span>(n*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">1</span>),<span class="built_in">NTT</span>(R,b,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) a[i]=(P+<span class="number">2</span><span class="number">-1ll</span>*a[i]*b[i]%P)*b[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">-1</span>),a.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Div2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x&amp;<span class="number">1</span>?x+P:x)/<span class="number">2</span>; &#125;</span><br><span class="line"><span class="function">V <span class="title">Sqrt</span><span class="params">(V a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">	V b=a; b.<span class="built_in">resize</span>((n+<span class="number">1</span>)/<span class="number">2</span>),b=<span class="built_in">Sqrt</span>(b),b.<span class="built_in">resize</span>(n);</span><br><span class="line">	a=a*~b; a.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,b.<span class="built_in">size</span>()<span class="number">-1</span>) a[i]+=b[i],<span class="built_in">Mod1</span>(a[i]);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=<span class="built_in">Div2</span>(a[i]);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Pow[N],IPow[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">1e5</span>;</span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">	Pow[<span class="number">0</span>]=Pow[<span class="number">1</span>]=IPow[<span class="number">0</span>]=IPow[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,x=<span class="number">2</span>,y=(P+<span class="number">1</span>)/<span class="number">2</span>;i&lt;N;i++,x*=<span class="number">2</span>,<span class="built_in">Mod1</span>(x),y=<span class="built_in">Div2</span>(y)) &#123;</span><br><span class="line">		Pow[i]=<span class="number">1ll</span>*Pow[i<span class="number">-1</span>]*x%P;</span><br><span class="line">		IPow[i]=<span class="number">1ll</span>*IPow[i<span class="number">-1</span>]*y%P;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">V <span class="title">F</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) F[i]=<span class="number">1ll</span>*I[i]*IPow[i]%P;</span><br><span class="line">	F=F*F,F.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) F[i]=<span class="number">1ll</span>*F[i]*Pow[i]%P;</span><br><span class="line">	F=<span class="built_in">Sqrt</span>(F);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">int</span>(<span class="number">1ll</span>*F[i]*J[i]%P));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E6%9C%89%E6%A0%87%E5%8F%B7%E8%8D%92%E6%BC%A0%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<hr />
<p>title: '有标号荒漠计数' date: 'Sat Aug 12 11:05:29 2023 categories: -
oi-solutions'</p>
<h1 id="有标号荒漠计数">有标号荒漠计数</h1>
<p>考虑随意选择一个点为根，则仙人掌的 <span
class="math inline">\(\text{EGF}\)</span> 考虑用以下方式递归生成</p>
<p>令树边为二元环，则一个点周围的点都是都是与它直接相连的环</p>
<p>断开这个点，对于周围断开的环，环上每个点下面认为是一个仙人掌，设某个环断开之后的大小为
<span class="math inline">\(c\)</span></p>
<p>当 <span class="math inline">\(c=1\)</span>
时，不需要考虑排列重复，即为 <span
class="math inline">\(F(x)\)</span></p>
<p>当 <span class="math inline">\(c&gt;1\)</span>
时，考虑环正反排列，即为 <span
class="math inline">\(\cfrac{F^c(x)}{2}\)</span></p>
<p>那么就容易得到 <span class="math inline">\(\displaystyle F(x)=x \cdot
\text{exp}(F(x)+\sum _{i\ge 2}\frac{F^i(x)}{2})\)</span></p>
<p>变一下就是 <span class="math inline">\(\displaystyle F=x\cdot
\text{exp}(\frac{F^2}{2-2F}+F)=x\cdot
\text{exp}(\frac{2F-F^2}{2-2F})\)</span></p>
<p>是的，我们要解这个方方方方方方程。。。<a
href="https://www.cnblogs.com/chasedeath/p/12859142.html">牛顿迭代代代代代代代</a></p>
<p><span class="math inline">\(\displaystyle f(F(x))=x\cdot
\text{exp}(\frac{2F-F^2}{2-2F})-F=0\)</span></p>
<p><span class="math inline">\(\displaystyle f(z)=x\cdot
\text{exp}(\frac{2z-z^2}{2-2z})-z\)</span></p>
<p><span class="math inline">\(\displaystyle f&#39;(z)=x\cdot
\text{exp}(\frac{2z-z^2}{2-2z})(1+\frac{2z-z^2}{2z^2-4z+2})-1\)</span></p>
<p><span class="math inline">\(\displaystyle =x\cdot
\text{exp}(\frac{2z-z^2}{2-2z})(\frac{1}{2}+\frac{1}{2z^2-4z+2})-1\)</span></p>
<p>设上一层的迭代结果为 <span class="math inline">\(G(x)\)</span>
，带入牛顿迭代结论 <span class="math inline">\(\displaystyle
F(x)=G(x)-\frac{f(G)}{f&#39;(G)}\)</span></p>
<p>设 <span class="math inline">\(\displaystyle H=x\cdot
\text{exp}(\frac{2G-G^2}{2-2G})\)</span> ，那么得到Luogu题解里 <span
class="math inline">\(\text{N}\color{red}\text{aCl_Fish}\)</span>
一样的式子<del>(还要没有推错)</del></p>
<p><span class="math inline">\(\displaystyle
F=G-\frac{2H-2G}{H(1+\frac{1}{(1-G)^2})-2}\)</span></p>
<p>最后还要变成无根，除掉 <span class="math inline">\(n\)</span>
即可</p>
<p>仙人掌转荒漠您只需要一个 <span
class="math inline">\(\text{exp}\)</span> 就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">18</span>,N=<span class="number">1</span>&lt;&lt;L|<span class="number">10</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> I[N],J[N];</span><br><span class="line"><span class="type">int</span> rev[N],w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	w[<span class="number">1</span>&lt;&lt;(L<span class="number">-1</span>)]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">qpow</span>(<span class="number">3</span>,(P<span class="number">-1</span>)&gt;&gt;L);</span><br><span class="line">	<span class="built_in">rep</span>(i,(<span class="number">1</span>&lt;&lt;(L<span class="number">-1</span>))+<span class="number">1</span>,<span class="number">1</span>&lt;&lt;L) w[i]=<span class="number">1ll</span>*w[i<span class="number">-1</span>]*t%P;</span><br><span class="line">	<span class="built_in">drep</span>(i,(<span class="number">1</span>&lt;&lt;(L<span class="number">-1</span>))<span class="number">-1</span>,<span class="number">1</span>) w[i]=w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">rep</span>(i,J[<span class="number">0</span>]=<span class="number">1</span>,N<span class="number">-1</span>) J[i]=<span class="number">1ll</span>*J[i<span class="number">-1</span>]*i%P;</span><br><span class="line">	I[N<span class="number">-1</span>]=<span class="built_in">qpow</span>(J[N<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">drep</span>(i,N<span class="number">-1</span>,<span class="number">1</span>) I[i<span class="number">-1</span>]=<span class="number">1ll</span>*I[i]*i%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> R=<span class="number">1</span>,c=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(R&lt;=n) R&lt;&lt;=<span class="number">1</span>,c++;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;c);</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,V &amp;A,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> ull a[N];</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">int</span>)A.<span class="built_in">size</span>()&lt;n) A.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[rev[i]]=A[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> *e=w+i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">				<span class="type">int</span> t=a[j+i]*e[j-l]%P;</span><br><span class="line">				a[j+i]=a[j]+P-t;</span><br><span class="line">				a[j]+=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=a[i]%P,<span class="built_in">Mod2</span>(A[i]);</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">reverse</span>(A.<span class="built_in">begin</span>()+<span class="number">1</span>,A.<span class="built_in">end</span>());</span><br><span class="line">		ll base=<span class="number">1ll</span>*I[n]*J[n<span class="number">-1</span>]%P;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=A[i]*base%P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V <span class="keyword">operator</span> + (V a,<span class="type">const</span> V &amp;b) &#123;</span><br><span class="line">	<span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>()) a.<span class="built_in">resize</span>(b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,b.<span class="built_in">size</span>()<span class="number">-1</span>) a[i]+=b[i],<span class="built_in">Mod1</span>(a[i]);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> - (V a,<span class="type">const</span> V &amp;b) &#123;</span><br><span class="line">	<span class="keyword">if</span>(a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>()) a.<span class="built_in">resize</span>(b.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,b.<span class="built_in">size</span>()<span class="number">-1</span>) a[i]-=b[i],<span class="built_in">Mod2</span>(a[i]);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> * (V a,V b) &#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>()<span class="number">-1</span>,m=b.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> R=<span class="built_in">Init</span>(n+m);</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">1</span>),<span class="built_in">NTT</span>(R,b,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) a[i]=<span class="number">1ll</span>*a[i]*b[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">-1</span>),a.<span class="built_in">resize</span>(n+m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> * (V a,<span class="type">const</span> <span class="type">int</span> &amp;x) &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> &amp;i:a) i=<span class="number">1ll</span>*i*x%P;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> * (<span class="type">const</span> <span class="type">int</span> &amp;x,V a) &#123; <span class="keyword">return</span> a*x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">println</span><span class="params">(<span class="type">const</span> V &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:a) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">read</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="function">V <span class="title">A</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> ~ (V a) &#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>(),m=(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> &#123;(<span class="type">int</span>)<span class="built_in">qpow</span>(a[<span class="number">0</span>])&#125;;</span><br><span class="line">	V b=a; b.<span class="built_in">resize</span>(m),b=~b;</span><br><span class="line">	<span class="type">int</span> R=<span class="built_in">Init</span>(n*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">1</span>),<span class="built_in">NTT</span>(R,b,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) a[i]=(P+<span class="number">2</span><span class="number">-1ll</span>*a[i]*b[i]%P)*b[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">-1</span>),a.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">Deriv</span><span class="params">(V a)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,a.<span class="built_in">size</span>()<span class="number">-2</span>) a[i]=<span class="number">1ll</span>*(i+<span class="number">1</span>)*a[i+<span class="number">1</span>]%P;</span><br><span class="line">	a.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">Integ</span><span class="params">(V a)</span></span>&#123;</span><br><span class="line">	a.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">drep</span>(i,a.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>) a[i]=<span class="number">1ll</span>*a[i<span class="number">-1</span>]*J[i<span class="number">-1</span>]%P*I[i]%P;</span><br><span class="line">	a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">Ln</span><span class="params">(V a)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">	a=<span class="built_in">Deriv</span>(a)*~a;</span><br><span class="line">	<span class="keyword">return</span> a.<span class="built_in">resize</span>(n<span class="number">-1</span>),<span class="built_in">Integ</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">V <span class="title">Exp</span><span class="params">(V a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">assert</span>(a[<span class="number">0</span>]==<span class="number">0</span>),V&#123;<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">	V b=a; b.<span class="built_in">resize</span>((n+<span class="number">1</span>)/<span class="number">2</span>),b=<span class="built_in">Exp</span>(b),b.<span class="built_in">resize</span>(n);</span><br><span class="line">	a=a-<span class="built_in">Ln</span>(b),a[<span class="number">0</span>]++;</span><br><span class="line">	a=a*b,a.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V <span class="keyword">operator</span> &lt;&lt; (V a,<span class="type">int</span> x) &#123;</span><br><span class="line">	a.<span class="built_in">resize</span>(a.<span class="built_in">size</span>()+x);</span><br><span class="line">	<span class="built_in">drep</span>(i,a.<span class="built_in">size</span>()<span class="number">-1</span>,x) a[i]=a[i-x];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,x<span class="number">-1</span>) a[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">V <span class="keyword">operator</span> &gt;&gt; (V a,<span class="type">int</span> x) &#123;</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">int</span>)a.<span class="built_in">size</span>()&lt;=x) <span class="keyword">return</span> V&#123;&#125;;</span><br><span class="line">	<span class="built_in">rep</span>(i,x,a.<span class="built_in">size</span>()<span class="number">-1</span>) a[i-x]=a[i];</span><br><span class="line">	a.<span class="built_in">resize</span>(a.<span class="built_in">size</span>()-x);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">Newton</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> V&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> V&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	V G=<span class="built_in">Newton</span>((n+<span class="number">1</span>)/<span class="number">2</span>); G.<span class="built_in">resize</span>(n);</span><br><span class="line">	V IG=~(V&#123;<span class="number">1</span>&#125;-G);</span><br><span class="line">	V H=(<span class="number">2</span>*G-G*G); H.<span class="built_in">resize</span>(n),H=H*IG*((P+<span class="number">1</span>)/<span class="number">2</span>),H.<span class="built_in">resize</span>(n),H=<span class="built_in">Exp</span>(H)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	V F=IG*IG; F.<span class="built_in">resize</span>(n),F[<span class="number">0</span>]++;</span><br><span class="line">	F=H*F,F.<span class="built_in">resize</span>(n),F[<span class="number">0</span>]-=<span class="number">2</span>,<span class="built_in">Mod2</span>(F[<span class="number">0</span>]);</span><br><span class="line">	F=G<span class="number">-2</span>*(H-G)*~F;</span><br><span class="line">	<span class="keyword">return</span> F.<span class="built_in">resize</span>(n),F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">rd</span>()+<span class="number">1</span>; <span class="built_in">Init</span>();</span><br><span class="line">	V F=<span class="built_in">Newton</span>(n); </span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,F.<span class="built_in">size</span>()<span class="number">-1</span>) F[i]=<span class="number">1ll</span>*F[i]*I[i]%P*J[i<span class="number">-1</span>]%P;</span><br><span class="line">	F=<span class="built_in">Exp</span>(F);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">int</span>(<span class="number">1ll</span>*F.<span class="built_in">back</span>()*J[n<span class="number">-1</span>]%P));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/%E9%AD%94%E5%A1%94%20OL/</url>
    <content><![CDATA[<hr />
<p>title: '「北大集训 2021」魔塔 OL | CTT2022 D1 T2' date: 'Sat Aug 12
11:05:29 2023 categories: - oi-solutions'</p>
<h1 id="北大集训-2021魔塔-ol-ctt2022-d1-t2">「北大集训 2021」魔塔 OL |
CTT2022 D1 T2</h1>
<h3 id="题目大意">题目大意</h3>
<p>维护 <span class="math inline">\(q\)</span> 个操作：</p>
<ol type="1">
<li><p>在序列末尾新增一个点 <span class="math inline">\((x,y,z)\)</span>
，其权值为 <span class="math inline">\((a,b)\)</span> 。</p></li>
<li><p>删除序列中编号为 <span class="math inline">\(k\)</span>
的点（不影响其他点编号）。</p></li>
<li><p>仅保留序列中三维分别在 <span class="math inline">\(g,l,d\)</span>
以内的点，做询问：</p>
<p>每一个点是一只怪物，击杀他需要 <span class="math inline">\(a\)</span>
的血量，击杀后会恢复 <span class="math inline">\(b\)</span> 的血量。</p>
<p>求击杀当前序列中所有怪物需要的最少初始血量。</p></li>
</ol>
<h3 id="简要分析">简要分析</h3>
<p>先不考虑三维偏序的部分，对于序列 <span
class="math inline">\(a_i,b_i\)</span> 做贪心：</p>
<p>考虑相邻交换，若交换 <span class="math inline">\(i,j\
(j=i+1)\)</span> 更优，则满足： <span class="math display">\[
\max\{a_i,a_j+a_i-b_i\}&gt;\max\{a_j,a_i+a_j-b_j\}
\\
即 (a_i&gt;a_j \and a_i&gt;a_i+a_j-b_j) \or (a_j+a_i-b_i&gt;a_j \and
a_j+a_i-b_i&gt;a_i+a_j-b_j)
\\
即 (a_j-b_j&lt;0 \and a_i&gt;a_j) \or (a_i-b_i&gt;0 \and b_j&gt;b_i)
\]</span> 具体排序方式即：</p>
<ol type="1">
<li><span class="math inline">\(a_i-b_i&lt;0\)</span> 的放在前面，按照
<span class="math inline">\(a_i&gt;a_j\)</span> 排序。</li>
<li><span class="math inline">\(a_i-b_i&gt;0\)</span> 的放在后面，按照
<span class="math inline">\(b_j&gt;b_i\)</span> 排序。</li>
</ol>
<p>连续的二元组 <span class="math inline">\((a_i,b_i)\)</span>
容易合并为 <span class="math inline">\((a&#39;,b&#39;)\)</span>
，分别为：最大值，总和。</p>
<p>离线所有点，按照上述方式排序，将得到的序列每 <span
class="math inline">\(B\)</span> 个分一块，每一个块维护所有 <span
class="math inline">\(2^B\)</span> 种情况对应的二元组和。</p>
<p>对于第 <span class="math inline">\(i\)</span> 个块，维护 <span
class="math inline">\(3\)</span> 组集合：</p>
<ol type="1">
<li><span class="math inline">\(x\leq u\)</span> 的集合 <span
class="math inline">\(A_{i,u}\)</span> 。</li>
<li><span class="math inline">\(y\leq v\)</span> 的集合 <span
class="math inline">\(B_{i,v}\)</span> 。</li>
<li><span class="math inline">\(z\leq w\)</span> 的集合 <span
class="math inline">\(C_{i,w}\)</span> 。</li>
</ol>
<p>在操作时，动态维护集合 <span class="math inline">\(S\)</span>
表示当前在整个序列里的点。</p>
<p>查询时对于每一个块，求出 <span class="math inline">\(S\ \cap A_{i,g}\
\cap B_{i,l}\ \cap C_{i,d}\)</span> ，然后处理对应集合。</p>
<p>设 <span class="math inline">\(n\)</span> 为怪物总数， <span
class="math inline">\(x\)</span> 为三维的值域，复杂度为 <span
class="math inline">\(O(n\log n+\frac{nx}{B}+\frac{n\cdot
2^B}{B}+q\frac{n}{B})\)</span></p>
<p><span class="math inline">\(B\)</span> 大致取 <span
class="math inline">\(\log n\)</span> 即可。</p>
<p>ans[i]=(a,b)</p>
<p>[i,i+B)</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/Atcoder/ARC089D%20-%20ColoringBalls/</url>
    <content><![CDATA[<hr />
<p>title: 'ARC089D - ColoringBalls' date: 'Sat Aug 12 11:05:24 2023
categories: - oi-solutions'</p>
<h1 id="arc089d---coloringballs">ARC089D - ColoringBalls</h1>
<h4 id="题目大意">题目大意</h4>
<p>有一排 <span class="math inline">\(n\)</span>
个球，一开始都是白色的。</p>
<p>然后有 <span class="math inline">\(m\)</span>
次操作，用一个字符串表示，若第 <span class="math inline">\(i\)</span>
个字符为<code>r/b</code>则表示可以选择一段区间染成 红色/蓝色。</p>
<p>不能直接把一个白球染成蓝色。</p>
<p>求最终不同的球染色情况的个数 <span class="math inline">\(\mod
10^9+7\)</span> 。</p>
<p><br></p>
<h4 id="分析">分析</h4>
<p>下文视 <span class="math inline">\(n,m\)</span> 同 阶。</p>
<p>分析最终态，总可以描述为若干连续的红蓝段，中间由白色分开。</p>
<p>如果确定了每一个红蓝段的长度和交错情况，然后再在 <span
class="math inline">\(n\)</span>
个位置里分配就能得到方案数，因此可以先忽略每一段的长度来进行考虑。</p>
<p>对于每一个红蓝段，可以分成两类：</p>
<ol type="1">
<li><p>只出现了红色，称这样的段为单一段。</p></li>
<li><p>出现了蓝色，不一定出现红色，称这样的段为复合段。</p>
<p>考虑这样的段如何构造得到：</p>
<ol type="1">
<li>先染了一次红色</li>
<li>然后染了一次蓝色</li>
<li>接下来的每一次操作，无论染红色还是蓝色，均可以使得交替次数 <span
class="math inline">\(+2\)</span> 。</li>
</ol>
<p>而最终得到的段，交替段的两端的红色段可以为空。</p></li>
</ol>
<p>为了包含到所有情况，并且不算重，构造方案时必然需要<strong>贪心地考虑</strong>。</p>
<p>可以先枚举有 <span class="math inline">\(a\)</span> 个复合段， <span
class="math inline">\(b\)</span> 个单一段。</p>
<p>贪心地将前 <span class="math inline">\(a+b\)</span> 个 <code>r</code>
操作用以新建一个段， <span class="math inline">\(a\)</span>
个复合段对应着前 <span class="math inline">\(a\)</span> 个
<code>r</code>。</p>
<p>然后再为每一个复合段贪心地匹配后面的第一个 <code>b</code> 操作，记作
<span class="math inline">\((pos_i,match_i),i\in[1,a]\)</span> 。</p>
<p>那么对于剩下的 <code>r/b</code>，每一个操作均可以对于 <span
class="math inline">\(a\)</span>
个中的某一些进行，称这样的<code>r/b</code>为自由的。</p>
<p>对于每一个自由的<code>b</code>，设其位置为 <span
class="math inline">\(j\)</span> ，其能操作的段 <span
class="math inline">\((pos_i,match_i)\)</span> 必然满足 <span
class="math inline">\(pos_i&lt;j\)</span> 。</p>
<p>对于每一个自由的<code>r</code>，设其位置为 <span
class="math inline">\(j\)</span> ，其能操作的段 <span
class="math inline">\((pos_i,match_i)\)</span> 必然满足 <span
class="math inline">\(match_i&lt;j\)</span> 。</p>
<p>对于 <span class="math inline">\(a\)</span>
个复合段，容易求得它们各自能得到的自由操作数量，记作 <span
class="math inline">\(c_i\)</span> ，显然 <span
class="math inline">\(c_i\ge c_{i+1}\)</span> 。</p>
<p>设每一个段被操作了 <span class="math inline">\(b_i\)</span>
次，满足条件的方案只需要满足 <span class="math inline">\(c_i\ge
\sum_{j=i} b_j\)</span> 。</p>
<p>而我们只需考虑 <span class="math inline">\(b_i\ge b_{i+1}\)</span>
的方案，因为这样的方案更容易被满足。</p>
<p>其次还需要考虑这 <span class="math inline">\(a+b\)</span>
个段之间的相对顺序：</p>
<ol type="1">
<li><span class="math inline">\(b\)</span> 个单一段等价，无顺序；</li>
<li><span class="math inline">\(a\)</span> 个复合段根据 <span
class="math inline">\(b_i\)</span> 分类， <span
class="math inline">\(b_i\)</span>
相同的段之间等价，需要在方案中除掉个数的阶乘。</li>
<li>最终还需要将 <span class="math inline">\(a,b\)</span>
两部分归并。</li>
</ol>
<p>考虑倒着处理 <span class="math inline">\(dp_{i,j,k}\)</span>
表示考虑了 <span class="math inline">\([i,a]\)</span> 这些复合段， <span
class="math inline">\(b_i=j\)</span> ， <span
class="math inline">\(\sum_{l=j} b_l=k\)</span> 。</p>
<p>每次枚举一个 <span class="math inline">\(b_i\)</span>
相同的段进行转移，即 <span class="math display">\[
dp_{i,j,k}\leftarrow \sum_{d=1} \frac{1}{d!}\sum_{l=0}^{j-1}
dp_{i+d,l,k+jd} \cdot [\ \forall p\in[0,d), k-jp\leq c_{i+p}]
\]</span> 可以在 <span class="math inline">\(j\)</span>
这一维上前缀和优化，剩余的部分转移复杂度的一个上界为 <span
class="math inline">\(O(n^3\ln n)\)</span> 。</p>
<p>最终还需要将 <span class="math inline">\(a,b\)</span>
两部分归并，并且将 <span class="math inline">\(n\)</span>
个位置分配到每一个段中。</p>
<p>如果最终的方案额外加入了 <span class="math inline">\(i\)</span>
个自由操作，则每一个段可以两类。</p>
<ol type="1">
<li>可以为空的段：
<ul>
<li>每一个复合段两端的红色段；</li>
<li>序列两端的白色段。</li>
</ul></li>
<li>不能为空的段：
<ul>
<li>每一个复合段中间的段；</li>
<li>每一个单一段；</li>
<li>每一个交替段之间的白色段。</li>
</ul></li>
</ol>
<p>这是一个简单的插板问题，可以用组合数在 <span
class="math inline">\(O(1)\)</span> 时间求解。</p>
<p>而需要枚举 <span class="math inline">\(O(n^2)\)</span> 个 <span
class="math inline">\(a,b\)</span> ，每次需要 <span
class="math inline">\(O(n^3\ln n)\)</span> 的 <span
class="math inline">\(\text{dp}\)</span> ，故总复杂度为 <span
class="math inline">\(O(n^5\ln n)\)</span> 。</p>
<p>实际上这个上界非常松，可以随意通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">    T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) f|=IO==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">72</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> Com[N*<span class="number">4</span>][N*<span class="number">4</span>],J[N],I[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> R[N],mk[N],C[N],pos[N],c;</span><br><span class="line"><span class="comment">// R[i] 表示第i个复合段匹配的第一个b</span></span><br><span class="line"><span class="comment">// pos 表示每一个a出现的位置</span></span><br><span class="line"><span class="comment">// C[i] 表示每一个复合r之后的自由点个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    a+=b,<span class="built_in">Mod1</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举 a 个复合段，b个单一段</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Calc</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a &amp;&amp; !b) &#123; ans++; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,a) <span class="keyword">if</span>(R[i]&gt;m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) mk[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,a) mk[R[i]]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,a+<span class="number">1</span>) C[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 为自由的b找到能放置的第一个复合点</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>(s[i]==<span class="string">&#x27;b&#x27;</span> &amp;&amp; !mk[i]) &#123;</span><br><span class="line">        <span class="built_in">drep</span>(j,a,<span class="number">1</span>) <span class="keyword">if</span>(pos[j]&lt;i) &#123;</span><br><span class="line">            C[j]++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为自由的r找到能放置的第一个复合点</span></span><br><span class="line">    <span class="built_in">rep</span>(i,a+b+<span class="number">1</span>,c) &#123;</span><br><span class="line">        <span class="built_in">drep</span>(j,a,<span class="number">1</span>) <span class="keyword">if</span>(R[j]&lt;pos[i]) &#123;</span><br><span class="line">            C[j]++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> dp[N][N][N];</span><br><span class="line">    <span class="comment">// dp[i][j]表示上一个放了i个，一共放了j个，处理掉分母的count[i]!</span></span><br><span class="line">    <span class="comment">// 每次枚举一段，且都放了k个</span></span><br><span class="line">    dp[a+<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">drep</span>(i,a<span class="number">-1</span>,<span class="number">1</span>) C[i]+=C[i+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">drep</span>(i,a,<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">0</span>,C[i]) <span class="built_in">rep</span>(k,<span class="number">0</span>,C[i]) dp[i][j][k]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(k,<span class="number">1</span>,C[i]) &#123;</span><br><span class="line">            <span class="type">int</span> up=C[i];</span><br><span class="line">            <span class="built_in">rep</span>(j,i,a) &#123;</span><br><span class="line">                up=<span class="built_in">min</span>(up-k,C[j]-k);</span><br><span class="line">                <span class="keyword">if</span>(up&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="built_in">rep</span>(d,<span class="number">0</span>,<span class="built_in">min</span>(up,C[j+<span class="number">1</span>])) <span class="built_in">Add</span>(dp[i][k][d+k*(j-i+<span class="number">1</span>)],<span class="number">1ll</span>*dp[j+<span class="number">1</span>][<span class="built_in">min</span>(k<span class="number">-1</span>,C[j+<span class="number">1</span>])][d]*I[j-i+<span class="number">1</span>]%P);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>]=I[a-i+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,C[i]) <span class="built_in">rep</span>(k,<span class="number">0</span>,C[i]) <span class="built_in">Add</span>(dp[i][j][k],dp[i][j<span class="number">-1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,C[<span class="number">1</span>]) <span class="keyword">if</span>(dp[<span class="number">1</span>][C[<span class="number">1</span>]][i]) &#123;</span><br><span class="line">        <span class="comment">// 计算可以为0的段数以及不可以为0的段数</span></span><br><span class="line">        <span class="type">int</span> c1=<span class="number">2</span>+a*<span class="number">2</span>; <span class="comment">// 两端的黑段，每一个非单一段两端的红段</span></span><br><span class="line">        <span class="type">int</span> c2=a+b<span class="number">-1</span>+a+i*<span class="number">2</span>+b; <span class="comment">// 中间的每一个黑段，每一个非单一段除了红段以外的段，每一个单一段</span></span><br><span class="line">        <span class="keyword">if</span>(c2&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">        ans=(ans+<span class="number">1ll</span>*Com[n+c1<span class="number">-1</span>][c1+c2<span class="number">-1</span>]%P*J[a]%P*Com[a+b][a]%P*dp[<span class="number">1</span>][C[<span class="number">1</span>]][i])%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,N*<span class="number">4</span><span class="number">-1</span>) <span class="built_in">rep</span>(j,*Com[i]=<span class="number">1</span>,i) Com[i][j]=Com[i<span class="number">-1</span>][j]+Com[i<span class="number">-1</span>][j<span class="number">-1</span>],<span class="built_in">Mod1</span>(Com[i][j]);</span><br><span class="line">    <span class="built_in">rep</span>(i,*J=<span class="number">1</span>,N<span class="number">-1</span>) J[i]=<span class="number">1ll</span>*J[i<span class="number">-1</span>]*i%P;</span><br><span class="line">    I[N<span class="number">-1</span>]=<span class="built_in">qpow</span>(J[N<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">drep</span>(i,N<span class="number">-1</span>,<span class="number">1</span>) I[i<span class="number">-1</span>]=<span class="number">1ll</span>*I[i]*i%P;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>(s[i]==<span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">        pos[++c]=i;</span><br><span class="line">        <span class="built_in">cmax</span>(j,i),j++;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=m &amp;&amp; s[j]!=<span class="string">&#x27;b&#x27;</span>) j++;</span><br><span class="line">        R[c]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(a,<span class="number">0</span>,c) <span class="built_in">rep</span>(b,<span class="number">0</span>,c-a) <span class="keyword">if</span>((a+b)*<span class="number">2</span><span class="number">-1</span>&lt;=n) &#123;</span><br><span class="line">        <span class="built_in">Calc</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/Atcoder/ARC114%20-%20Sequence%20Scores/</url>
    <content><![CDATA[<hr />
<p>title: 'ARC114 - Sequence Scores' date: 'Sat Aug 12 11:05:24 2023
categories: - oi-solutions'</p>
<h1 id="arc114---sequence-scores">ARC114 - Sequence Scores</h1>
<p>题目大意：对于一个序列 <span
class="math inline">\(A=a_i,a_i\in[1,m]\)</span> ，定义 <span
class="math inline">\(f(A)\)</span> 为</p>
<p>对于一个全零的初始序列，每次选择一个区间对于某一个值取 <span
class="math inline">\(\max\)</span> ，最少生成 <span
class="math inline">\(A\)</span> 的步数</p>
<p>求所有 <span class="math inline">\(m^n\)</span> 种 <span
class="math inline">\(A\)</span> 的 <span
class="math inline">\(f(A)\)</span> 之和</p>
<p>首先考虑 <span class="math inline">\(f(A)\)</span>
的计算，显然可以采用如下方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b[i]=0</span><br><span class="line">Function Solve(l,r)</span><br><span class="line">	v=min a[l..r]</span><br><span class="line">	for i in l,r</span><br><span class="line">		b[i]=max&#123;b[i],v&#125;</span><br><span class="line">	Divide a[l..r] into contiguous ranges that a[i]!=b[i] , Solve(l&#x27;,r&#x27;)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>那么考虑计算一个区间 <span class="math inline">\([l,r]\)</span> 被
<span class="math inline">\(\text{Solve}\)</span> 的次数</p>
<p>显然区间 <span class="math inline">\([l,r]\)</span> 被 <span
class="math inline">\(\text{Solve}\)</span> 当且仅当</p>
<p><span
class="math inline">\(\min\{a_i|i\in[l,r]\}&gt;\max(a_{l-1},a_{r+1})\)</span></p>
<p>对于不同的 <span class="math inline">\(r-l+1\)</span> ，枚举 <span
class="math inline">\(\min\)</span> ，计算方案数即可</p>
<p>注意考虑 <span class="math inline">\(l=1\or r=n\)</span>
的边界情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> Pow[N][N],F[N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,N<span class="number">-1</span>) <span class="built_in">rep</span>(j,*Pow[i]=<span class="number">1</span>,N<span class="number">-1</span>) Pow[i][j]=<span class="number">1ll</span>*Pow[i][j<span class="number">-1</span>]*i%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">2</span>) <span class="built_in">rep</span>(k,<span class="number">1</span>,m) &#123;</span><br><span class="line">		F[i][j]=(F[i][j]+<span class="number">1ll</span>*(Pow[m-k+<span class="number">1</span>][i]-Pow[m-k][i]+P)*Pow[k<span class="number">-1</span>][j])%P;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,i,n) &#123;</span><br><span class="line">		<span class="type">int</span> c=(i&gt;<span class="number">1</span>)+(j&lt;n);</span><br><span class="line">		ans=(ans+<span class="number">1ll</span>*F[j-i+<span class="number">1</span>][c]*Pow[m][n-(j-i+<span class="number">1</span>)-c])%P;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/Atcoder/ARC114%20-%20Paper%20Cutting%202/</url>
    <content><![CDATA[<hr />
<p>title: 'ARC114 - Paper Cutting 2' date: 'Sat Aug 12 11:05:24 2023
categories: - oi-solutions'</p>
<h1 id="arc114---paper-cutting-2">ARC114 - Paper Cutting 2</h1>
<h3 id="题目大意">题目大意：</h3>
<p>在一张方格图上确定了一个矩形，每次操作选择一条两行或者两列之间的线将图切开</p>
<p>如果切开了矩形就停止，否则将包含矩形的一部分保留</p>
<p>问期望多少步停止</p>
<p><br></p>
<p><br></p>
<p>（如果你熟练掌握概率的独立性，这道题非常简单）</p>
<p>称矩形内部的横竖线为<strong>关键线</strong></p>
<p>考虑对于每一个横线|竖线计算其被切的概率，以矩形右边的一条竖线为例</p>
<p>那么在这条竖线右边的线，以及在矩形左边的线，矩形上下的横线
都与其独立</p>
<p>也就是说，概率就是：</p>
<p>这条竖线左边且在矩形右边的线和所有<strong>关键线</strong>之中，这条线是<strong>第一个被切掉</strong>的概率</p>
<p>那么数一下上面提到所有线的个数 <span class="math inline">\(c\)</span>
，概率就是 <span class="math inline">\(\frac{1}{c}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> I[N];</span><br><span class="line"><span class="type">int</span> a,b,c,d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	I[<span class="number">0</span>]=I[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-1</span>) I[i]=<span class="number">1ll</span>*(P-P/i)*I[P%i]%P;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	a=<span class="built_in">rd</span>(),b=<span class="built_in">rd</span>(),c=<span class="built_in">rd</span>(),d=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="keyword">if</span>(a&gt;c) <span class="built_in">swap</span>(a,c);</span><br><span class="line">	<span class="keyword">if</span>(b&gt;d) <span class="built_in">swap</span>(b,d);</span><br><span class="line">	<span class="type">int</span> e=c-a+d-b,ans=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,a<span class="number">-1</span>) ans=(ans+I[a-i+e])%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,c+<span class="number">1</span>,n) ans=(ans+I[i-c+e])%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,b<span class="number">-1</span>) ans=(ans+I[b-i+e])%P;</span><br><span class="line">	<span class="built_in">rep</span>(i,d+<span class="number">1</span>,m) ans=(ans+I[i-d+e])%P;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/Atcoder/ARC114%20Moving%20Pieces%20on%20Line/</url>
    <content><![CDATA[<hr />
<p>title: 'ARC114 - Moving Pieces on Line' date: 'Sat Aug 12 11:05:24
2023 categories: - oi-solutions'</p>
<h1 id="arc114---moving-pieces-on-line">ARC114 - Moving Pieces on
Line</h1>
<h3 id="题目大意">题目大意：</h3>
<p>白色的数轴上有 <span class="math inline">\(n\)</span> 个球 <span
class="math inline">\(a_i\)</span> ，给定若干递增且不交的区间 <span
class="math inline">\([t_i,t_{i+1})\)</span></p>
<p>每次选择一个球向左或者向右滚，且将滚过的一段反色</p>
<p>求最小步数恰好仅将给定区间染黑色，或者确定不存在方案</p>
<h3 id="模型转化">模型转化</h3>
<p>首先显然可以发现，每个小球只会滚过一段区间一次</p>
<p>设小球 <span class="math inline">\(i\)</span> 最终停在 <span
class="math inline">\(b_i\)</span> ，则滚过这段数轴会被反色，且代价为
<span class="math inline">\(|a_i-b_i|\)</span></p>
<p>将最终颜色做<strong>异或差分</strong>，那么对于目标的反色，我们认为就是在每个
<span class="math inline">\(t_i\)</span> 处放置了一个1</p>
<p>而对于所有 <span class="math inline">\(a_i\)</span> ，就是在 <span
class="math inline">\(a_i,b_i\)</span>
处分别放置了一个1，这样就完全避免了关于 <span
class="math inline">\(a_i,b_i\)</span> 大小关系的问题</p>
<h3 id="计算答案">计算答案</h3>
<p>由于已经固定了 <span class="math inline">\(a_i\)</span> (设 <span
class="math inline">\(a_i\)</span> 已经排好序)，我们需要决策 <span
class="math inline">\(b_i\)</span></p>
<p>那么可以预先得到哪些位置需要放置奇数个 <span
class="math inline">\(b_i\)</span> ，设这个集合为 <span
class="math inline">\(pos\)</span></p>
<p>若 <span class="math inline">\(|pos|&gt;n\)</span> ，显然无解</p>
<p>否则， <span class="math inline">\(b_i\)</span>
的放置仅有两种情况</p>
<p>1.放在某一个 <span class="math inline">\(pos_i\)</span> 处</p>
<p>2.让两个 <span class="math inline">\(b_i\)</span> 放在同一个位置</p>
<p>对于 <span class="math inline">\(a,pos\)</span>
排序之后的情况，显然较小的 <span class="math inline">\(a_i\)</span>
会匹配较小的 <span class="math inline">\(pos_i\)</span> ，代价为 <span
class="math inline">\(|a_i-pos_i|\)</span></p>
<p>而情况2用掉的两个 <span class="math inline">\(b_i\)</span> ，选择使用
<span class="math inline">\(b_i,b_{i+1}\)</span> 一定不劣，并且代价就是
<span class="math inline">\(a_{i+1}-a_i\)</span></p>
<p>那么令 <span class="math inline">\(dp_{i,j}\)</span> 表示前 <span
class="math inline">\(i\)</span> 个 <span
class="math inline">\(a_i\)</span> ，已经匹配了 <span
class="math inline">\(j\)</span> 个 <span
class="math inline">\(pos_j\)</span> 的代价，如上决策即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) f|=IO==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line">ll dp[N][N];</span><br><span class="line"><span class="type">int</span> h[N*<span class="number">2</span>],hc;</span><br><span class="line"><span class="type">int</span> s[N*<span class="number">2</span>],t[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> pos[N*<span class="number">2</span>],c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">rd</span>(),h[++hc]=a[i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) b[i]=<span class="built_in">rd</span>(),h[++hc]=b[i];</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(h+<span class="number">1</span>,h+hc+<span class="number">1</span>),hc=<span class="built_in">unique</span>(h+<span class="number">1</span>,h+hc+<span class="number">1</span>)-h<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		a[i]=<span class="built_in">lower_bound</span>(h+<span class="number">1</span>,h+hc+<span class="number">1</span>,a[i])-h;</span><br><span class="line">		s[a[i]]^=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		b[i]=<span class="built_in">lower_bound</span>(h+<span class="number">1</span>,h+hc+<span class="number">1</span>,b[i])-h;</span><br><span class="line">		t[b[i]]^=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,hc) <span class="keyword">if</span>(s[i]^t[i]) pos[++c]=i;</span><br><span class="line">	<span class="keyword">if</span>(c&gt;n || (n-c)&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">63</span>,<span class="keyword">sizeof</span> dp),dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="built_in">min</span>(i,c)) &#123;</span><br><span class="line">		<span class="keyword">if</span>(j&lt;c) <span class="built_in">cmin</span>(dp[i][j+<span class="number">1</span>],dp[i<span class="number">-1</span>][j]+<span class="built_in">abs</span>(h[a[i]]-h[pos[j+<span class="number">1</span>]]));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;n) <span class="built_in">cmin</span>(dp[i+<span class="number">1</span>][j],dp[i<span class="number">-1</span>][j]+h[a[i+<span class="number">1</span>]]-h[a[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[n][c]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/Atcoder/ARC115%20#D/</url>
    <content><![CDATA[<hr />
<p>title: '<a href="https://atcoder.jp/contests/arc115">AtCoder Regular
Contest 115</a> #D' date: 'Sat Aug 12 11:05:24 2023 categories: -
oi-solutions'</p>
<h1 id="atcoder-regular-contest-115-d"><a
href="https://atcoder.jp/contests/arc115">AtCoder Regular Contest
115</a> #D</h1>
<h3 id="solution1">Solution1</h3>
<p>考虑用 <span class="math inline">\(\text{FWT}\)</span>
来理解这个式子，容易发现 <span class="math inline">\(\text{FWT}\)</span>
之后求积的式子，满足</p>
<p>对于任意 <span class="math inline">\((u_i,v_i)\)</span></p>
<p>如果 <span class="math inline">\(u_i,v_i\)</span>
中有一者被选择，答案为0，否则权值 <span class="math inline">\(\times
2\)</span></p>
<p>那么显然对于一个连通块，设其大小为 <span
class="math inline">\(c\)</span> ，放在一起考虑</p>
<p>在 <span class="math inline">\(\text{FWT}\)</span>
的式子里它们同时出现或者同时不出现</p>
<p>枚举最后 <span class="math inline">\(\text{FWT}\)</span>
回来时的项与在这 <span class="math inline">\(c\)</span> 个位置中出现
<span class="math inline">\(i\)</span> 个</p>
<p>对于选择这个连通块的情况，贡献为 <span
class="math inline">\((-1)^i\)</span></p>
<p>对于不选的情况，贡献为 <span class="math inline">\(1\)</span></p>
<p>显然只有 <span class="math inline">\(2|i\)</span>
时贡献为2，乘上组合数完成转移，连通块之间背包合并</p>
<p>就能得到最终计算答案的项中出现了几个1，然后与 <span
class="math inline">\(\text{FWT}\)</span> 的系数合并即可</p>
<p><span class="math display">\[  \ \]</span></p>
<h3 id="solution2">Solution2</h3>
<p>对于一个连通块，考虑取出一个生成树</p>
<p>容易发现，仅使用这个生成树上的边，就能构成任何一个包含 <span
class="math inline">\(2k\)</span> 个奇点的情况</p>
<p>对于多余的边，类似异或线性基，它们都是可选可不选的</p>
<p>于是直接统计答案即可</p>
<p>Sol1 和 Sol2 的式子是一样的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>,P=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n,m,dp[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span></span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> c,vis[N],C[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[u]) <span class="keyword">return</span>;</span><br><span class="line">	vis[u]=<span class="number">1</span>,c++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:G[u]) <span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) <span class="built_in">rep</span>(j,*C[i]=<span class="number">1</span>,i) C[i][j]=C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>],<span class="built_in">Mod1</span>(C[i][j]);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>();</span><br><span class="line">		G[u].<span class="built_in">pb</span>(v),G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(u,<span class="number">1</span>,n) <span class="keyword">if</span>(!vis[u]) &#123;</span><br><span class="line">		c=<span class="number">0</span>,<span class="built_in">dfs</span>(u);</span><br><span class="line">		<span class="built_in">drep</span>(i,n,<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="built_in">min</span>(i,c)) <span class="keyword">if</span>(~j&amp;<span class="number">1</span>) &#123;</span><br><span class="line">				s=(s+<span class="number">2ll</span>*dp[i-j]*C[c][j])%P;</span><br><span class="line">			&#125;</span><br><span class="line">			dp[i]=s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> d=<span class="built_in">qpow</span>(<span class="number">2</span>,P<span class="number">-1</span>-n+m);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">int</span>(<span class="number">1ll</span>*dp[i]*d%P));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/Atcoder/ARC117%20-%20Miracle%20Tree/</url>
    <content><![CDATA[<hr />
<p>title: 'ARC 117 - Miracle Tree' date: 'Sat Aug 12 11:05:24 2023
categories: - oi-solutions'</p>
<h1 id="arc-117---miracle-tree">ARC 117 - Miracle Tree</h1>
<p><del>话说我只能蒙结论。。。</del></p>
<p>打表或者理性分析可以发现一些性质</p>
<ol type="1">
<li><span class="math inline">\(\nexists E_i=E_j\)</span></li>
</ol>
<p>2.如果确定 <span class="math inline">\(E_i\)</span> 从小到大的顺序
<span class="math inline">\(P_i\)</span> ，就能确定一组最优的 <span
class="math inline">\(E_i\)</span></p>
<p>（但是对于平凡的 <span class="math inline">\(P_i\)</span>
，这个过程会极其恶心，因此考虑特殊化 <span
class="math inline">\(P_i\)</span> ）</p>
<p>3.设 <span class="math inline">\(\displaystyle f(P)=\sum_{i=2}^n
dis(P_{i-1},P_i)\)</span> ，即遍历排列的距离和</p>
<p>则 <span class="math inline">\(\max\{E_i\}\ge
\min\{f(P)\}+1\)</span></p>
<p><del>显然</del></p>
<p>由此确定了一个下界，接下来将说明可以取到下界</p>
<p>1.对于一个排列 <span class="math inline">\(P_{i}\)</span> ，如果
<span class="math inline">\(P_i\)</span> 是一组 <span
class="math inline">\(\text{dfs}\)</span> 序，那么满足 <span
class="math inline">\(\max\{E_i\}=f(P)+1\)</span> (容易模拟发现)</p>
<ol start="2" type="1">
<li><span class="math inline">\(\min\{f(P)\}\)</span> 在 <span
class="math inline">\((P_1,P_n)\)</span>
恰好为一条直径时取到，显然存在这样一组 <span
class="math inline">\(\text{dfs}\)</span> 序满足要求</li>
</ol>
<p>由此确定了答案 <span class="math inline">\(P\)</span>
可以是任何一组以某一条直径两个端点为 <span
class="math inline">\(P_1,P_n\)</span> 的 <span
class="math inline">\(\text{dfs}\)</span> 序</p>
<p>容易给出一个合法解，代码实现极为暴力</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> F[N][<span class="number">20</span>],D[N],E[N];</span><br><span class="line"><span class="type">int</span> ma=<span class="number">-1</span>,id;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(D[u]&gt;ma) ma=D[u],id=u;</span><br><span class="line">	F[u][<span class="number">0</span>]=f,E[u]=D[u];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">18</span>) F[u][i]=F[F[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:G[u]) <span class="keyword">if</span>(v!=f) D[v]=D[u]+<span class="number">1</span>,<span class="built_in">dfs</span>(v,u),<span class="built_in">cmax</span>(E[u],E[v]);</span><br><span class="line">	<span class="built_in">sort</span>(G[u].<span class="built_in">begin</span>(),G[u].<span class="built_in">end</span>(),[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123; <span class="keyword">return</span> E[x]&lt;E[y]; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(D[x]&lt;D[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> del=D[x]-D[y],i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=del;++i) <span class="keyword">if</span>(del&amp;(<span class="number">1</span>&lt;&lt;i)) x=F[x][i];</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="built_in">drep</span>(i,<span class="number">18</span>,<span class="number">0</span>) <span class="keyword">if</span>(F[x][i]!=F[y][i]) x=F[x][i],y=F[y][i];</span><br><span class="line">	<span class="keyword">return</span> F[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dis</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123; <span class="keyword">return</span> D[x]+D[y]<span class="number">-2</span>*D[<span class="built_in">LCA</span>(x,y)]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lst;</span><br><span class="line">ll A[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!lst) A[lst=u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> A[u]=A[lst]+<span class="built_in">Dis</span>(lst,u),lst=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:G[u]) <span class="keyword">if</span>(v!=f) <span class="built_in">dfs2</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n) &#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>();</span><br><span class="line">		G[u].<span class="built_in">pb</span>(v),G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> u=id;</span><br><span class="line">	<span class="built_in">dfs</span>(u,<span class="number">0</span>),<span class="built_in">dfs2</span>(u,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,A[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/Atcoder/ARC117%20-%20Tricolor%20Pyramid/</url>
    <content><![CDATA[<hr />
<p>title: 'ARC117 - Tricolor Pyramid' date: 'Sat Aug 12 11:05:24 2023
categories: - oi-solutions'</p>
<h1 id="arc117---tricolor-pyramid">ARC117 - Tricolor Pyramid</h1>
<p>设三种颜色分别为01,2, 容易发现原题变换 <span
class="math inline">\(f(a,b)\)</span> 的等价表达为</p>
<p><span class="math inline">\(f(a,b)=(-a-b)\mod 3\)</span></p>
<p><span class="math inline">\(\mod 3\)</span>
可以最后处理，那么就是一个取负操作</p>
<p>看成一个递推 <span class="math inline">\(F_{n,i}=col_i\)</span></p>
<p><span class="math inline">\(F_{i,j}=-F_{i+1,j}-F_{i+1,j+1}\)</span>
，求出 <span class="math inline">\(F_{1,1} \mod 3\)</span></p>
<p>那么对于每个 <span class="math inline">\(col_i\)</span> ，处理其对于
<span class="math inline">\(F_{1,1}\)</span>
的贡献系数，容易发现贡献就是一个两边走的杨辉三角，即 <span
class="math inline">\(\displaystyle
\binom{n-1}{i-1}(-1)^{n-1}\)</span></p>
<p><del>然后我就真的暴力处理组合数</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">char</span> ch[]=<span class="string">&quot;BWR&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> F[N],cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cnt[n]-cnt[m]-cnt[n-m]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> F[n]*F[m]*F[n-m]%<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,F[<span class="number">0</span>]=<span class="number">1</span>,N<span class="number">-1</span>) &#123;</span><br><span class="line">		cnt[i]=cnt[i<span class="number">-1</span>],F[i]=F[i<span class="number">-1</span>];</span><br><span class="line">		<span class="type">int</span> x=i;</span><br><span class="line">		<span class="keyword">while</span>(x%<span class="number">3</span>==<span class="number">0</span>) x/=<span class="number">3</span>,cnt[i]++;</span><br><span class="line">		F[i]=F[i]*x%<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;W&#x27;</span>) t=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>) t=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(~n&amp;<span class="number">1</span>) t=<span class="number">3</span>-t;</span><br><span class="line">		sum=(sum+<span class="built_in">C</span>(n<span class="number">-1</span>,i<span class="number">-1</span>)*t)%<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sum%=<span class="number">3</span>,<span class="built_in">putchar</span>(ch[sum]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/Atcoder/ARC117%20-%20Zero-Sum%20Ranges%202/</url>
    <content><![CDATA[<hr />
<p>title: 'ARC117 - Zero-Sum Ranges 2' date: 'Sat Aug 12 11:05:24 2023
categories: - oi-solutions'</p>
<h1 id="arc117---zero-sum-ranges-2">ARC117 - Zero-Sum Ranges 2</h1>
<p>题目大意：计算由 <span class="math inline">\(n\)</span> 个 <span
class="math inline">\(+1\)</span> 和 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(-1\)</span> 构成的序列，且 包含恰好 <span
class="math inline">\(k\)</span> 个和为零的区间 的数量</p>
<p>显然需要转化为前缀和，通过前缀和相等的二元组数确定和为0的数量</p>
<p>而恰好 <span class="math inline">\(n\)</span> 个 <span
class="math inline">\(+1,-1\)</span> 可以转化为 <span
class="math inline">\(s_{2n}=0\)</span></p>
<p>设 <span class="math inline">\(m=2n+1\)</span> ，接下来我们要计算
<span class="math inline">\(m\)</span> 个元素，且 <span
class="math inline">\(s_1=s_m=0,s_{i}=s_{i-1}\pm 1\)</span> 的序列</p>
<p><span class="math inline">\(s_i\)</span> 的变化是连续的，考虑分为
<span class="math inline">\(s_i\ge 0,s_i&lt;0\)</span> 的两部分</p>
<p>以 <span class="math inline">\(\ge 0\)</span>
为例，从高到低确定每个连续的峰折线的情况，折线组的位置不重要，只需要知道个数</p>
<p>令 <span class="math inline">\(dp_{i,j,c}\)</span> 表示当前 <span
class="math inline">\(i\)</span> 个元素确定，且已经确定的元素分成了
<span class="math inline">\(j\)</span> 段，得到 <span
class="math inline">\(c\)</span> 个相同对的方案数</p>
<p>每个段中可能包含折线组，且两端一定是当前的最低值，状态数为 <span
class="math inline">\(O(n^4)\)</span></p>
<p>每次 <span class="math inline">\(dp\)</span>
在当前状态上扩展下一层的情况，由于变化连续，得到新的状态</p>
<p>1.每个段两边应该出现新的位置</p>
<p>2.两个段向两边扩展时，可能共用一个位置</p>
<p>3.可能出现新的峰顶</p>
<p>根据2,3的情况，组合数转移</p>
<p>如果直接枚举2,3情况，复杂度为 <span
class="math inline">\(O(n^6)\)</span></p>
<p>实际上容易发现2,3情况可以放在一起处理</p>
<p>具体的，对于新出现的 <span class="math inline">\(j+1\)</span>
个位置（也就是每两个段之间的间隔）是一定会出现的，用这 <span
class="math inline">\(j+1\)</span> 个可以合并为一整个段</p>
<p>剩余的情况，额外插入一个元素，就是在 <span
class="math inline">\(j+1\)</span>
个位置中分配，且每额外加入一个就能额外产生一个新的段</p>
<p>复杂度为 <span class="math inline">\(O(n^5)\)</span></p>
<p>最终合并 <span class="math inline">\(s_i\ge 0,s_i&lt;0\)</span>
的两部分，由于 <span class="math inline">\(s_1=s_m=0\)</span>
，所以开头结尾两端必须是0，然后两部分的段交替排列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="keyword">enum</span>&#123;N=<span class="number">62</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line">ll C[N][N],dp[N][N][<span class="number">910</span>];</span><br><span class="line"><span class="comment">// dp[i][j][s]</span></span><br><span class="line"><span class="comment">// i places taken</span></span><br><span class="line"><span class="comment">// j elements </span></span><br><span class="line"><span class="comment">// s ranges generated</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">D2</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; <span class="keyword">return</span> n*(n<span class="number">-1</span>)/<span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k),m=n*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,m) <span class="built_in">rep</span>(j,*C[i]=<span class="number">1</span>,i) C[i][j]=C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,m) <span class="keyword">if</span>(<span class="built_in">D2</span>(i)&lt;=k) dp[i][i][<span class="built_in">D2</span>(i)]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">rep</span>(j,<span class="number">1</span>,i) <span class="built_in">rep</span>(s,<span class="number">0</span>,k) <span class="keyword">if</span>(dp[i][j][s]) &#123;</span><br><span class="line">		<span class="built_in">rep</span>(d,j+<span class="number">1</span>,m-i) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s+<span class="built_in">D2</span>(d)&gt;k) <span class="keyword">break</span>;</span><br><span class="line">			dp[i+d][d-j][s+<span class="built_in">D2</span>(d)]+=dp[i][j][s]*C[d<span class="number">-1</span>][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">rep</span>(j,<span class="number">1</span>,i) <span class="built_in">rep</span>(s,<span class="number">0</span>,k) <span class="keyword">if</span>(dp[i][j][s]) &#123;</span><br><span class="line">		ans+=dp[i][j][s]*dp[m-i][j<span class="number">-1</span>][k-s];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeChef/CodeChef%202020%20NOV%20Scalar%20Product%20Tree/</url>
    <content><![CDATA[<hr />
<p>title: 'CodeChef 2020 November Challenge - Scalar Product Tree
(莫队)' date: 'Sat Aug 12 11:05:24 2023 categories: - oi-solutions'</p>
<h1
id="codechef-2020-november-challenge---scalar-product-tree-莫队">CodeChef
2020 November Challenge - Scalar Product Tree (莫队)</h1>
<p>题目大意：给定一棵根为1的树，每个点有权值 <span
class="math inline">\(A_i\)</span>
，每个点按照其从根开始的路径记录下来一串数 <span
class="math inline">\((A_1,\cdots,A_u)\)</span> 构成一个向量 <span
class="math inline">\(v_u\)</span></p>
<p>每次查询两个点 <span class="math inline">\((x,y)\)</span> ，查询
<span class="math inline">\(v_x\cdot v_y\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p>由于向量点积是对位相乘的，不好用数据结构维护</p>
<p>考虑用一个序列描述 <span class="math inline">\(\text{dfs}\)</span>
遍历树时每个点入栈出栈的过程，扫描一段前缀即可得到遍历到每个点时 <span
class="math inline">\(\text{dfs}\)</span>
栈的情况，也就得到了题目指定的向量</p>
<p>每次查询两个点 <span class="math inline">\(x,y\)</span>
，那么就是查询了两段前缀，用莫队维护两个前缀指针的移动，同时维护每个深度上两个前缀对应的值以及这些值的乘积即可</p>
<p>复杂度为 <span class="math inline">\(O(n\sqrt n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) f|=IO==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">6e5</span>+<span class="number">10</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> id[N],dfn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> U;</span><br><span class="line">U A[N];</span><br><span class="line"><span class="type">int</span> L[N],K[N]; <span class="comment">// L,K维护括号序列，L为编号,K为左括号还是右括号</span></span><br><span class="line">U Sum,Ans[N];</span><br><span class="line"><span class="type">int</span> dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	L[id[u]=++dfn]=u,K[dfn]=<span class="number">1</span>;</span><br><span class="line">	dep[u]=dep[f]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt) &#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	L[++dfn]=u,K[dfn]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Que</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,id;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Que __) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(l/len!=__.l/len) <span class="keyword">return</span> l/len&lt;__.l/len;</span><br><span class="line">		<span class="keyword">return</span> ((l/len)&amp;<span class="number">1</span>)?r&lt;__.r:r&gt;__.r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; Q[N];</span><br><span class="line"></span><br><span class="line">U S[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> d,<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p=dep[x];</span><br><span class="line">	Sum-=S[d][p]*S[!d][p];</span><br><span class="line">	S[d][p]=k==<span class="number">1</span>?A[x]:<span class="number">0</span>;</span><br><span class="line">	Sum+=S[d][p]*S[!d][p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) A[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n) &#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">AddEdge</span>(u,v),<span class="built_in">AddEdge</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>),len=<span class="built_in">sqrt</span>(dfn);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="type">int</span> l=<span class="built_in">rd</span>(),r=<span class="built_in">rd</span>();</span><br><span class="line">		l=id[l],r=id[r];</span><br><span class="line">		<span class="keyword">if</span>(l&gt;r) <span class="built_in">swap</span>(l,r);</span><br><span class="line">		Q[i]=(Que)&#123;l,r,i&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(Q+<span class="number">1</span>,Q+m+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Add</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">Add</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;Q[i].l) ++l,<span class="built_in">Add</span>(<span class="number">0</span>,L[l],K[l]);</span><br><span class="line">		<span class="keyword">while</span>(l&gt;Q[i].l) <span class="built_in">Add</span>(<span class="number">0</span>,L[l],-K[l]),l--;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(r&lt;Q[i].r) ++r,<span class="built_in">Add</span>(<span class="number">1</span>,L[r],K[r]);</span><br><span class="line">		<span class="keyword">while</span>(r&gt;Q[i].r) <span class="built_in">Add</span>(<span class="number">1</span>,L[r],-K[r]),r--;</span><br><span class="line">		Ans[Q[i].id]=Sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,Ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeChef/CodeChefNOV19%20PrettyBox/</url>
    <content><![CDATA[<hr />
<p>title: 'Codechef November Chanllenge 2019 Div1 PrettyBox
(贪心，线段树)' date: 'Sat Aug 12 11:05:24 2023 categories: -
oi-solutions'</p>
<h1
id="codechef-november-chanllenge-2019-div1-prettybox-贪心线段树">Codechef
November Chanllenge 2019 Div1 PrettyBox (贪心，线段树)</h1>
<p><a
href="https://www.codechef.com/NOV19A/problems/PBOXES">原题链接</a></p>
<p>前言：这篇文章主要讲如何用线段树优化贪心，关于贪心的证明建议看<a
href="https://discuss.codechef.com/t/pboxes-editorial/44102">官方题解</a></p>
<p>贪心思路：</p>
<p>首先肯定要按照 <span class="math inline">\((S_i,P_i)\)</span>
递增的顺序排序</p>
<p>每次选取两个点，一个标记为左括号，权值为 <span
class="math inline">\(-P_i\)</span> ，一个标记为右括号，权值为 <span
class="math inline">\(P_i\)</span>
，显然只要是一个合法的括号序列即可</p>
<p>题解证明了在不断增加括号时，不会出现一个位置的括号情况改变</p>
<p>现在我们的贪心问题就在于怎样找到一对最优的括号，注意每次选出的
<strong>两个括号之间并不一定匹配</strong></p>
<p>为了便于描述，把左括号看做1，右括号看做-1，一个合法括号序列满足任何一个前缀和
<span class="math inline">\(\ge 0\)</span></p>
<p>考虑什么样的情况可以放置左右括号，设分别放在 <span
class="math inline">\(x,y\)</span></p>
<ol type="1">
<li><p><span class="math inline">\(x&lt;y\)</span> 显然合法</p></li>
<li><p><span class="math inline">\(x&gt;y\)</span>
时，如果存在一个括号对，将 <span class="math inline">\((x,y)\)</span>
包含在一起，即 <span class="math inline">\((y,x)\)</span>
这一段区间不跨过一个前缀和为 <span class="math inline">\(0\)</span>
的位置</p></li>
</ol>
<p>如果把序列 看做 由一段段 <strong>前缀和为0的位置</strong> 分割开来的
一个个<strong>联通块</strong>，似乎比较好理解</p>
<p>也就是块内随意选，之间只能由小到大匹配</p>
<p>接下来考虑用线段树维护这样的块的信息，下面只讨论 <span
class="math inline">\(x&gt;y\)</span> 的情况</p>
<p>由于线段树每个结点统计区间 <span class="math inline">\([l,r]\)</span>
的信息，所以实际上块之间的间隔并不为0</p>
<p>设 <span class="math inline">\([l,r]\)</span> 中最小的前缀和为 <span
class="math inline">\(Min\)</span> (是指从 <span
class="math inline">\(l\)</span> 开始的前缀和)</p>
<p>不妨统计 <span class="math inline">\([l,r]\)</span>
中不跨过一个前缀和为 <span class="math inline">\(Min\)</span>
的位置的答案 <span class="math inline">\(Ans\)</span> ，以及跨过的答案
<span class="math inline">\(Ans2\)</span></p>
<p>合并两个区间时，需要找到</p>
<p>左区间中 右边连续的一段不跨过最小值 的最大权值 <span
class="math inline">\(R\)</span></p>
<p>右区间中 左边连续的一段不跨过最小值 的最小权值 <span
class="math inline">\(L\)</span></p>
<p>以及任意的最小值最大值 <span class="math inline">\(mi,ma\)</span></p>
<p>然后按照 <span class="math inline">\(Min\)</span> 的权值大小关系
，判断这4种权值的合并应该被分配到 <span
class="math inline">\(Ans\)</span> 还是 <span
class="math inline">\(Ans2\)</span></p>
<p>合并 <span class="math inline">\(L,R\)</span> 时注意 <span
class="math inline">\(L\)</span> 优先看左儿子， <span
class="math inline">\(R\)</span> 优先看右儿子，具体实现看代码中的 <span
class="math inline">\(Up\)</span> 函数</p>
<p>每次存下答案找到最优配对后，在序列上对应放置-1,1单点修改即可，复杂度为
<span class="math inline">\(O(n\log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; a=<span class="built_in">min</span>(a,b); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; a=<span class="built_in">max</span>(a,b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,M=N&lt;&lt;<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">Pii T[N];</span><br><span class="line"><span class="type">int</span> A[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> S[M]; <span class="comment">// 区间和</span></span><br><span class="line"><span class="type">int</span> Min[M]; <span class="comment">// 前缀最小值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> x):<span class="built_in">x</span>(x)&#123;&#125;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node __) <span class="type">const</span> &#123; <span class="keyword">return</span> A[x]&lt;A[__.x]; &#125;</span><br><span class="line">&#125; L[M],R[M]; <span class="comment">// 左最小，右最大  , 记录的是不跨过最小值的权值</span></span><br><span class="line">Node mi[M],ma[M]; <span class="comment">// 区间最大最小，没有限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">Pair</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Pair</span>(<span class="type">int</span> x,<span class="type">int</span> y):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">	<span class="built_in">Pair</span>(Node x,Node y):<span class="built_in">x</span>(x.x),<span class="built_in">y</span>(y.x)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Val</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> A[y]-A[x]; &#125;</span><br><span class="line">	<span class="type">int</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Pair __) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Val</span>()&lt;__.<span class="built_in">Val</span>(); &#125;</span><br><span class="line">&#125; Ans[M],Ans2[M]; <span class="comment">// 不跨过最小值的答案以及x&lt;y的答案，包含最小值的答案</span></span><br><span class="line"><span class="comment">// 区间答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	S[p]=S[p&lt;&lt;<span class="number">1</span>]+S[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">	Min[p]=<span class="built_in">min</span>(Min[p&lt;&lt;<span class="number">1</span>],S[p&lt;&lt;<span class="number">1</span>]+Min[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">	mi[p]=<span class="built_in">min</span>(mi[p&lt;&lt;<span class="number">1</span>],mi[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]),ma[p]=<span class="built_in">max</span>(ma[p&lt;&lt;<span class="number">1</span>],ma[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	Ans[p]=<span class="built_in">max</span>(Ans[p&lt;&lt;<span class="number">1</span>],Ans[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">	Ans2[p]=<span class="built_in">Pair</span>(mi[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],ma[p&lt;&lt;<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">cmax</span>(Ans2[p],Ans2[p&lt;&lt;<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">cmax</span>(Ans2[p],Ans2[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cmax</span>(Ans[p],<span class="built_in">Pair</span>(mi[p&lt;&lt;<span class="number">1</span>],ma[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]));</span><br><span class="line">	Ans[p]=<span class="built_in">max</span>(Ans[p],<span class="built_in">Pair</span>(L[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],R[p&lt;&lt;<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(Min[p&lt;&lt;<span class="number">1</span>]!=Min[p]) &#123;</span><br><span class="line">		<span class="built_in">cmax</span>(Ans[p],Ans2[p&lt;&lt;<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">cmax</span>(Ans[p],<span class="built_in">Pair</span>(L[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],ma[p&lt;&lt;<span class="number">1</span>]));</span><br><span class="line">		L[p]=<span class="built_in">min</span>(mi[p&lt;&lt;<span class="number">1</span>],L[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		L[p]=L[p&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(S[p&lt;&lt;<span class="number">1</span>]+Min[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]!=Min[p]) &#123;</span><br><span class="line">		<span class="built_in">cmax</span>(Ans[p],Ans2[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">cmax</span>(Ans[p],<span class="built_in">Pair</span>(mi[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],R[p&lt;&lt;<span class="number">1</span>]));</span><br><span class="line">		R[p]=<span class="built_in">max</span>(R[p&lt;&lt;<span class="number">1</span>],ma[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		R[p]=R[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		S[p]=Min[p]=<span class="number">0</span>;</span><br><span class="line">		L[p]=n+<span class="number">1</span>,R[p]=n+<span class="number">2</span>;</span><br><span class="line">		mi[p]=ma[p]=l;</span><br><span class="line">		Ans[p]=Ans2[p]=<span class="built_in">Pair</span>(n+<span class="number">1</span>,n+<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">Up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Upd</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		S[p]=Min[p]=k;</span><br><span class="line">		L[p]=n+<span class="number">1</span>,R[p]=n+<span class="number">2</span>;</span><br><span class="line">		mi[p]=n+<span class="number">1</span>,ma[p]=n+<span class="number">2</span>;</span><br><span class="line">		Ans[p]=Ans2[p]=<span class="built_in">Pair</span>(n+<span class="number">1</span>,n+<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	x&lt;=mid?<span class="built_in">Upd</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x,k):<span class="built_in">Upd</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,k);</span><br><span class="line">	<span class="built_in">Up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n=<span class="built_in">rd</span>()) T[i].first=<span class="built_in">rd</span>(),T[i].second=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">sort</span>(T+<span class="number">1</span>,T+n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) A[i]=T[i].second;</span><br><span class="line">	A[n+<span class="number">1</span>]=<span class="number">1e9</span>+<span class="number">10</span>,A[n+<span class="number">2</span>]=<span class="number">-1e9</span><span class="number">-10</span>;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=n/<span class="number">2</span>) &#123;</span><br><span class="line">		Pair res=Ans[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(res.<span class="built_in">Val</span>()&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans+=res.<span class="built_in">Val</span>());</span><br><span class="line">		<span class="built_in">Upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,res.x,<span class="number">1</span>),<span class="built_in">Upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,res.y,<span class="number">-1</span>);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=n/<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans),i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeChef/Codechef%202020NOV%20Chef%20and%20the%20Combination%20Clock/</url>
    <content><![CDATA[<hr />
<p>title: 'CodeChef 2020 November - Challenge Chef and the Combination
Lock (多项式)' date: 'Sat Aug 12 11:05:24 2023 categories: -
oi-solutions'</p>
<h1
id="codechef-2020-november---challenge-chef-and-the-combination-lock-多项式">CodeChef
2020 November - Challenge Chef and the Combination Lock (多项式)</h1>
<p>题目大意：给定了 <span class="math inline">\(n\)</span> 个随机变量
<span class="math inline">\(x_i\in{0,1,\cdots,A_i}\)</span> ，令 <span
class="math inline">\(\Chi=\min_i\lbrace x_i,A_i-x_i\rbrace\)</span>
，求 <span class="math inline">\(E(\Chi)\)</span></p>
<p>我们知道 <span class="math inline">\(E(\Chi)=\sum_{i=0}^{\infty}
P(\Chi&gt;i)\)</span></p>
<p>不妨考虑计算 <span class="math inline">\(P(\Chi&gt;i)\)</span>
，先计算方案数，发现方案数可以用一个多项式来表示</p>
<p>令 <span class="math inline">\(F(x)\)</span> 为 <span
class="math inline">\(\Chi&gt;x\)</span> 的方案数，则 <span
class="math inline">\(\begin{aligned}F(x)=\prod_{i=1}^n
(A_i-1-2x)　\end{aligned}\)</span></p>
<p>显然 <span class="math inline">\(\Chi \leq \min\lbrace \frac{A_i}{2}
\rbrace\)</span> ，不妨设这个上界为 <span
class="math inline">\(U\)</span> ，也就是说我们要求 <span
class="math inline">\(\sum_{i=0}^U F(i)\)</span></p>
<p>常识：一个 <span class="math inline">\(n\)</span>
次多项式前缀和可以用一个不超过 <span class="math inline">\(n+1\)</span>
次的多项式来表示</p>
<p>如果暴力求出 <span class="math inline">\(F(x)\)</span> 在 <span
class="math inline">\(x=0,1,\cdots,n+1\)</span>
处的值，累前缀和，然后用拉格朗日插值法求出解</p>
<p>暴力求值复杂度为 <span class="math inline">\(O(n^2)\)</span>
，拉格朗日插值复杂度为 <span class="math inline">\(O(n)\)</span></p>
<p>可以用分治 <span class="math inline">\(\text{NTT}\)</span> 优化 <span
class="math inline">\(F(x)\)</span> 的求解，然后用<a
href="https://www.cnblogs.com/chasedeath/p/13073178.html"><strong>多项式多点求值</strong></a>求得点值</p>
<p>复杂度为 <span class="math inline">\(O(n\log ^2n)\)</span>
，实际在CodeChef上的运行时间为0.53s</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">18</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector &lt;<span class="type">int</span>&gt; Poly;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(Poly a,<span class="type">int</span> k=<span class="number">0</span>)</span></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(!k)&#123; <span class="keyword">for</span>(<span class="type">int</span> i:a) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> i:a) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rev[N],w[N];</span><br><span class="line"><span class="type">int</span> Inv[N+<span class="number">1</span>],Fac[N+<span class="number">1</span>],FInv[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">qpow</span>(<span class="number">3</span>,(P<span class="number">-1</span>)/N);</span><br><span class="line">	w[N&gt;&gt;<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,(N&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>,N<span class="number">-1</span>) w[i]=<span class="number">1ll</span>*w[i<span class="number">-1</span>]*t%P;</span><br><span class="line">	<span class="built_in">drep</span>(i,(N&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>,<span class="number">1</span>) w[i]=w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	Inv[<span class="number">0</span>]=Inv[<span class="number">1</span>]=Fac[<span class="number">0</span>]=Fac[<span class="number">1</span>]=FInv[<span class="number">0</span>]=FInv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,N) &#123;</span><br><span class="line">		Inv[i]=<span class="number">1ll</span>*(P-P/i)*Inv[P%i]%P; </span><br><span class="line">		FInv[i]=<span class="number">1ll</span>*FInv[i<span class="number">-1</span>]*Inv[i]%P;</span><br><span class="line">		Fac[i]=<span class="number">1ll</span>*Fac[i<span class="number">-1</span>]*i%P;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> R=<span class="number">1</span>,c=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(R&lt;n) R&lt;&lt;=<span class="number">1</span>,c++;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,R<span class="number">-1</span>) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;c);</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(rev[i]&lt;i) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> *e=w+i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">				<span class="type">int</span> t=<span class="number">1ll</span>*a[j+i]*e[j-l]%P;</span><br><span class="line">				a[j+i]=a[j]-t,<span class="built_in">Mod2</span>(a[j+i]);</span><br><span class="line">				a[j]+=t,<span class="built_in">Mod1</span>(a[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">		ll base=Inv[n];</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=a[i]*base%P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,Poly &amp;a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> A[N];</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">int</span>)a.<span class="built_in">size</span>()&lt;n) a.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=a[i];</span><br><span class="line">	<span class="built_in">NTT</span>(n,A,f);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=A[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poly <span class="keyword">operator</span> * (Poly a,Poly b)&#123;</span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> R=<span class="built_in">Init</span>(n);</span><br><span class="line">	a.<span class="built_in">resize</span>(R),b.<span class="built_in">resize</span>(R);</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">1</span>),<span class="built_in">NTT</span>(R,b,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) a[i]=<span class="number">1ll</span>*a[i]*b[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">-1</span>);</span><br><span class="line">	a.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Poly <span class="keyword">operator</span> + (Poly a,Poly b) &#123; </span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());</span><br><span class="line">	a.<span class="built_in">resize</span>(n),b.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]+=b[i],<span class="built_in">Mod1</span>(a[i]);</span><br><span class="line">	<span class="keyword">return</span> a; </span><br><span class="line">&#125;</span><br><span class="line">Poly <span class="keyword">operator</span> - (Poly a,Poly b) &#123; </span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">max</span>(a.<span class="built_in">size</span>(),b.<span class="built_in">size</span>());</span><br><span class="line">	a.<span class="built_in">resize</span>(n),b.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]-=b[i],<span class="built_in">Mod2</span>(a[i]);</span><br><span class="line">	<span class="keyword">return</span> a; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Poly <span class="title">Poly_Inv</span><span class="params">(Poly a)</span> </span>&#123; </span><br><span class="line">	<span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> Poly&#123;(<span class="type">int</span>)<span class="built_in">qpow</span>(a[<span class="number">0</span>],P<span class="number">-2</span>)&#125;;</span><br><span class="line">	Poly b=a; b.<span class="built_in">resize</span>((n+<span class="number">1</span>)/<span class="number">2</span>); b=<span class="built_in">Poly_Inv</span>(b);</span><br><span class="line">	<span class="type">int</span> R=<span class="built_in">Init</span>(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	a.<span class="built_in">resize</span>(R),b.<span class="built_in">resize</span>(R);</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">1</span>),<span class="built_in">NTT</span>(R,b,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) a[i]=(<span class="number">2</span><span class="number">-1ll</span>*a[i]*b[i]%P+P)*b[i]%P;</span><br><span class="line">	<span class="built_in">NTT</span>(R,a,<span class="number">-1</span>);</span><br><span class="line">	a.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用转置原理优化的多项式多点求值</span></span><br><span class="line"><span class="function">Poly <span class="title">Evaluate</span><span class="params">(Poly F,Poly X)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> ls[N&lt;&lt;<span class="number">1</span>],rs[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line">	<span class="type">static</span> Poly T[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	<span class="type">static</span> <span class="keyword">auto</span> TMul=[&amp;] (Poly F,Poly G)&#123;</span><br><span class="line">		<span class="type">int</span> n=F.<span class="built_in">size</span>(),m=G.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">if</span>(n&lt;=<span class="number">20</span> &amp;&amp; m&lt;=<span class="number">20</span>)&#123;</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,n-m) &#123;</span><br><span class="line">				<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">				<span class="built_in">rep</span>(j,<span class="number">0</span>,m<span class="number">-1</span>) t=(t+<span class="number">1ll</span>*F[i+j]*G[j])%P;</span><br><span class="line">				F[i]=t;</span><br><span class="line">			&#125; </span><br><span class="line">			F.<span class="built_in">resize</span>(n-m+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> F;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">reverse</span>(G.<span class="built_in">begin</span>(),G.<span class="built_in">end</span>());</span><br><span class="line">		<span class="type">int</span> R=<span class="built_in">Init</span>(n);</span><br><span class="line">		<span class="built_in">NTT</span>(R,F,<span class="number">1</span>),<span class="built_in">NTT</span>(R,G,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) F[i]=<span class="number">1ll</span>*F[i]*G[i]%P;</span><br><span class="line">		<span class="built_in">NTT</span>(R,F,<span class="number">-1</span>); <span class="function">Poly <span class="title">T</span><span class="params">(n-m+<span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n-m) T[i]=F[i+m<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">static</span> function &lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; Build=[&amp;](<span class="type">int</span> l,<span class="type">int</span> r) &#123;</span><br><span class="line">		<span class="type">int</span> u=++cnt; ls[u]=rs[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">			T[u]=Poly&#123;<span class="number">1</span>,P-X[l]&#125;;</span><br><span class="line">			<span class="keyword">return</span> u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		ls[u]=<span class="built_in">Build</span>(l,mid),rs[u]=<span class="built_in">Build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">		T[u]=T[ls[u]]*T[rs[u]];</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n=F.<span class="built_in">size</span>(),m=X.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">cmax</span>(n,m),F.<span class="built_in">resize</span>(n),X.<span class="built_in">resize</span>(n);</span><br><span class="line">	cnt=<span class="number">0</span>,<span class="built_in">Build</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	F.<span class="built_in">resize</span>(n*<span class="number">2</span>+<span class="number">1</span>),T[<span class="number">1</span>]=<span class="built_in">TMul</span>(F,<span class="built_in">Poly_Inv</span>(T[<span class="number">1</span>]));</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,cnt) <span class="keyword">if</span>(ls[i]) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(T[ls[i]],T[rs[i]]);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> R=<span class="built_in">Init</span>(T[i].<span class="built_in">size</span>()),n=T[i].<span class="built_in">size</span>(),m1=T[ls[i]].<span class="built_in">size</span>(),m2=T[rs[i]].<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">NTT</span>(R,T[i],<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">reverse</span>(T[ls[i]].<span class="built_in">begin</span>(),T[ls[i]].<span class="built_in">end</span>()); <span class="built_in">reverse</span>(T[rs[i]].<span class="built_in">begin</span>(),T[rs[i]].<span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">NTT</span>(R,T[ls[i]],<span class="number">1</span>); <span class="built_in">NTT</span>(R,T[rs[i]],<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,R<span class="number">-1</span>) &#123;</span><br><span class="line">			T[ls[i]][j]=<span class="number">1ll</span>*T[ls[i]][j]*T[i][j]%P;</span><br><span class="line">			T[rs[i]][j]=<span class="number">1ll</span>*T[rs[i]][j]*T[i][j]%P;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">NTT</span>(R,T[ls[i]],<span class="number">-1</span>); <span class="built_in">NTT</span>(R,T[rs[i]],<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,n-m1) T[ls[i]][j]=T[ls[i]][j+m1<span class="number">-1</span>];</span><br><span class="line">		T[ls[i]].<span class="built_in">resize</span>(n-m1+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,n-m2) T[rs[i]][j]=T[rs[i]][j+m2<span class="number">-1</span>];</span><br><span class="line">		T[rs[i]].<span class="built_in">resize</span>(n-m2+<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> X[p++]=T[i][<span class="number">0</span>];</span><br><span class="line">	X.<span class="built_in">resize</span>(m);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> A[N];</span><br><span class="line"><span class="type">int</span> I[N],J[N];</span><br><span class="line"><span class="type">int</span> F[N],L[N],R[N];</span><br><span class="line"></span><br><span class="line"><span class="function">Poly <span class="title">Solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> Poly&#123;A[l]<span class="number">-1</span>,P<span class="number">-2</span>&#125;;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Solve</span>(l,mid)*<span class="built_in">Solve</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,J[<span class="number">0</span>]=<span class="number">1</span>,N<span class="number">-1</span>) J[i]=<span class="number">1ll</span>*J[i<span class="number">-1</span>]*i%P;</span><br><span class="line">	I[N<span class="number">-1</span>]=<span class="built_in">qpow</span>(J[N<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">drep</span>(i,N<span class="number">-1</span>,<span class="number">1</span>) I[i<span class="number">-1</span>]=<span class="number">1ll</span>*I[i]*i%P;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x=P,All=<span class="number">1</span>; </span><br><span class="line">		n=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) F[i]=<span class="number">0</span>;</span><br><span class="line">		F[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">			A[i]=<span class="built_in">rd</span>();</span><br><span class="line">			f|=!A[i];</span><br><span class="line">			<span class="built_in">cmin</span>(x,(A[i]<span class="number">-1</span>)/<span class="number">2</span>),All=<span class="number">1ll</span>*All*(A[i]+<span class="number">1</span>)%P;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f)&#123; <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">		Poly Y=<span class="built_in">Solve</span>(<span class="number">1</span>,n),<span class="built_in">X</span>(n+<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n+<span class="number">1</span>) X[i]=i;</span><br><span class="line">		Y=<span class="built_in">Evaluate</span>(Y,X);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) Y[i]=(Y[i]+Y[i<span class="number">-1</span>])%P;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=n+<span class="number">1</span>) ans=Y[x];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拉格朗日插值</span></span><br><span class="line">			L[<span class="number">0</span>]=x;</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) L[i]=<span class="number">1ll</span>*L[i<span class="number">-1</span>]*(x-i)%P;</span><br><span class="line">			R[n+<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">drep</span>(i,n+<span class="number">1</span>,<span class="number">0</span>) R[i]=<span class="number">1ll</span>*R[i+<span class="number">1</span>]*(x-i)%P;</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,n+<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="type">int</span> t=<span class="number">1ll</span>*Y[i]*(i?L[i<span class="number">-1</span>]:<span class="number">1</span>)%P*R[i+<span class="number">1</span>]%P*I[i]%P*I[n+<span class="number">1</span>-i]%P;</span><br><span class="line">				<span class="keyword">if</span>((n+<span class="number">1</span>-i)&amp;<span class="number">1</span>) t=P-t;</span><br><span class="line">				ans=(ans+t)%P;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans=ans*<span class="built_in">qpow</span>(All)%P;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeChef/CodeChef%20Winning%20Ways/</url>
    <content><![CDATA[<hr />
<p>title: 'CodeChef November Challenge2019 Winning Ways (3-FWT)' date:
'Sat Aug 12 11:05:24 2023 categories: - oi-solutions'</p>
<h1 id="codechef-november-challenge2019-winning-ways-3-fwt">CodeChef
November Challenge2019 Winning Ways (3-FWT)</h1>
<p>显然每个把每个数换成其因子个数-1，就能转为一个扩展的 <span
class="math inline">\(\text{Nim}\)</span> 游戏</p>
<p>每次操作 <span class="math inline">\(1,2,\cdots,k\)</span> 堆的 <span
class="math inline">\(\text{Nim}\)</span> 游戏，其判定方法是：</p>
<p>将每个数二进制分解，对于每个二进制位上分别计算1的个数 <span
class="math inline">\(\mod (k+1)\)</span> ，如果均为0则先手必败</p>
<p>对于这道题 <span class="math inline">\(k=3\)</span>
，我们考虑将其转为二进制之后的形式累成3进制，然后就能进行3进制按位不进位加法，即类异或</p>
<p>然后问题实际上有非常多的部分需要考虑</p>
<h2 id="part1-如何求因子个数">Part1 如何求因子个数</h2>
<p>一个简单的方法是枚举 <span class="math inline">\([1,\sqrt n]\)</span>
判断是否整除，复杂度过高</p>
<p>对于 <span class="math inline">\(n=\prod p_i^{c_i}\)</span> ( <span
class="math inline">\(p_i\)</span> 为质数)，其因子个数为 <span
class="math inline">\(\prod (c_i+1)\)</span></p>
<p>由这个式子对于 <span class="math inline">\(n\)</span>
进行质因数分解，枚举 <span class="math inline">\([1,\sqrt n]\)</span>
中的质数，复杂度为 <span class="math inline">\(O(\pi(\sqrt
n))=O(\frac{\sqrt n}{\log n})\)</span> ，这个应该够了？</p>
<p>然后是一个常规套路型的分解方法：</p>
<p>先对于 <span class="math inline">\([1,n^{\frac{1}{3}}]\)</span>
的质数筛 <span class="math inline">\(n\)</span>
，剩余的部分只有3种情况</p>
<ol type="1">
<li><p><span class="math inline">\(n\)</span> 被筛成1了</p></li>
<li><p><span class="math inline">\(n\)</span> 被筛到只剩一个质数，可以用
<span class="math inline">\(\text{Miller_Rabin}\)</span>
算法快速判断，<a
href="https://www.cnblogs.com/chasedeath/p/13492548.html"><strong>可以参考</strong></a></p></li>
<li><p><span class="math inline">\(n\)</span>
仍然是若干质数的乘积，此时质因子必然 <span
class="math inline">\(&gt;n^{\frac{1}{3}}\)</span>
，因此最多只有两个</p></li>
</ol>
<p>那么只需要判断 <span class="math inline">\(n\)</span>
是否是完全平方数即可</p>
<p>总复杂度为 <span class="math inline">\(O(w\cdot \log
n+\frac{n^{\frac{1}{3}}}{\log n})\)</span> ，其中 <span
class="math inline">\(w\)</span> 为 <span
class="math inline">\(\text{Miller_Rabin}\)</span> 筛选次数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> notpri[N],pri[N],pc;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>,<span class="type">int</span> P=::P)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Trans</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> buf[<span class="number">20</span>],l=<span class="number">0</span>;</span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) buf[++l]=x%<span class="number">2</span>,x/=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">drep</span>(i,l,<span class="number">1</span>) s=s*<span class="number">3</span>+buf[i];</span><br><span class="line">    <span class="built_in">cmax</span>(ma,s);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Miller_Rabin</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> !notpri[x];</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span> || ~x&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll s=<span class="number">0</span>,t=x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(~t&amp;<span class="number">1</span>) s++,t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">4</span>) &#123;</span><br><span class="line">        ll a=pri[<span class="built_in">rand</span>()%pc+<span class="number">1</span>],b=<span class="built_in">qpow</span>(a,t,x),c;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,s) &#123;</span><br><span class="line">            c=<span class="number">1ll</span>*b*b%x;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">1</span> &amp;&amp; b!=<span class="number">1</span> &amp;&amp; b!=x<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            b=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CheckSqr</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=<span class="built_in">round</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line">    <span class="keyword">return</span> y*y==n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Count</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=pc &amp;&amp; pri[i]*pri[i]*pri[i]&lt;=n;++i) <span class="keyword">if</span>(n%pri[i]==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n%pri[i]==<span class="number">0</span>) n/=pri[i],c++;</span><br><span class="line">        res*=c+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">CheckSqr</span>(n)) <span class="keyword">return</span> res*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Miller_Rabin</span>(n)) <span class="keyword">return</span> res*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> res*<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-1</span>) <span class="keyword">if</span>(!notpri[i]) &#123;</span><br><span class="line">        pri[++pc]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+i;j&lt;N;j+=i) notpri[j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="part2-快速计算答案">Part2 快速计算答案</h2>
<p><span class="math inline">\(10^9\)</span> 以内的数，最大因子个数为
<span class="math inline">\(1334\)</span> ，这个数为 <span
class="math inline">\(931170240\)</span></p>
<p>转成二进制之后最多包含 <span class="math inline">\(11\)</span>
位，三进制下最大为 <span class="math inline">\(3^{11}-1=177146\)</span>
，令这个上界为 <span class="math inline">\(M\)</span></p>
<p>一种非常暴力的方法就是直接枚举， <span
class="math inline">\(NM\)</span> 计算每次选择一个数，复杂度为 <span
class="math inline">\(O(NMK)\)</span> ，应该可以通过 <span
class="math inline">\(N\leq 12\)</span> 的数据</p>
<p>一个比较浅显的优化可以用快速幂维护乘法，复杂度为 <span
class="math inline">\(O(M^2\log K)\)</span></p>
<p>由于是3进制类异或，接下来考虑用 <span
class="math inline">\(\text{3-FWT}\)</span> 优化乘法，<a
href="https://www.cnblogs.com/chasedeath/p/12785842.html"><strong>可以参考</strong></a></p>
<p>模数为 <span class="math inline">\(P=10^9+7\)</span> ，不存在整数
<span class="math inline">\(3\)</span> 阶单位根，因此要用类似拆系数
<span class="math inline">\(\text{FFT}\)</span> 方法做</p>
<p>复杂度为 <span class="math inline">\(O(M\log M\log K)\)</span>
，似乎已经比较小了，但是常数非常大，应该难以通过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> R;<span class="comment">// R为上界</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cp</span>&#123;</span><br><span class="line">    db x,y;</span><br><span class="line">    <span class="built_in">Cp</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Cp</span>(db x,db y):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    Cp <span class="keyword">operator</span> + (<span class="type">const</span> Cp t)&#123; <span class="keyword">return</span> <span class="built_in">Cp</span>(x+t.x,y+t.y); &#125;</span><br><span class="line">    Cp <span class="keyword">operator</span> - (<span class="type">const</span> Cp t)&#123; <span class="keyword">return</span> <span class="built_in">Cp</span>(x-t.x,y-t.y); &#125;</span><br><span class="line">    Cp <span class="keyword">operator</span> * (<span class="type">const</span> Cp t)&#123; <span class="keyword">return</span> <span class="built_in">Cp</span>(x*t.x-y*t.y,x*t.y+y*t.x); &#125;</span><br><span class="line">&#125; A[N],B[N],C[N],D[N];</span><br><span class="line">Cp w[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> A[<span class="number">20</span>],B[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">19</span>) A[i]=x%<span class="number">3</span>,x/=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">19</span>) B[i]=y%<span class="number">3</span>,y/=<span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">drep</span>(i,<span class="number">19</span>,<span class="number">0</span>) ans=ans*<span class="number">3</span>+((A[i]+B[i])%<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(Cp *a,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;R;i*=<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;R;l+=i*<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">                <span class="type">static</span> Cp t[<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">if</span>(f==<span class="number">1</span>) &#123;</span><br><span class="line">                    t[<span class="number">0</span>]=a[j]+a[j+i]+a[j+i*<span class="number">2</span>];</span><br><span class="line">                    t[<span class="number">1</span>]=a[j]+w[<span class="number">1</span>]*a[j+i]+w[<span class="number">2</span>]*a[j+i*<span class="number">2</span>];</span><br><span class="line">                    t[<span class="number">2</span>]=a[j]+w[<span class="number">2</span>]*a[j+i]+w[<span class="number">1</span>]*a[j+i*<span class="number">2</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t[<span class="number">0</span>]=a[j]+a[j+i]+a[j+i*<span class="number">2</span>];</span><br><span class="line">                    t[<span class="number">1</span>]=a[j]+w[<span class="number">2</span>]*a[j+i]+w[<span class="number">1</span>]*a[j+i*<span class="number">2</span>];</span><br><span class="line">                    t[<span class="number">2</span>]=a[j]+w[<span class="number">1</span>]*a[j+i]+w[<span class="number">2</span>]*a[j+i*<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                a[j]=t[<span class="number">0</span>],a[j+i]=t[<span class="number">1</span>],a[j+i*<span class="number">2</span>]=t[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">rep</span>(d,<span class="number">0</span>,<span class="number">2</span>) &#123;</span><br><span class="line">                        a[j+i*d].x/=<span class="number">3</span>,a[j+i*d].y/=<span class="number">3</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S=(<span class="number">1</span>&lt;&lt;<span class="number">15</span>)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FWTs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Poly</span>&#123; </span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line">    Poly <span class="keyword">operator</span> * (<span class="type">const</span> Poly __) <span class="type">const</span> &#123;</span><br><span class="line">        Poly res;</span><br><span class="line">        <span class="comment">// 拆系数，任意模数3-FWT</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FWTs</span></span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) A[i]=<span class="built_in">Cp</span>((a[i]&amp;S),(a[i]&gt;&gt;<span class="number">15</span>)),B[i]=<span class="built_in">Cp</span>((a[i]&amp;S),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) C[i]=<span class="built_in">Cp</span>((__.a[i]&amp;S),(__.a[i]&gt;&gt;<span class="number">15</span>));</span><br><span class="line">        <span class="built_in">FWT</span>(A,<span class="number">1</span>),<span class="built_in">FWT</span>(B,<span class="number">1</span>),<span class="built_in">FWT</span>(C,<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E(x) ((ll)(x+0.5))%P</span></span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) A[i]=A[i]*C[i];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) B[i]=B[i]*C[i];</span><br><span class="line">        <span class="built_in">FWT</span>(A,<span class="number">-1</span>),<span class="built_in">FWT</span>(B,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) &#123;</span><br><span class="line">            ll a=<span class="built_in">E</span>(B[i].x),b=<span class="built_in">E</span>(A[i].y),c=<span class="built_in">E</span>(B[i].x-A[i].x);</span><br><span class="line">            res.a[i]=(a+<span class="number">1ll</span>*b*(S+<span class="number">1</span>)+<span class="number">1ll</span>*c*(S+<span class="number">1</span>)*(S+<span class="number">1</span>))%P;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) res.a[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) <span class="keyword">if</span>(a[i]) <span class="built_in">rep</span>(j,<span class="number">0</span>,R<span class="number">-1</span>) <span class="keyword">if</span>(__.a[j]) &#123;</span><br><span class="line">            <span class="type">int</span> k=<span class="built_in">Add</span>(i,j);</span><br><span class="line">            res.a[k]=(res.a[k]+<span class="number">1ll</span>*a[i]*__.a[j])%P;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; x,res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-1</span>) <span class="keyword">if</span>(!notpri[i]) &#123;</span><br><span class="line">        pri[++pc]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+i;j&lt;N;j+=i) notpri[j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    w[<span class="number">0</span>]=<span class="built_in">Cp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">29</span>) w[i]=w[i<span class="number">-1</span>]*<span class="built_in">Cp</span>(<span class="built_in">cos</span>(<span class="number">2</span>*Pi/<span class="number">3</span>),<span class="built_in">sin</span>(<span class="number">2</span>*Pi/<span class="number">3</span>));</span><br><span class="line">    <span class="comment">// 复平面3阶单位根</span></span><br><span class="line"></span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) x.a[<span class="built_in">Count</span>(<span class="built_in">rd</span>())]++;</span><br><span class="line">    <span class="keyword">for</span>(R=<span class="number">1</span>;R&lt;=ma;R*=<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    res.a[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(;m;m&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m&amp;<span class="number">1</span>) res=res*x;</span><br><span class="line">        x=x*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,R<span class="number">-1</span>) ans+=res.a[i],<span class="built_in">Mod1</span>(ans);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="further">Further</h3>
<p>对于形式幂级数多项式，我们知道 <span class="math inline">\(K\)</span>
次幂的循环卷积可以直接 <span class="math inline">\(\text{DFT}\)</span>
一次，每一位快速幂，然后 <span
class="math inline">\(\text{IDFT}\)</span></p>
<p>同理的，如果你学习了 <span
class="math inline">\(\text{K-FWT}\)</span> 就知道这就是一个按 <span
class="math inline">\(K\)</span>
进制位，每一位分别进行循环卷积，因此也可以用类似的方法做</p>
<p>但是遇到一个非常大的问题就是无法找到模意义下的 <span
class="math inline">\(3\)</span> 阶单位根(指 <span
class="math inline">\(3\not |(P-1)\)</span> )</p>
<p>如果用复平面单位根 <span
class="math inline">\(\omega_n=cos(\frac{2\pi}{n})+sin(\frac{2\pi}{n})\cdot
i\)</span> ( <span class="math inline">\(i=\sqrt {-1})\)</span>
，无法在计算时保证值域精度</p>
<p>这里由于 <span class="math inline">\(n=3\)</span> 比较特殊，发现
<span
class="math inline">\(\omega_3=cos(\frac{2\pi}{3})+sin(\frac{2\pi}{3})\cdot
i=-\frac{1}{2}+\frac{\sqrt 3}{2}\cdot i\)</span></p>
<p>而 <span class="math inline">\(3\)</span> 在 <span
class="math inline">\(\mod 10^9+7\)</span>
下存在二次剩余，因此可以用一个模意义下的复数描述复平面单位根</p>
<p>应该是有通行的单位根求法，会根据 <span
class="math inline">\(n\)</span>
不同要用更复杂的高维复数描述，但是我并不会.jpg</p>
<p>总复杂度为 <span class="math inline">\(O(M(\log M+\log K))\)</span>
，分别为进行 <span class="math inline">\(\text{3-FWT}\)</span>
以及快速幂的复杂度</p>
<p>Code总览:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> Mbe;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Quad3=<span class="number">82062379</span>; <span class="comment">// 3在Mod P意义下的二次剩余</span></span><br><span class="line"><span class="type">const</span> db Pi=<span class="built_in">acos</span>((db)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxX=<span class="number">931170240</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,ma,R;</span><br><span class="line"><span class="type">int</span> notpri[N],pri[N],pc;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>,<span class="type">int</span> P=::P)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Trans</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> buf[<span class="number">20</span>],l=<span class="number">0</span>;</span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) buf[++l]=x%<span class="number">2</span>,x/=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">drep</span>(i,l,<span class="number">1</span>) s=s*<span class="number">3</span>+buf[i];</span><br><span class="line">    <span class="built_in">cmax</span>(ma,s);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Miller_Rabin</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;N) <span class="keyword">return</span> !notpri[x];</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span> || ~x&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll s=<span class="number">0</span>,t=x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(~t&amp;<span class="number">1</span>) s++,t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">4</span>) &#123;</span><br><span class="line">        ll a=pri[<span class="built_in">rand</span>()%pc+<span class="number">1</span>],b=<span class="built_in">qpow</span>(a,t,x),c;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,s) &#123;</span><br><span class="line">            c=<span class="number">1ll</span>*b*b%x;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">1</span> &amp;&amp; b!=<span class="number">1</span> &amp;&amp; b!=x<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            b=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CheckSqr</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=<span class="built_in">round</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line">    <span class="keyword">return</span> y*y==n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Count</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=pc &amp;&amp; pri[i]*pri[i]*pri[i]&lt;=n;++i) <span class="keyword">if</span>(n%pri[i]==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n%pri[i]==<span class="number">0</span>) n/=pri[i],c++;</span><br><span class="line">        res*=c+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">CheckSqr</span>(n)) <span class="keyword">return</span> res*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Miller_Rabin</span>(n)) <span class="keyword">return</span> res*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> res*<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cp</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">Cp</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Cp</span>(<span class="type">int</span> x,<span class="type">int</span> y):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    Cp <span class="keyword">operator</span> + (<span class="type">const</span> Cp t)&#123; </span><br><span class="line">        <span class="function">Cp <span class="title">res</span><span class="params">(x+t.x,y+t.y)</span></span>;</span><br><span class="line">        <span class="built_in">Mod1</span>(res.x),<span class="built_in">Mod1</span>(res.y);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Cp <span class="keyword">operator</span> * (<span class="type">const</span> Cp t)&#123; <span class="keyword">return</span> <span class="built_in">Cp</span>((<span class="number">1ll</span>*x*t.x+<span class="number">1ll</span>*(P-y)*t.y)%P,(<span class="number">1ll</span>*x*t.y+<span class="number">1ll</span>*y*t.x)%P); &#125;</span><br><span class="line">&#125; A[N]; <span class="comment">// 模意义下 模拟复平面单位根</span></span><br><span class="line">Cp w1,w2; <span class="comment">// 3阶单位根及其平方</span></span><br><span class="line"></span><br><span class="line"><span class="function">Cp <span class="title">qpow</span><span class="params">(Cp x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">Cp <span class="title">res</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是展开的FWT式子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;R;i*=<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;R;l+=i*<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">                Cp a=A[j]+A[j+i]+A[j+i*<span class="number">2</span>];</span><br><span class="line">                Cp b=A[j]+w1*A[j+i]+w2*A[j+i*<span class="number">2</span>];</span><br><span class="line">                Cp c=A[j]+w2*A[j+i]+w1*A[j+i*<span class="number">2</span>];</span><br><span class="line">                A[j]=a,A[j+i]=b,A[j+i*<span class="number">2</span>]=c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IFWT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;R;i*=<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;R;l+=i*<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">                Cp a=A[j]+A[j+i]+A[j+i*<span class="number">2</span>];</span><br><span class="line">                Cp b=A[j]+w2*A[j+i]+w1*A[j+i*<span class="number">2</span>];</span><br><span class="line">                Cp c=A[j]+w1*A[j+i]+w2*A[j+i*<span class="number">2</span>];</span><br><span class="line">                A[j]=a,A[j+i]=b,A[j+i*<span class="number">2</span>]=c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll base=<span class="built_in">qpow</span>(R);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) A[i].x=A[i].x*base%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-1</span>) <span class="keyword">if</span>(!notpri[i]) &#123;</span><br><span class="line">        pri[++pc]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+i;j&lt;N;j+=i) notpri[j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    w1=<span class="built_in">Cp</span>(P-(P+<span class="number">1</span>)/<span class="number">2</span>,<span class="number">1ll</span>*Quad3*(P+<span class="number">1</span>)/<span class="number">2</span>%P);</span><br><span class="line">    w2=w1*w1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">        n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) A[<span class="built_in">Trans</span>(<span class="built_in">Count</span>(<span class="built_in">rd</span>())<span class="number">-1</span>)].x++;</span><br><span class="line">        <span class="keyword">for</span>(R=<span class="number">1</span>;R&lt;=ma;R*=<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">FWT</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) A[i]=<span class="built_in">qpow</span>(A[i],m);</span><br><span class="line">        <span class="built_in">IFWT</span>();</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,R<span class="number">-1</span>) ans+=A[i].x,<span class="built_in">Mod1</span>(ans);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) A[i].x=A[i].y=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeChef/Codechef%20March%20Challenge%202021%20Div2%20Consecutive%20Adding/</url>
    <content><![CDATA[<hr />
<p>title: 'Codechef March Challenge 2021 Div2 Consecutive
Adding(CONSADD)' date: 'Sat Aug 12 11:05:24 2023 categories: -
oi-solutions'</p>
<h1
id="codechef-march-challenge-2021-div2-consecutive-addingconsadd">Codechef
March Challenge 2021 Div2 Consecutive Adding(CONSADD)</h1>
<p>题目大意：</p>
<p>给定两个 <span class="math inline">\(n\times m\)</span> 矩阵 <span
class="math inline">\(A\)</span> ， <span
class="math inline">\(B\)</span> 和一个常数 <span
class="math inline">\(x\)</span></p>
<p>现在对于 <span class="math inline">\(A\)</span>
操作，每次可以选择一行或者一列连续的 <span
class="math inline">\(x\)</span> 个，一起改变同一个数值 <span
class="math inline">\(v\in \Z\)</span></p>
<p>判断是否可以由 <span class="math inline">\(A\)</span> 变成 <span
class="math inline">\(B\)</span></p>
<p><br></p>
<p>显然可以先将 <span class="math inline">\(A,B\)</span>
作差，转化为操作成0矩阵</p>
<p>进一步，我们将 <span class="math inline">\(A\)</span>
矩阵行内差分，使得每次行操作变为一个单点 <span
class="math inline">\(A_{i,j}+v\)</span> ，一个单点 <span
class="math inline">\(A_{i,j+x}-v\)</span></p>
<p>在此基础上，继续差分即可将行列操作都转化为单点操作</p>
<p>此时容易发现， <span class="math inline">\(A_{i,j}\)</span>
的数值有关联的部分都是 <span
class="math inline">\(A_{i,j},A_{i+x,j},A_{i,j+x}\cdots
A_{i+ax,j+bx}\)</span></p>
<p>也就是相差 <span class="math inline">\(x\)</span>
的，考虑可以将这一部分子矩形提取出来，这样问题变成了</p>
<p>每次操作一个数 <span class="math inline">\(A_{i,j}+v\)</span>
，可以选择相邻一个数 <span class="math inline">\(A_{i,j+1}\)</span> 或
<span class="math inline">\(A_{i+1,j}\)</span> 去 <span
class="math inline">\(-v\)</span></p>
<p>对于每个这样的子问题，容易发现有解的充要条件：子矩阵元素和为0</p>
<p>（可以依次考虑每个元素贪心构造方案）</p>
<p>如此可以 <span class="math inline">\(O(nm)\)</span> 判定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line">ll A[N][N],B[N][N];</span><br><span class="line"><span class="type">int</span> V[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">		n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,m+<span class="number">1</span>) A[i][j]=V[i][j]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,m) A[i][j]=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,m) A[i][j]-=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) <span class="built_in">drep</span>(j,m+<span class="number">1</span>,<span class="number">1</span>) A[i][j]-=A[i][j<span class="number">-1</span>];</span><br><span class="line">		<span class="built_in">drep</span>(i,n+<span class="number">1</span>,<span class="number">1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,m+<span class="number">1</span>) A[i][j]-=A[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="comment">// 3 次作差</span></span><br><span class="line">		<span class="type">int</span> f=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,m+<span class="number">1</span>) <span class="keyword">if</span>(!V[i][j]) &#123;</span><br><span class="line">			ll s=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 子问题判定</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> a=i;a&lt;=n+<span class="number">1</span>;a+=k) <span class="keyword">for</span>(<span class="type">int</span> b=j;b&lt;=m+<span class="number">1</span>;b+=k) &#123;</span><br><span class="line">				V[a][b]=<span class="number">1</span>;</span><br><span class="line">				s+=A[a][b];</span><br><span class="line">			&#125;</span><br><span class="line">			f&amp;=s==<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(f?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeChef/Codechef%20March%20Challenge%202021%20Random%20Walk%20Queries/</url>
    <content><![CDATA[<hr />
<p>title: '<a
href="https://www.codechef.com/MARCH21B/problems/RWALKS">Codechef March
Challenge 2021 Random Walk Queries(RWALKS) (动态点分治)</a>' date: 'Sat
Aug 12 11:05:24 2023 categories: - oi-solutions'</p>
<h1
id="codechef-march-challenge-2021-random-walk-queriesrwalks-动态点分治"><a
href="https://www.codechef.com/MARCH21B/problems/RWALKS">Codechef March
Challenge 2021 Random Walk Queries(RWALKS) (动态点分治)</a></h1>
<p>题目大意：</p>
<p>对于给定的无根树 <span class="math inline">\(T\)</span>
，要求强制在线维护两种操作</p>
<p>1.游走 <span class="math inline">\((u,d)\)</span> ，以 <span
class="math inline">\(u\)</span> 为根在树上游走，从 <span
class="math inline">\(u\)</span> 开始，最多走 <span
class="math inline">\(d\)</span> 步，每次随机从儿子中选择一个点</p>
<p>2.查询 <span class="math inline">\(u\)</span> ，当前 <span
class="math inline">\(u\)</span> 被遍历的期望次数</p>
<p><span class="math display">\[ \ \]</span></p>
<p><del>灵光一闪想到这么个憨批树上结构</del></p>
<p>对于更新 <span class="math inline">\((u,d)\)</span> ，考虑 <span
class="math inline">\(u\)</span> <strong>跨过当前点分根</strong>
到达其他点分子树里的贡献</p>
<p>一个点由当前点分根到达的概率是一个定值，可以预处理出来，并在查询时计算</p>
<p>因此更新贡献时，可以描述为 <span class="math inline">\(dep\leq
d\)</span> 的点接受到 以 <span class="math inline">\(x\)</span>
的概率访问当前点分根</p>
<p>可以简单用树状数组维护</p>
<p>为了剔除对于自己所在子树的非法贡献，需要额外开一些树状数组来维护</p>
<p>一个节点有 <span class="math inline">\(\log n\)</span>
个点分父节点，每次需要两次树状数组查询</p>
<p>因此查询部分复杂度为 <span class="math inline">\(O(m\log
^2n)\)</span> ，预处理以及空间复杂度为 <span
class="math inline">\(O(n\log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,K=<span class="number">19</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,I[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt,deg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=ecnt,deg[v]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erep(u) for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	<span class="built_in">BIT</span>()&#123;&#125;;</span><br><span class="line">	<span class="built_in">BIT</span>(<span class="type">int</span> n):<span class="built_in">n</span>(n)&#123; s.<span class="built_in">resize</span>(n+<span class="number">1</span>); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x)</span></span>&#123; </span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">cmin</span>(p,n);p;p-=p&amp;-p) s[p]+=x,<span class="built_in">Mod1</span>(s[p]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Que</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(p&lt;=n) res+=s[p],<span class="built_in">Mod1</span>(res),p+=p&amp;-p;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; T[N];</span><br><span class="line">vector &lt;BIT&gt; G[N];</span><br><span class="line"><span class="comment">//  Dep:点分树上的dep，id:节点在每层的编号， dep:节点在每层的dep，s:节点在每层由根到达的系数</span></span><br><span class="line"><span class="type">int</span> Dep[N],id[K][N],dep[K][N],s[K][N],vis[N],sz[N],fa[N],Root;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mi,rt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindRt</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ma=<span class="number">0</span>; sz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">erep</span>(u) <span class="keyword">if</span>(v!=f &amp;&amp; !vis[v]) &#123;</span><br><span class="line">		<span class="built_in">FindRt</span>(n,v,u);</span><br><span class="line">		sz[u]+=sz[v],<span class="built_in">cmax</span>(ma,sz[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cmax</span>(ma,n-sz[u]);</span><br><span class="line">	<span class="keyword">if</span>(mi&gt;ma) mi=ma,rt=u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> D,maxd;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="built_in">cmax</span>(maxd,dep[D][u]=dep[D][f]+<span class="number">1</span>),::id[D][u]=id;</span><br><span class="line">	<span class="built_in">erep</span>(u) <span class="keyword">if</span>(v!=f &amp;&amp; !vis[v]) &#123;</span><br><span class="line">		s[D][v]=<span class="number">1ll</span>*s[D][u]*I[deg[u]<span class="number">-1</span>]%P;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u,id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理点分治，开树状数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Divide</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	mi=<span class="number">1e9</span>,<span class="built_in">FindRt</span>(n,u,<span class="number">0</span>),u=rt;</span><br><span class="line">	<span class="type">int</span> sonc=<span class="number">0</span>;</span><br><span class="line">	vis[u]=s[Dep[u]=D][u]=<span class="number">1</span>,id[D][u]=<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">erep</span>(u) <span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">		maxd=<span class="number">0</span>;</span><br><span class="line">		s[D][v]=<span class="number">1</span>,<span class="built_in">dfs</span>(v,u,sonc);</span><br><span class="line">		G[u].<span class="built_in">pb</span>(<span class="built_in">BIT</span>(maxd));</span><br><span class="line">		sonc++;</span><br><span class="line">		<span class="built_in">cmax</span>(t,maxd);</span><br><span class="line">	&#125;</span><br><span class="line">	T[u]=<span class="built_in">BIT</span>(t);</span><br><span class="line">	<span class="built_in">erep</span>(u) <span class="keyword">if</span>(!vis[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(sz[v]&gt;sz[u]) sz[v]=n-sz[u];</span><br><span class="line">		D++,fa[<span class="built_in">Divide</span>(sz[v],v)]=u,D--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Que</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	ll ans=sum[u];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=u,d=Dep[v];(d--,v=fa[v]);) </span><br><span class="line">		ans=(ans+ <span class="number">1ll</span>* (T[v].<span class="built_in">Que</span>(dep[d][u])+G[v][id[d][u]].<span class="built_in">Que</span>(dep[d][u])) *s[d][u])%P;</span><br><span class="line">	<span class="keyword">return</span> (ans%P+P)%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Upd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	sum[u]++,<span class="built_in">Mod1</span>(sum[u]),T[u].<span class="built_in">Add</span>(d,I[deg[u]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=fa[u],D=Dep[u]<span class="number">-1</span>;v;v=fa[v],D--) &#123;</span><br><span class="line">		<span class="keyword">if</span>(d&lt;dep[D][u]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> x=<span class="number">1ll</span>*I[deg[u]]*s[D][u]%P;</span><br><span class="line">		sum[v]+=x,<span class="built_in">Mod1</span>(sum[v]);</span><br><span class="line">		x=<span class="number">1ll</span>*x*I[deg[v]<span class="number">-1</span>]%P;</span><br><span class="line">		T[v].<span class="built_in">Add</span>(d-dep[D][u],x),G[v][id[D][u]].<span class="built_in">Add</span>(d-dep[D][u],P-x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lst;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">rd</span>()+lst)%n+<span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	I[<span class="number">0</span>]=I[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-1</span>) I[i]=<span class="number">1ll</span>*(P-P/i)*I[P%i]%P;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">AddEdge</span>(u,v),<span class="built_in">AddEdge</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	Root=<span class="built_in">Divide</span>(n,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> opt=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> u=<span class="built_in">Get</span>(),d=<span class="built_in">Get</span>();</span><br><span class="line">			<span class="built_in">Upd</span>(u,d);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lst=<span class="built_in">Que</span>(<span class="built_in">Get</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeChef/Codechef%20Red-Black%20Boolean%20Expression/</url>
    <content><![CDATA[<hr />
<p>title: 'CodeChef 2020 November Challenge - Red-Black Boolean
Expression' date: 'Sat Aug 12 11:05:24 2023 categories: -
oi-solutions'</p>
<h1
id="codechef-2020-november-challenge---red-black-boolean-expression">CodeChef
2020 November Challenge - Red-Black Boolean Expression</h1>
<p>吐槽：这题很蠢，很套路</p>
<p>题目大意：</p>
<p>给定 <span class="math inline">\(n\)</span> 个布尔变量 <span
class="math inline">\(x_i\)</span> ，每个变量有其反变量 <span
class="math inline">\(\overline {x_i}\)</span></p>
<p>有 <span class="math inline">\(n\)</span> 组关系 <span
class="math inline">\(a_i,b_i\)</span> ，要求 <span
class="math inline">\(a_i\lor b_i\)</span> 为真</p>
<p>并且保证所有 <span class="math inline">\(a_i,b_i\)</span>
关系构成一张二分图，其中 <span class="math inline">\(x_i\)</span> 与
<span class="math inline">\(\overline{x_i}\)</span> 有一条边相连</p>
<p>给定每个变量的初始值 <span class="math inline">\(s_i\)</span>
，以及翻转其所需的代价 <span class="math inline">\(C_i\)</span>
，求最小满足条件的代价</p>
<p><span class="math display">\[  \ \]</span></p>
<p><span class="math inline">\(a_i\lor b_i\)</span> 为真即不存在 <span
class="math inline">\(a_i,b_i\)</span> 均为假的情况</p>
<p>如果是2-sat上的理解，即可以由 <span
class="math inline">\(a_i\)</span> 假推 <span
class="math inline">\(b_i\)</span> 真， <span
class="math inline">\(b_i\)</span> 假推 <span
class="math inline">\(a_i\)</span> 真，但是 <span
class="math inline">\(2-sat\)</span> 没法带权</p>
<p>由于题目保证了关系的二分图性质，不妨把所有变量分成两个集合 <span
class="math inline">\(A,B\)</span></p>
<p>这个问题令人联想到网络流最小割模型，我们用一条边 <span
class="math inline">\((u,v)\)</span> 限制 <span
class="math inline">\((u,v)\)</span> 不同时为假的情况</p>
<p>对于 <span class="math inline">\(A\)</span> 中的点，我们令源点 <span
class="math inline">\(S\)</span> 向 <span
class="math inline">\(u\)</span> 连的边 <span
class="math inline">\((S,u,w)\)</span> 表示 <span
class="math inline">\(u\)</span> 变成 <span
class="math inline">\(0\)</span> 所需代价，令 <span
class="math inline">\((u,T,w)\)</span> 表示 <span
class="math inline">\(u\)</span> 变成1的代价</p>
<p>对于 <span class="math inline">\(B\)</span>
中的点，采取相反的连接方式</p>
<p>任意一个关系的两点不在同一集合，不妨对于 <span
class="math inline">\(u\in A\)</span>
的情况考虑，实际上可以分为两类考虑</p>
<ol type="1">
<li><p><span class="math inline">\((u,v)\)</span>
不同时为0，那么连接一条边 <span
class="math inline">\((v,u,\infty)\)</span> ，表示如果合法必然有一条让
<span class="math inline">\(u\)</span> 或 <span
class="math inline">\(v\)</span> 变成1的边被割掉</p></li>
<li><p><span class="math inline">\((u,v)\)</span> 不同时为1，连接一条边
<span class="math inline">\((v,u,\infty)\)</span> ，原理类似</p></li>
</ol>
<p>然后就可以跑网络流最小割了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,S,T;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt,w;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u],w&#125;;</span><br><span class="line">	head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123; </span><br><span class="line">	<span class="built_in">AddEdge</span>(u,v,w),<span class="built_in">AddEdge</span>(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> F[N],X[N],Y[N],col[N],A[N];</span><br><span class="line"><span class="comment">// 这里我用带权并查集实现了二分图</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(F[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="type">int</span> f=F[x]; F[x]=<span class="built_in">Find</span>(F[x]);</span><br><span class="line">	col[x]^=col[f];</span><br><span class="line">	<span class="keyword">return</span> F[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,T) dis[i]=INF;</span><br><span class="line">	<span class="type">static</span> queue &lt;<span class="type">int</span>&gt; que;</span><br><span class="line">	dis[S]=<span class="number">0</span>; que.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u=que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt) &#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(!w || dis[v]&lt;=dis[u]+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			dis[v]=dis[u]+<span class="number">1</span>,que.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[T]&lt;INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> in)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==T) <span class="keyword">return</span> in;</span><br><span class="line">	<span class="type">int</span> out=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt) &#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to,w=e[i].w;</span><br><span class="line">		<span class="keyword">if</span>(!w || dis[v]!=dis[u]+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> t=<span class="built_in">Dfs</span>(v,<span class="built_in">min</span>(in-out,w));</span><br><span class="line">		e[i].w-=t,e[i^<span class="number">1</span>].w+=t,out+=t;</span><br><span class="line">		<span class="keyword">if</span>(in==out) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!out) dis[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>; </span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">Bfs</span>()) ans+=<span class="built_in">Dfs</span>(S,INF);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">		n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) F[i]=i,col[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">		S=n+<span class="number">1</span>,T=n+<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) A[i]=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">			X[i]=<span class="built_in">rd</span>(),Y[i]=<span class="built_in">rd</span>();</span><br><span class="line">			<span class="type">int</span> x=<span class="built_in">abs</span>(X[i]),y=<span class="built_in">abs</span>(Y[i]);</span><br><span class="line">			<span class="type">int</span> u=<span class="built_in">Find</span>(x),v=<span class="built_in">Find</span>(y);</span><br><span class="line">			<span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;</span><br><span class="line">			F[u]=v,col[u]=col[x]^col[y]^(X[i]&lt;<span class="number">0</span>)^(Y[i]&lt;<span class="number">0</span>)^<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">Find</span>(i);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">			<span class="keyword">if</span>(col[i]^s[i]^<span class="string">&#x27;0&#x27;</span>) <span class="built_in">Link</span>(S,i,A[i]);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">Link</span>(i,T,A[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">			<span class="type">int</span> t=col[<span class="built_in">abs</span>(X[i])]^(X[i]&lt;<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">assert</span>(col[<span class="built_in">abs</span>(X[i])]^col[<span class="built_in">abs</span>(Y[i])]^(X[i]&lt;<span class="number">0</span>)^(Y[i]&lt;<span class="number">0</span>));</span><br><span class="line">			<span class="keyword">if</span>(t) <span class="built_in">Link</span>(<span class="built_in">abs</span>(X[i]),<span class="built_in">abs</span>(Y[i]),INF);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">Link</span>(<span class="built_in">abs</span>(Y[i]),<span class="built_in">abs</span>(X[i]),INF);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Dinic</span>());</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,T) head[i]=<span class="number">0</span>; ecnt=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/COCI2010-2011%20Contest#Final%20D%20/</url>
    <content><![CDATA[<hr />
<p>title: 'COCI20102011 Contest#Final D (dp)' date: 'Sat Aug 12 11:05:24
2023 categories: - oi-solutions'</p>
<h1 id="coci20102011-contestfinal-d-dp">COCI20102011 Contest#Final D
(dp)</h1>
<p>我们将一个操作序列看做由左右括号，空格构成的字符串，则序列大致长这个样子</p>
<p><span class="math inline">\(\text{_ ( ( ) _ ( ) ) ( _ ( ( ) ) (
}\)</span></p>
<p>很显然，一个失配的左括号只能在最外层出现，而空格可以出现在任意位置</p>
<p>dp一个括号序列让人想到区间dp，但是这个题目的区间实际只需要用长度就可以描述</p>
<p>令 <span class="math inline">\(dp[t][l][r][f1][f2]\)</span> 表示用
<span class="math inline">\(t\)</span> 的时间从 <span
class="math inline">\(l\)</span> 走到 <span
class="math inline">\(r\)</span> ， <span
class="math inline">\(f1\)</span> 表示是不是最外层括号， <span
class="math inline">\(f2\)</span> 表示当前 <span
class="math inline">\(dp\)</span>
是否受到<strong>单纯括号序列</strong>的限制</p>
<p>其中，引入的<strong>单纯括号序列</strong>是为了防止出现重复转移，其意思就是这个括号序列两端必须是一对匹配的左右括号，而中间随意</p>
<p>转移大致如下:</p>
<p>1.那么对于非单纯的括号序列，可以在序列插入空格或者失配的左括号(需要满足
<span class="math inline">\(f1\)</span> )，从 <span
class="math inline">\(dp[t-1]\)</span> 转移过来</p>
<p>2.对于任何的括号序列，都可以在两端找到匹配的的左右括号，从 <span
class="math inline">\(dp[t-2]\)</span> 转移过来，且完成匹配后 <span
class="math inline">\(f1\)</span> 应为 <span
class="math inline">\(0\)</span></p>
<p>3.且一个非单纯的括号序列是可以分割的，为了不重复，强制分割的左序列是单纯的即可</p>
<p>实际会发现，一个单纯的括号序列可以认为一定不是最外层括号，即 <span
class="math inline">\(f2\)</span> 为真时， <span
class="math inline">\(f1\)</span> 一定为假，所以可以压缩为三种状态</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(reg int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(reg int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">51</span>,P=<span class="number">10007</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,T;</span><br><span class="line"><span class="type">int</span> E[N][N];</span><br><span class="line"><span class="type">int</span> dp[N][N][N][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),T=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">memset</span>(E,<span class="number">-63</span>,<span class="keyword">sizeof</span> E);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>(),c=IO==<span class="string">&#x27; &#x27;</span>?<span class="built_in">getchar</span>():IO;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>) E[u][v]=c-<span class="string">&#x27;A&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>) E[u][v]=<span class="string">&#x27;a&#x27;</span>-c<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> E[u][v]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">1</span>) dp[<span class="number">0</span>][i][i][j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(k,<span class="number">1</span>,T)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(l,<span class="number">1</span>,n) <span class="built_in">rep</span>(r,(k&lt;T?<span class="number">1</span>:n),n) <span class="built_in">rep</span>(fl,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">rep</span>(fl2,<span class="number">0</span>,<span class="number">1</span>) &#123;</span><br><span class="line">            ll res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!fl2) &#123;</span><br><span class="line">                <span class="built_in">rep</span>(i,<span class="number">2</span>,k<span class="number">-1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) res+=dp[i][l][j][<span class="number">0</span>][<span class="number">1</span>]*dp[k-i][j][r][fl][<span class="number">0</span>];</span><br><span class="line">                <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(E[l][i]&gt;=<span class="number">0</span> &amp;&amp; (!E[l][i] || fl)) res+=dp[k<span class="number">-1</span>][i][r][fl][fl2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">1</span>) <span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">                <span class="keyword">if</span>(E[l][i]&gt;<span class="number">0</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) </span><br><span class="line">                    <span class="keyword">if</span>(E[j][r]+E[l][i]==<span class="number">0</span>) res+=dp[k<span class="number">-2</span>][i][j][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            dp[k][l][r][fl][fl2]=res%P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,T) ans+=dp[i][<span class="number">1</span>][n][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans%P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/COCI2011-2012%20Contest#1%20F/</url>
    <content><![CDATA[<hr />
<p>title: 'COCI2011/2012 Contest#1 F 状压加速dp' date: 'Sat Aug 12
11:05:24 2023 categories: - oi-solutions'</p>
<h1 id="coci20112012-contest1-f-状压加速dp">COCI2011/2012 Contest#1 F
状压加速dp</h1>
<p>首先是一个非常Naive的dp，令 <span
class="math inline">\(dp[i][x][y]\)</span> 表示 <span
class="math inline">\(i\)</span> 时刻 <span
class="math inline">\(x,y\)</span> 是否能被跳到</p>
<p>枚举，然后转移，如果滚动数组，就可以做到 <span
class="math inline">\(O(n^2)\)</span> 空间， <span
class="math inline">\(O(Tn^2)\)</span> 时间复杂度</p>
<p>这显然是TLE的。。。</p>
<p><span class="math display">\[ \ \]</span></p>
<p>注意到题目的 <span class="math inline">\(n\leq 30\)</span>
，可以直接用一个int存在某一行/列的答案</p>
<p>设时刻 <span class="math inline">\(i\)</span> 第 <span
class="math inline">\(j\)</span> 列的答案为 <span
class="math inline">\(dp[i][j]\)</span></p>
<p>假设不考虑答案的限制，两之间转移可以做到 <span
class="math inline">\(O(1)\)</span> ，即</p>
<ol type="1">
<li><p><span class="math inline">\(dp[i][j\pm 1]\)</span>
左/右移两位</p></li>
<li><p><span class="math inline">\(dp[i][j\pm 2]\)</span>
左/右移一位</p></li>
</ol>
<p>两者转移即可，但是涉及到倍数的限制，设 <span
class="math inline">\(can[i][j]\)</span> 为 <span
class="math inline">\(i\)</span> 时刻 <span
class="math inline">\(j\)</span> 列的可行跳跃位置</p>
<p>则只需要最后的时候让 <span class="math inline">\(dp[i][j]\)</span> 与
<span class="math inline">\(can[i][j]\)</span> 取交集即可</p>
<p>如果直接枚举倍数，复杂度上限是 <span class="math inline">\(O(n^2
T)\)</span></p>
<p>考虑分块决策，设将 <span class="math inline">\([1,D]\)</span>
的因数挑出来额外记录一个数组 <span
class="math inline">\(can2[x][j]\)</span> 表示值为 <span
class="math inline">\(x\)</span> 的第 <span
class="math inline">\(j\)</span> 列有那些</p>
<p>不直接枚举他们，而是在每次访问时考虑他们对于 <span
class="math inline">\(can[i][j]\)</span> 的贡献</p>
<p>在优秀实现下，复杂度上限为 <span
class="math inline">\(O(n^2\frac{T}{D+1}+T (D+\sum_{t=1}^{D} \frac{1}{t}
n))=O(n^2\frac{T}{D+1}+T (n\ln D+D))\)</span></p>
<p>这个实现上来说，就是枚举时间 <span class="math inline">\(i\)</span>
后，判断是否满足 <span class="math inline">\(t|i\)</span> ，然后再将
<span class="math inline">\(can2[t][j]\)</span> 贡献到 <span
class="math inline">\(can[i][j]\)</span></p>
<p>显然， <span class="math inline">\(t|i\)</span> 成立的次数就是 <span
class="math inline">\(T\sum_{t=1}^{D} \frac{1}{t}\)</span>
，也就是要循环这么多次取贡献 <span class="math inline">\(j\)</span>
这一维</p>
<p>调整一下 <span class="math inline">\(D\)</span> 的参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30</span>,D=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[N][N],dp[<span class="number">2</span>][N];</span><br><span class="line"><span class="type">int</span> can[<span class="number">1000010</span>][N],t[D+<span class="number">1</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="type">int</span> sx,sy; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;sx,&amp;sy),sx--,sy--;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">		<span class="keyword">if</span>(a[i][j]&lt;=D) t[a[i][j]][i]|=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">for</span>(reg <span class="type">int</span> T=a[i][j];T&lt;=m;T+=a[i][j]) can[T][i]|=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> cur=<span class="number">0</span>; dp[cur][sx]=<span class="number">1</span>&lt;&lt;sy;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,D) <span class="keyword">if</span>(i%j==<span class="number">0</span>) <span class="built_in">rep</span>(k,<span class="number">0</span>,n<span class="number">-1</span>) can[i][k]|=t[j][k];</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">			dp[!cur][j]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(j) &#123;</span><br><span class="line">				dp[!cur][j]|=dp[cur][j<span class="number">-1</span>]&lt;&lt;<span class="number">2</span>;</span><br><span class="line">				dp[!cur][j]|=dp[cur][j<span class="number">-1</span>]&gt;&gt;<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;n<span class="number">-1</span>) &#123;</span><br><span class="line">				dp[!cur][j]|=dp[cur][j+<span class="number">1</span>]&lt;&lt;<span class="number">2</span>;</span><br><span class="line">				dp[!cur][j]|=dp[cur][j+<span class="number">1</span>]&gt;&gt;<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;<span class="number">1</span>) &#123;</span><br><span class="line">				dp[!cur][j]|=dp[cur][j<span class="number">-2</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">				dp[!cur][j]|=dp[cur][j<span class="number">-2</span>]&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;n<span class="number">-2</span>) &#123;</span><br><span class="line">				dp[!cur][j]|=dp[cur][j+<span class="number">2</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">				dp[!cur][j]|=dp[cur][j+<span class="number">2</span>]&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dp[!cur][j]&amp;=can[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cur^=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(dp[cur][i]&amp;(<span class="number">1</span>&lt;&lt;j)) ans++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(dp[cur][i]&amp;(<span class="number">1</span>&lt;&lt;j)) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i+<span class="number">1</span>,j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/COCI2012-2013%20Contest#5%20F%20/</url>
    <content><![CDATA[<hr />
<p>title: 'COCI20122013 Contest#5 F' date: 'Sat Aug 12 11:05:24 2023
categories: - oi-solutions'</p>
<h1 id="coci20122013-contest5-f">COCI20122013 Contest#5 F</h1>
<p><del>不知道题解在写什么.jpg</del></p>
<h3 id="part1-naive的dp">Part1 : Naive的dp</h3>
<p>令 <span class="math inline">\(dp_{i,a,b,j}\)</span> 表示当前时刻
<span class="math inline">\(i\)</span> ，两队比分为 <span
class="math inline">\(a,b\)</span> ，球在 <span
class="math inline">\(j\)</span> 手上的概率</p>
<p>转移非常简单就不说了，单次转移为 <span
class="math inline">\(O(n)\)</span> ，复杂度为 <span
class="math inline">\(O(n^2r^2T)\)</span></p>
<p>在优秀卡常+O2下跑进700ms</p>
<p>优化的话: 1.float</p>
<p><del>2.分小块加速</del></p>
<p>3.循环展开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> db;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-12</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,R,T;</span><br><span class="line">db dp[<span class="number">510</span>][<span class="number">11</span>][<span class="number">11</span>][<span class="number">210</span>],p[<span class="number">410</span>],sz[<span class="number">410</span>],ans[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">&#125; e[<span class="number">80000</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">410</span>],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> E[<span class="number">410</span>][<span class="number">410</span>],G[<span class="number">410</span>][<span class="number">410</span>]; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> D=<span class="number">5</span>;</span><br><span class="line">db tmp[<span class="number">210</span>][<span class="number">1</span>&lt;&lt;D];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),R=<span class="built_in">rd</span>(),T=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="type">int</span> m=(n*<span class="number">2</span>+D<span class="number">-1</span>)/D;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;p[i]);</span><br><span class="line">		<span class="type">int</span> e=<span class="built_in">rd</span>(),f=<span class="built_in">rd</span>();</span><br><span class="line">		sz[i]=e+f+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,e) &#123;</span><br><span class="line">			<span class="type">int</span> x=<span class="built_in">rd</span>();</span><br><span class="line">			<span class="keyword">if</span>(i&gt;n) x+=n;</span><br><span class="line">			E[i][x]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,f) &#123;</span><br><span class="line">			<span class="type">int</span> x=<span class="built_in">rd</span>();</span><br><span class="line">			<span class="keyword">if</span>(i&lt;=n) x+=n;</span><br><span class="line">			E[i][x]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,m) &#123;</span><br><span class="line">			<span class="type">int</span> f=(j<span class="number">-1</span>)*D+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">rep</span>(k,<span class="number">0</span>,D<span class="number">-1</span>) G[i][j]|=E[i][f+k]&lt;&lt;k;</span><br><span class="line">			<span class="keyword">if</span>(G[i][j]) <span class="built_in">AddEdge</span>(i,j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(reg <span class="type">int</span> i=<span class="number">0</span>;i&lt;=T;++i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(reg <span class="type">int</span> a=<span class="number">0</span>;a&lt;=R;++a) &#123;</span><br><span class="line">			<span class="keyword">for</span>(reg <span class="type">int</span> b=<span class="number">0</span>;b&lt;=R;++b) &#123;</span><br><span class="line">				<span class="keyword">for</span>(reg <span class="type">int</span> j=<span class="number">1</span>;j&lt;=n*<span class="number">2</span>;++j) <span class="keyword">if</span>(dp[i][a][b][j]&gt;eps) &#123;</span><br><span class="line">					<span class="keyword">if</span>(a==R || b==R || i==T) &#123; ans[a][b]+=dp[i][a][b][j]; <span class="keyword">continue</span>; &#125;</span><br><span class="line">					db t=dp[i][a][b][j]/sz[j];</span><br><span class="line">					<span class="keyword">for</span>(reg <span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k+=<span class="number">4</span>) &#123;</span><br><span class="line">						tmp[k][G[j][k]]+=t;</span><br><span class="line">						tmp[k+<span class="number">1</span>][G[j][k+<span class="number">1</span>]]+=t;</span><br><span class="line">						tmp[k+<span class="number">2</span>][G[j][k+<span class="number">2</span>]]+=t;</span><br><span class="line">						tmp[k+<span class="number">3</span>][G[j][k+<span class="number">3</span>]]+=t;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(j&lt;=n) &#123;</span><br><span class="line">						dp[i+<span class="number">1</span>][a][b][n+<span class="number">1</span>]+=t*(<span class="number">1</span>-p[j]);</span><br><span class="line">						dp[i+<span class="number">1</span>][a+<span class="number">1</span>][b][n+<span class="number">1</span>]+=t*p[j];</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						dp[i+<span class="number">1</span>][a][b][<span class="number">1</span>]+=t*(<span class="number">1</span>-p[j]);</span><br><span class="line">						dp[i+<span class="number">1</span>][a][b+<span class="number">1</span>][<span class="number">1</span>]+=t*p[j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span>(reg <span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j) &#123;</span><br><span class="line">					<span class="type">int</span> f=(j<span class="number">-1</span>)*D+<span class="number">1</span>;</span><br><span class="line">					<span class="built_in">rep</span>(k,<span class="number">1</span>,(<span class="number">1</span>&lt;&lt;D)<span class="number">-1</span>) &#123;</span><br><span class="line">						(k&amp;<span class="number">1</span>) &amp;&amp;  (dp[i+<span class="number">1</span>][a][b][f]+=tmp[j][k]);</span><br><span class="line">						(k&amp;<span class="number">2</span>) &amp;&amp;  (dp[i+<span class="number">1</span>][a][b][f+<span class="number">1</span>]+=tmp[j][k]);</span><br><span class="line">						(k&amp;<span class="number">4</span>) &amp;&amp;  (dp[i+<span class="number">1</span>][a][b][f+<span class="number">2</span>]+=tmp[j][k]);</span><br><span class="line">						(k&amp;<span class="number">8</span>) &amp;&amp;  (dp[i+<span class="number">1</span>][a][b][f+<span class="number">3</span>]+=tmp[j][k]);</span><br><span class="line">						(k&amp;<span class="number">16</span>) &amp;&amp;  (dp[i+<span class="number">1</span>][a][b][f+<span class="number">4</span>]+=tmp[j][k]);</span><br><span class="line">						tmp[j][k]=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,R) <span class="built_in">rep</span>(j,<span class="number">0</span>,R) <span class="keyword">if</span>(i!=R || j!=R) <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,ans[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[\  \]</span></p>
<h3 id="part2-状态割裂">Part2: 状态割裂</h3>
<p>定义每个球进的时间为关键点，我们发现关键点的状态非常单一，只有两种</p>
<p>一个合法的转移序列可以被分为若干关键点的段以及最后一段到达 <span
class="math inline">\(T\)</span> 之后停止转移</p>
<p>考虑预处理两个关键点之间的转移概率</p>
<p>令 <span class="math inline">\(g_{a,b,i}\)</span> 为当球在 <span
class="math inline">\(a\)</span> 队一号队员时， <span
class="math inline">\(i\)</span> 次后 <span
class="math inline">\(b\)</span> 队进球的概率</p>
<p>可以枚举 <span class="math inline">\(a\)</span> ，类似上面的 <span
class="math inline">\(dp\)</span> ，去掉比分的一维即可</p>
<p>预处理复杂度为 <span class="math inline">\(O(Tn^2)\)</span></p>
<p>然后 <span class="math inline">\(dp\)</span>
时直接枚举两个关键点转移，令</p>
<p><span class="math inline">\(h_{i,a,b,j}\)</span> 时刻 <span
class="math inline">\(i\)</span> 比分为 <span
class="math inline">\(a,b\)</span> ，球在 <span
class="math inline">\(j\)</span> 队一号队员手上的概率</p>
<p>转移分两种</p>
<p>1.枚举下一个在 <span class="math inline">\(T\)</span>
以内的关键点转移</p>
<p>复杂度为 <span class="math inline">\(O(T)\)</span></p>
<p>2.考虑在 <span class="math inline">\(T\)</span>
以内的时间不再出现进球了</p>
<p>需要预处理出当球在 <span class="math inline">\(i\)</span> 队手上时，
<span class="math inline">\(j\)</span> 次内出现进球的概率 <span
class="math inline">\(s_{i,j}\)</span> ，这个直接由 <span
class="math inline">\(g\)</span> 数组累前缀和即可</p>
<p><span class="math inline">\(dp\)</span> 关键点的复杂度为 <span
class="math inline">\(O(T^2r^2)\)</span></p>
<p>大概比上面代码快4-5倍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span> db;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">    T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-12</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,R,T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125; e[<span class="number">80000</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">410</span>],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++ecnt]=(Edge)&#123;v,head[u]&#125;;</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line">db p[<span class="number">410</span>],sz[<span class="number">410</span>],ans[<span class="number">11</span>][<span class="number">11</span>],f[<span class="number">510</span>][<span class="number">210</span>],g[<span class="number">2</span>][<span class="number">2</span>][<span class="number">510</span>],s[<span class="number">2</span>][<span class="number">510</span>];</span><br><span class="line"><span class="comment">// g[i][j][k] 在i拿球的情况下，j在第k次进球了</span></span><br><span class="line">db h[<span class="number">510</span>][<span class="number">11</span>][<span class="number">11</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),R=<span class="built_in">rd</span>(),T=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;p[i]);</span><br><span class="line">        <span class="type">int</span> e=<span class="built_in">rd</span>(),f=<span class="built_in">rd</span>();</span><br><span class="line">        sz[i]=e+f+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,e) &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="keyword">if</span>(i&gt;n) x+=n;</span><br><span class="line">            <span class="built_in">AddEdge</span>(i,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,f) &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=n) x+=n;</span><br><span class="line">            <span class="built_in">AddEdge</span>(i,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(d,<span class="number">0</span>,<span class="number">1</span>) &#123;</span><br><span class="line">        f[<span class="number">0</span>][d*n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,T) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(j,<span class="number">1</span>,n*<span class="number">2</span>) <span class="keyword">if</span>(f[i][j]&gt;eps) &#123;</span><br><span class="line">                db t=f[i][j]/sz[j];</span><br><span class="line">                <span class="keyword">for</span>(reg <span class="type">int</span> k=head[j];k;k=e[k].nxt) f[i+<span class="number">1</span>][e[k].to]+=t;</span><br><span class="line">                f[i+<span class="number">1</span>][j&gt;n?<span class="number">1</span>:n+<span class="number">1</span>]+=t*(<span class="number">1</span>-p[j]);</span><br><span class="line">                g[d][j&gt;n][i+<span class="number">1</span>]+=t*p[j];</span><br><span class="line">                f[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,T) &#123;</span><br><span class="line">            s[d][i]=g[d][<span class="number">0</span>][i]+g[d][<span class="number">1</span>][i];</span><br><span class="line">            <span class="keyword">if</span>(i) s[d][i]+=s[d][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,T) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(a,<span class="number">0</span>,R) <span class="built_in">rep</span>(b,<span class="number">0</span>,R) <span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">1</span>) <span class="keyword">if</span>(h[i][a][b][j]&gt;eps) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a==R || b==R || i==T)&#123; ans[a][b]+=h[i][a][b][j]; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="built_in">rep</span>(k,<span class="number">1</span>,T-i) &#123;</span><br><span class="line">                <span class="comment">// 能在结束前产生一次进球</span></span><br><span class="line">                h[i+k][a+<span class="number">1</span>][b][<span class="number">1</span>]+=h[i][a][b][j]*g[j][<span class="number">0</span>][k];</span><br><span class="line">                h[i+k][a][b+<span class="number">1</span>][<span class="number">0</span>]+=h[i][a][b][j]*g[j][<span class="number">1</span>][k];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[a][b]+=h[i][a][b][j]*(<span class="number">1</span>-s[j][T-i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,R) <span class="built_in">rep</span>(j,<span class="number">0</span>,R) <span class="keyword">if</span>(i&lt;R || j&lt;R) <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,ans[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/COCI2013-2014%20Contest#1%20F%20/</url>
    <content><![CDATA[<hr />
<p>title: 'COCI2013-2014 Contest#1 F SLASTIČAR' date: 'Sat Aug 12
11:05:24 2023 categories: - oi-solutions'</p>
<h1 id="coci2013-2014-contest1-f-slastičar">COCI2013-2014 Contest#1 F
SLASTIČAR</h1>
<p>其实挺妙的一个数据结构题</p>
<p>题意: 给定一个A串，对于查询的每个 <span
class="math inline">\(B\)</span> 串，从头开始匹配匹配 <span
class="math inline">\(A\)</span> 的每个后缀，每次匹配失败的代价是 <span
class="math inline">\(\text{LCP}+1\)</span> 可，匹配成功的代价是 <span
class="math inline">\(|B|\)</span> ，且立即停止，求代价总和</p>
<p>设 <span class="math inline">\(A\)</span> 串长为 <span
class="math inline">\(n\)</span> ，查询个数为 <span
class="math inline">\(q\)</span> ，查询总长为 <span
class="math inline">\(m\)</span></p>
<p>我们知道求两个串的 <span class="math inline">\(\text{LCP}\)</span>
可以把两个串中间放一个符号分开，跑后缀数组/后缀自动机</p>
<p>但是首先是 <span class="math inline">\(m=3\cdot 10^6\)</span>
，内存就开不下</p>
<p>而且发现，如果 <span class="math inline">\(|B|\)</span>
的某个前缀未出现在 <span class="math inline">\(A\)</span>
中，后面的部分都不造成贡献，所以可以在 <span
class="math inline">\(A\)</span> 串中定位 <span
class="math inline">\(B\)</span> 的每个前缀</p>
<p>这样就只需要求 <span class="math inline">\(A\)</span>
的后缀数组即可，然而，这个并不好实现</p>
<p>假设当前已经定位了一个长度为 <span class="math inline">\(i\)</span>
的前缀，其对应的合法后缀排名范围为 <span
class="math inline">\([L_i,R_i]\)</span></p>
<p>那么接下来就是在当前前缀上接上下一个字符 <span
class="math inline">\(c\)</span> ，这个如果再外加数据结构并不好实现</p>
<p>考虑后缀数组的性质， <span class="math inline">\([L_i,R_i]\)</span>
这些后缀前 <span class="math inline">\(d\)</span> 个字符相同， <span
class="math inline">\(d+1\)</span> 个字符呈单调非递减</p>
<p>所以字符 <span class="math inline">\(c\)</span>
出现的范围也一定是一段区间，可以直接两次二分得到</p>
<p>这样查询 <span class="math inline">\([L_i,R_i]\)</span> 的复杂度为
<span class="math inline">\(\log n\)</span> ，这样就用 <span
class="math inline">\(O(m\log n)\)</span> 的复杂度完成了串定位</p>
<p>如果不考虑每次完成匹配后停止，其实答案就是 <span
class="math inline">\(\sum R_i-L_i+1\)</span> ，即 <span
class="math inline">\(\sum_i LCP_i=\sum_i \sum_j [LCP_j\ge
i]\)</span></p>
<p>设最终的匹配位置为 <span class="math inline">\(p\)</span>
，这个位置可以用线段树在最后的一段 <span
class="math inline">\([L_{|B|},R_{|B|}]\)</span> 中求最小值得到</p>
<p>考虑减掉多余的部分，即减去实际位置 <span
class="math inline">\(&gt;p\)</span> 的且在后缀数组排名在 <span
class="math inline">\([L_i,R_i]\)</span> 中的部分</p>
<p>可以把所有的 <span class="math inline">\([L_i,R_i]\)</span>
拿出来作为，离线询问，用树状数组维护查询，复杂度为 <span
class="math inline">\(O((n+m)\log n)\)</span></p>
<p>因此总复杂度为 <span class="math inline">\(O((n+m)\log
n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[N],t[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rk[N&lt;&lt;<span class="number">1</span>],tmp[N],cnt[N],sa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) cnt[<span class="built_in">int</span>(s[i])]++;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">200</span>) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) rk[i]=cnt[(<span class="type">int</span>)s[i]],sa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(reg <span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(reg <span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i) cnt[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(reg <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cnt[rk[i+k]]++;</span><br><span class="line">        <span class="keyword">for</span>(reg <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(reg <span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i) tmp[cnt[rk[i+k]]--]=i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(reg <span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i) cnt[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(reg <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cnt[rk[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(reg <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(reg <span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i) sa[cnt[rk[tmp[i]]]--]=tmp[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(reg <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) tmp[sa[i]]=tmp[sa[i<span class="number">-1</span>]]+(rk[sa[i]]!=rk[sa[i<span class="number">-1</span>]]||rk[sa[i]+k]!=rk[sa[i<span class="number">-1</span>]+k]);</span><br><span class="line">        <span class="keyword">for</span>(reg <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) rk[i]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindChar</span><span class="params">(<span class="type">int</span> &amp;l,<span class="type">int</span> &amp;r,<span class="type">int</span> len,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tl=l,tr=r;</span><br><span class="line">    <span class="type">int</span> lres=<span class="number">-1</span>,rres=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[sa[mid]+len]&lt;=c) l=mid+<span class="number">1</span>,lres=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lres==<span class="number">-1</span> || s[sa[lres]+len]!=c) &#123; l=<span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    l=tl,r=tr;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[sa[mid]+len]&gt;=c) r=mid<span class="number">-1</span>,rres=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    l=rres,r=lres;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="type">int</span> ql[M],qr[M],qid[M],qnxt[M];</span><br><span class="line"><span class="type">int</span> head[N],qc;</span><br><span class="line"><span class="type">int</span> L[N],R[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">    <span class="type">int</span> s[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">while</span>(p&lt;=n) s[p]++,p+=p&amp;-p; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Que</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p) res+=s[p],p-=p&amp;-p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Que</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">Que</span>(r)-<span class="built_in">Que</span>(l<span class="number">-1</span>); &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> s[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r) &#123; s[p]=sa[l]; <span class="keyword">return</span> ;&#125;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        s[p]=<span class="built_in">min</span>(s[p&lt;&lt;<span class="number">1</span>],s[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Que</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) <span class="keyword">return</span> s[p];</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,res=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">if</span>(ql&lt;=mid) <span class="built_in">cmin</span>(res,<span class="built_in">Que</span>(p&lt;&lt;<span class="number">1</span>,l,mid,ql,qr));</span><br><span class="line">        <span class="keyword">if</span>(qr&gt;mid) <span class="built_in">cmin</span>(res,<span class="built_in">Que</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;SGT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Build</span>(n),<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    SGT.<span class="built_in">Build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line">        L[<span class="number">0</span>]=<span class="number">1</span>,R[<span class="number">0</span>]=n;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>,pos=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;t[j];++j) &#123;</span><br><span class="line">            L[len=j]=L[j<span class="number">-1</span>],R[j]=R[j<span class="number">-1</span>];</span><br><span class="line">            <span class="built_in">FindChar</span>(L[j],R[j],j<span class="number">-1</span>,t[j]);</span><br><span class="line">            <span class="keyword">if</span>(!L[j])&#123; pos=<span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            ans[i]+=R[j]-L[j]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos &amp;&amp; (pos=SGT.<span class="built_in">Que</span>(<span class="number">1</span>,<span class="number">1</span>,n,L[len],R[len]))&lt;n) &#123;</span><br><span class="line">            ans[i]+=pos<span class="number">-1</span>,pos++;</span><br><span class="line">            <span class="built_in">rep</span>(j,<span class="number">1</span>,len)&#123;</span><br><span class="line">                qc++,ql[qc]=L[j],qr[qc]=R[j],qid[qc]=i,qnxt[qc]=head[pos];</span><br><span class="line">                head[pos]=qc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> ans[i]+=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">drep</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">        T.<span class="built_in">Add</span>(rk[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[i];j;j=qnxt[j]) ans[qid[j]]-=T.<span class="built_in">Que</span>(ql[j],qr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/COCI2013-2014%20Contest#3%20F/</url>
    <content><![CDATA[<hr />
<p>title: 'COCI2013-2014 Contest#3 F 单调栈' date: 'Sat Aug 12 11:05:24
2023 categories: - oi-solutions'</p>
<h1 id="coci2013-2014-contest3-f-单调栈">COCI2013-2014 Contest#3 F
单调栈</h1>
<p>考虑每个小区间 <span class="math inline">\([x_i,x_{i+1}]\)</span>
中，外部光照进来只能是这样</p>
<figure>
<img src="https://i.loli.net/2020/09/03/ZojvbGetxOIMmXF.png"
alt="Light1.png" />
<figcaption aria-hidden="true">Light1.png</figcaption>
</figure>
<p>其中两边是光源，红色表示被照到了</p>
<p>那么所有合法的被照到的段可以表示为 <span
class="math inline">\([x_i,x_{i+1}]\)</span> 中的两个小段，即</p>
<p>1.左边照进来的 <span
class="math inline">\([s0_i,x_{i+1}]\)</span></p>
<p>2.右边照进来的 <span class="math inline">\([x_i,s1_i]\)</span></p>
<p>考虑从左到右维护可能照到右边的<strong>较优光源</strong></p>
<p>显然对于每一个光源都有一个<strong>当前能遮住它最多</strong>的城市，构成(光源，限制城市)这样的点对</p>
<p>对于每一个<strong>较优的</strong>这样的点对
可以维护一个<strong>单调栈</strong>，维护出来应该是这样的</p>
<figure>
<img src="https://i.loli.net/2020/09/03/jgtAk8omSYafON3.png"
alt="Light2.png" />
<figcaption aria-hidden="true">Light2.png</figcaption>
</figure>
<p>有几个较为显然的性质:</p>
<p>1.所有点对的 <span class="math inline">\(h_i\)</span>
<strong>递减</strong>，否则要么是上一个光源被完全遮住了，要么是这个点可以遮住上一个光源更多</p>
<p>2.靠右的点对能够覆盖的范围较大，即可行区间的左端点较小</p>
<p>否则它此时不会产生贡献，而当后面较高的点进来时，相对更矮的它也更容易被遮住</p>
<p>实际上，这样的形状就会构成一个类似上凸包的东西，但是凸包上只有一部分点产生贡献</p>
<p><span class="math display">\[  \ \]</span></p>
<p>考虑依次加入点 <span class="math inline">\((x_i,h_i)\)</span>
，显然可以弹掉 <span class="math inline">\(h_j&lt;h_i\)</span>
的所有点对(为了防止下面计算左端点时出现问题)</p>
<p>接下来的情况，类似维护凸包，但是要考虑更新限制城市 或者 弹掉点对</p>
<p><span class="math display">\[ \ \]</span></p>
<p>对于向左的情况，反着求一遍即可，最后可以减去两种区间都覆盖不到的部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,D;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">City</span>&#123; <span class="type">int</span> k,x,h; &#125; C[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Lightpair</span>&#123;</span><br><span class="line">	<span class="comment">//描述一个灯塔和右边遮住它最多的城市</span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">Lightpair</span>(<span class="type">const</span> <span class="type">int</span> &amp;_x=<span class="number">0</span>,<span class="type">const</span> <span class="type">int</span> &amp;_y=<span class="number">0</span>) : <span class="built_in">x</span>(_x),<span class="built_in">y</span>(_y) &#123; &#125;</span><br><span class="line">	<span class="function">db <span class="title">Left</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> C[y].x+<span class="number">1.0</span>*(C[y].x-C[x].x)/(C[x].h-C[y].h)*C[y].h;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// z这个发光对能照到的范围为[Left(),+oo)</span></span><br><span class="line">&#125; stk[N];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cover</span><span class="params">(Lightpair &amp;x,<span class="type">int</span> y)</span></span>&#123; <span class="keyword">if</span>(<span class="built_in">Lightpair</span>(x.x,y).<span class="built_in">Left</span>()&gt;x.<span class="built_in">Left</span>()) x.y=y; &#125;</span><br><span class="line">db s[<span class="number">2</span>][N];</span><br><span class="line"><span class="comment">// 将所有可能的发光区间描述为 [C[i].x,s[k][i]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),D=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) C[i].k=<span class="built_in">rd</span>(),C[i].x=<span class="built_in">rd</span>(),C[i].h=<span class="built_in">rd</span>();</span><br><span class="line">	C[n+<span class="number">1</span>].x=D;</span><br><span class="line">	<span class="built_in">rep</span>(k,<span class="number">0</span>,<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">			<span class="keyword">while</span>(top &amp;&amp; C[stk[top].x].h&lt;=C[i].h) top--; <span class="comment">// 完全被遮住的，先弹掉</span></span><br><span class="line">			<span class="keyword">if</span>(top) &#123;</span><br><span class="line">				<span class="built_in">Cover</span>(stk[top],i);</span><br><span class="line">				<span class="keyword">while</span>(top&gt;<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="built_in">Cover</span>(stk[top<span class="number">-1</span>],i);</span><br><span class="line">					<span class="keyword">if</span>(stk[top<span class="number">-1</span>].<span class="built_in">Left</span>()&gt;stk[top].<span class="built_in">Left</span>()) <span class="keyword">break</span>;</span><br><span class="line">					top--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(C[i].k) stk[++top]=i,s[k][i]=C[i].x; <span class="comment">// 一定覆盖C[i].x,C[i+1].x</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(top) s[k][i]=<span class="built_in">min</span>(stk[top].<span class="built_in">Left</span>(),(db)C[i+<span class="number">1</span>].x); <span class="comment">// 尝试让当前最优的点对覆盖过来</span></span><br><span class="line">			<span class="keyword">else</span> s[k][i]=C[i+<span class="number">1</span>].x; <span class="comment">// 无覆盖</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!k) &#123;</span><br><span class="line">			<span class="built_in">reverse</span>(C+<span class="number">1</span>,C+n+<span class="number">1</span>),top=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">1</span>,n) C[i].x=D-C[i].x;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">reverse</span>(s[k],s[k]+n+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,n) s[k][i]=D-s[k][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	db ans=D; <span class="comment">// 减去不合法的</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) <span class="keyword">if</span>(s[<span class="number">0</span>][i]&gt;s[<span class="number">1</span>][i]) ans-=s[<span class="number">0</span>][i]-s[<span class="number">1</span>][i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/COCI20162017%20Contest#2%20F%20/</url>
    <content><![CDATA[<hr />
<p>title: 'COCI2016-2017 Contest#2 F' date: 'Sat Aug 12 11:05:24 2023
categories: - oi-solutions'</p>
<h1 id="coci2016-2017-contest2-f">COCI2016-2017 Contest#2 F</h1>
<p>首先分析题意: 任意走都能在 <span class="math inline">\(k\)</span>
步内结束，也就是说，一定可以在 <span class="math inline">\(k\)</span>
步内封锁所有出路</p>
<p>注意游戏停止的条件是后手不能走，因此即使在 <span
class="math inline">\(k\)</span>
步封住了出路，下一轮依然要标记一个点</p>
<p>因此必须是 <span class="math inline">\(&lt;k\)</span> 的</p>
<p>设树根1的 <span class="math inline">\(dep=0\)</span> ，第 <span
class="math inline">\(i\)</span> 层表示所有 <span
class="math inline">\(dep=i\)</span> 的节点</p>
<p>发现第 <span class="math inline">\(i\)</span> 次操作，一定是从 <span
class="math inline">\(i-1\)</span> 层走到了 <span
class="math inline">\(i\)</span></p>
<p>假设最后的封路决策在 <span class="math inline">\(i\)</span>
层封掉了2个点，那么这个决策一定是不优的</p>
<p>因为在 <span class="math inline">\(i\)</span> 层花2的时间一定不如在
<span class="math inline">\(i-1\)</span> 层和 <span
class="math inline">\(i\)</span> 层各花1的时间</p>
<p>因此，问题可以转化为: 在 <span class="math inline">\(1-k\)</span>
层每层选择一个点，判断是否存在一种方案使得选择完成后完全封死出路</p>
<p>显然在最优情况下，选择的点之间不会有祖先关系，并且我们可以删掉所有
<span class="math inline">\(dep&gt;k\)</span> 的点</p>
<p>因此可以写出一个 <span class="math inline">\(n\cdot 2^k\)</span> 的
<span class="math inline">\(dp\)</span></p>
<p>由于最后要阻塞其实是阻塞所有的叶子( <span
class="math inline">\(dep=k\)</span> 的点)</p>
<p>因此考虑令选择每个节点是覆盖了一段叶子，将叶子按照 <span
class="math inline">\(\text{dfs}\)</span> 序从小到大依次标号，设选择
<span class="math inline">\(i\)</span> 子树能覆盖叶子范围 <span
class="math inline">\(L_i,R_i\)</span></p>
<p>因此按照 <span class="math inline">\(L_i\)</span>
从小到大依次考虑每个节点，加入的转移就是</p>
<p><span class="math inline">\(\begin{aligned} dep_i\notin
S,dp_{L_i,S}\rightarrow dp_{R_i+1,S\cup \lbrace dep_i\rbrace
}\end{aligned}\)</span></p>
<p>如果用bitset实现，时间/空间复杂度均为 <span class="math inline">\(O(n
\cdot 2^{k-5})\)</span></p>
<p>如果直接 <span class="math inline">\(dp\)</span> 显然。。。考虑缩小
<span class="math inline">\(k\)</span> 的范围</p>
<p>推论1: 当 <span class="math inline">\(n&lt; \frac{(k-1)\cdot
(k+2)}{2}\)</span> 时，一定有解</p>
<p>考虑一个浅显的贪心： 在第 <span class="math inline">\(i\)</span> 层用
<span class="math inline">\(\leq i\)</span> 的代价标记这层所有点</p>
<p>这个方法不可用的条件就是第 <span class="math inline">\(i\)</span>
层的点个数 <span class="math inline">\(&gt;i\)</span> ，那么就有 <span
class="math inline">\(n\ge
2+3+\cdots+k=\frac{(k-1)(k+2)}{2}\)</span></p>
<p>可以看到此时 <span class="math inline">\(k\)</span> 的上界已经缩小到
<span class="math inline">\(O(\sqrt n)\)</span>
级别，但由于实际常数，还是太大了</p>
<p><span class="math display">\[ \ \]</span></p>
<p>推论2: 当 <span class="math inline">\(n\leq k\cdot k\)</span>
时，一定有解</p>
<p>假设删除原树的1节点，则我们决策的对象变为一片森林</p>
<p>考虑依次决策每一层，每次推进一层，都会把选择一棵树删除，并且当前森林所有顶端的节点删除</p>
<p>要求 <span class="math inline">\(k\)</span> 次决策后森林为空</p>
<p>设森林第一层包含 <span class="math inline">\(d\)</span> 个节点</p>
<p>此时一定存在一个子树大小 <span class="math inline">\(\ge
\frac{n}{d}\)</span></p>
<p>删除这个子树后，规模变为 <span
class="math inline">\(n-d-\frac{n}{d}+1\)</span></p>
<p>我们知道 <span class="math inline">\(d+\frac{n}{d}\ge 2\sqrt
n\)</span></p>
<p><span class="math inline">\(n-d-\frac{n}{d}+1\leq n-2\sqrt n+1=(\sqrt
n-1)^2\)</span></p>
<p>因此得证</p>
<p>此时 <span class="math inline">\(k\)</span>
的上界已经缩小到19，完全可以通过</p>
<p>带入优化的复杂度为 <span class="math inline">\(O(n\cdot
2^{15})\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">410</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; G[N],Q[N];</span><br><span class="line"><span class="type">int</span> dep[N],L[N],R[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	dep[u]=dep[f]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(dep[u]==m<span class="number">-1</span>) &#123; L[u]=cnt++,R[u]=cnt; <span class="keyword">return</span>; &#125;</span><br><span class="line">	L[u]=cnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:G[u]) <span class="keyword">if</span>(v!=f) <span class="built_in">pre_dfs</span>(v,u);</span><br><span class="line">	R[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bitset &lt;1&lt;&lt;19&gt; dp[<span class="number">401</span>],rev[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> F[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="keyword">if</span>(m*m&gt;=n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;DA&quot;</span>),<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n) &#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>();</span><br><span class="line">		G[u].<span class="built_in">pb</span>(v),G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="keyword">sizeof</span> dep),dep[<span class="number">0</span>]=<span class="number">-2</span>,<span class="built_in">pre_dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(~dep[i]) Q[L[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) <span class="built_in">rep</span>(j,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>) <span class="keyword">if</span>(~j&amp;(<span class="number">1</span>&lt;&lt;i)) rev[i][j]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,cnt<span class="number">-1</span>) </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> v:Q[i]) &#123;</span><br><span class="line">			dp[R[v]]|=(dp[i]&amp;rev[dep[v]])&lt;&lt;(<span class="number">1</span>&lt;&lt;dep[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">puts</span>(dp[cnt].<span class="built_in">count</span>()?<span class="string">&quot;DA&quot;</span>:<span class="string">&quot;NE&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/COCI20162017%20Contest#3%20F%20/</url>
    <content><![CDATA[<hr />
<p>title: 'COCI2016/2017 Contest#3 F Meksikanac' date: 'Sat Aug 12
11:05:24 2023 categories: - oi-solutions'</p>
<h1 id="coci20162017-contest3-f-meksikanac">COCI2016/2017 Contest#3 F
Meksikanac</h1>
<p>设 <span class="math inline">\(M=\max\lbrace
X_p,Y_p\rbrace\)</span></p>
<h2 id="分析">分析:</h2>
<p>给定的多边形很难直接处理</p>
<p>如果直接枚举平移位置，然后判断每个点是否在多边形内部</p>
<p>由于不是凸包，判断点的位置可以用1.射线法,2.转角判断是否是360</p>
<p>一次判断复杂度为 <span class="math inline">\(O(K)\)</span>
，因此复杂度为 <span class="math inline">\(O(M^2\cdot N\cdot K)\)</span>
，显然不可取</p>
<p>但是观察题目的条件，不管怎么移动，多边形都只包含一些整点</p>
<p>由于多边形内的整点只有 <span class="math inline">\(O(M^2)\)</span>
个，如果能全部求出，直接匹配判断会方便很多，且复杂度降为 <span
class="math inline">\(O(M^4)\)</span></p>
<p>那么如何求出多边形内部的整点?</p>
<h3 id="做法1">做法1</h3>
<p>考虑枚举每个点，暴力判断，复杂度为 <span
class="math inline">\(O(M^2K)\)</span></p>
<h3 id="做法2">做法2</h3>
<p>考虑枚举 <span class="math inline">\(x\)</span>
一维，像写扫描线一样，把所有合法的 <span
class="math inline">\(y\)</span> 扫描出来(跨过奇数次在内部)</p>
<p>复杂度为 <span class="math inline">\(O(MK\log K)\)</span> 或者可能
<span class="math inline">\(O(MK)\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="优化">优化</h3>
<p>发现转化后，问题变为了 :</p>
<p>给定点集 <span class="math inline">\(A,B\)</span> ，判断将 <span
class="math inline">\(A\)</span> 点集平移 <span
class="math inline">\((dx,dy)\)</span> 后，是否存在点与 <span
class="math inline">\(B\)</span> 中重合</p>
<p>考虑这个问题的一维情形:</p>
<p>在给定的数轴上的 <span class="math inline">\([0,M]\)</span> 内部有
<span class="math inline">\(A,B\)</span> 两个数集</p>
<p>那么出现重合的平移量即 <span class="math inline">\(B_i-A_j\)</span>
，这个问题可以用一次卷积解决，复杂度为 <span
class="math inline">\(O(M\log M)\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p>类似的，将 <span class="math inline">\(x,y\)</span>
两维压在一起，做类似的卷积就可以判断 <span
class="math inline">\((dx,dy)\)</span> 是否合法了</p>
<p>复杂度为 <span class="math inline">\(O(M^2\log M^2)=O(M^2\log
M)\)</span></p>
<p>实现上的话，把 <span class="math inline">\((x,y)\)</span> 变为 <span
class="math inline">\(x\cdot (y_p+2)+y\)</span> 即可</p>
<p>注意这里的减法向下溢出没有关系，因为溢出的部分恰好不会被调用到</p>
<p><span class="math display">\[ \ \]</span></p>
<p>综上，总复杂度为 <span class="math inline">\(O(KM+M^2\log
M)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,M=<span class="number">10010</span>,P=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-9</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> X,Y,D,n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Read</span><span class="params">()</span></span>&#123; x=<span class="built_in">rd</span>(), y=<span class="built_in">rd</span>(); &#125;</span><br><span class="line">&#125; A[M];</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=N*N*<span class="number">4.2</span>;</span><br><span class="line"><span class="type">int</span> F[K],G[K];</span><br><span class="line"><span class="type">double</span> U[M];</span><br><span class="line"><span class="type">int</span> cnt,rev[K];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> e[K&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">    e[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> w=<span class="built_in">qpow</span>(f==<span class="number">1</span>?<span class="number">3</span>:(P+<span class="number">1</span>)/<span class="number">3</span>,(P<span class="number">-1</span>)/i/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j-=<span class="number">2</span>) e[j+<span class="number">1</span>]=<span class="number">1ll</span>*(e[j]=e[j&gt;&gt;<span class="number">1</span>])*w%P;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">                <span class="type">int</span> t=<span class="number">1ll</span>*a[j+i]*e[j-l]%P;</span><br><span class="line">                a[j+i]=a[j]-t,<span class="built_in">Mod2</span>(a[j+i]);</span><br><span class="line">                a[j]+=t,<span class="built_in">Mod1</span>(a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">        ll base=<span class="built_in">qpow</span>(n);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=a[i]*base%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cover</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    F[(X+<span class="number">1</span>-x)*D+Y-y]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X=<span class="built_in">rd</span>(),Y=<span class="built_in">rd</span>(),D=Y+<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n=<span class="built_in">rd</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>();</span><br><span class="line">        G[x*D+y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mix=<span class="number">1e9</span>,miy=<span class="number">1e9</span>,max=<span class="number">-1e9</span>,may=<span class="number">-1e9</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m=<span class="built_in">rd</span>()) &#123;</span><br><span class="line">        A[i].<span class="built_in">Read</span>();</span><br><span class="line">        <span class="built_in">cmin</span>(mix,A[i].x),<span class="built_in">cmax</span>(max,A[i].x);</span><br><span class="line">        <span class="built_in">cmin</span>(miy,A[i].y),<span class="built_in">cmax</span>(may,A[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    max-=mix,may-=miy;</span><br><span class="line">    <span class="keyword">if</span>(max&gt;X || may&gt;Y) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) A[i].x-=mix,A[i].y-=miy;</span><br><span class="line">    A[m+<span class="number">1</span>]=A[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,X) &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,m) &#123;</span><br><span class="line">            Point L=A[j],R=A[j+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(L.x&gt;R.x) <span class="built_in">swap</span>(L,R);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;L.x || i&gt;R.x) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(L.x==R.x) &#123;</span><br><span class="line">                <span class="built_in">rep</span>(y,<span class="built_in">min</span>(L.y,R.y),::<span class="built_in">max</span>(L.y,R.y)) <span class="built_in">Cover</span>(i,y);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> y=<span class="number">1.0</span>*(R.y-L.y)/(R.x-L.x)*(i-L.x)+L.y;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;R.x) U[++cnt]=y;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(y-<span class="built_in">int</span>(y))&lt;eps) <span class="built_in">Cover</span>(i,y);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">sort</span>(U+<span class="number">1</span>,U+cnt+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j+=<span class="number">2</span>) <span class="keyword">for</span>(<span class="type">int</span> y=<span class="built_in">ceil</span>(U[j]);y&lt;=U[j+<span class="number">1</span>]+eps;++y) <span class="built_in">Cover</span>(i,y);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> R=<span class="number">1</span>,cc=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(R&lt;=(X+<span class="number">1</span>)*<span class="number">2</span>*D) R&lt;&lt;=<span class="number">1</span>,cc++;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,R<span class="number">-1</span>) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;cc);</span><br><span class="line">    <span class="built_in">NTT</span>(R,F,<span class="number">1</span>),<span class="built_in">NTT</span>(R,G,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) F[i]=<span class="number">1ll</span>*F[i]*G[i]%P;</span><br><span class="line">    <span class="built_in">NTT</span>(R,F,<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,X-max) <span class="built_in">rep</span>(j,<span class="number">0</span>,Y-may) <span class="keyword">if</span>(!F[(X+<span class="number">1</span>+i)*D+Y+j]) ans++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/COCI20162017%20Contest#6%20F%20/</url>
    <content><![CDATA[<hr />
<p>title: 'COCI20162017 Contest#6 F' date: 'Sat Aug 12 11:05:24 2023
categories: - oi-solutions'</p>
<h1 id="coci20162017-contest6-f">COCI20162017 Contest#6 F</h1>
<p>其实这个题不是很难的。。。</p>
<p>设值域为 <span class="math inline">\(M\)</span></p>
<p>考虑如果没有幸运数的限制，那么从 <span
class="math inline">\(A\)</span> 变成 <span
class="math inline">\(B\)</span> ，实际上只与 <span
class="math inline">\(\frac{A}{B}\)</span> 有关</p>
<p>不妨令 <span class="math inline">\(dp_{i,j}\)</span> 为从 <span
class="math inline">\(i\)</span> 走了 <span
class="math inline">\(j\)</span> 步变成1，显然这个 <span
class="math inline">\(j\)</span> 的最大值为 <span
class="math inline">\(\log M=19\)</span> ，即 <span
class="math inline">\(2^{19}\)</span> 最多操作19次</p>
<p>从 <span class="math inline">\(i\)</span>
枚举倍数进行转移，同时也暴力处理每个数的因数个数，复杂度为 <span
class="math inline">\(O(M\ln M\log M)\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p>接下来考虑幸运数的限制</p>
<p>推论: 最多只会在一个幸运数上停留</p>
<p>如果经过多个，显然在代价最小的那个上面停留</p>
<p>因此考虑枚举停留的幸运数 <span class="math inline">\(x\)</span></p>
<p>那么转移可以分为两步 <span class="math inline">\(\frac{A}{x}\)</span>
和 <span class="math inline">\(\frac{x}{B}\)</span> ，可以暴力合并两个
<span class="math inline">\(dp\)</span> 数组，单次查询复杂度为 <span
class="math inline">\(O(T\cdot \log^2 M)\)</span></p>
<p>合并得到的结果，可以描述为:</p>
<p>可以在 <span class="math inline">\(x\)</span> 上用 <span
class="math inline">\(C(x)\)</span> 的代价停留，并且其他部分的转移花了
<span class="math inline">\(j\)</span> 的时间， <span
class="math inline">\(y\)</span> 的代价</p>
<p>如果考虑停留的时间，那么得到的答案显然是一条直线，斜率就是停留的代价</p>
<p>关于一群直线，一群查询，不难想到可以斜率优化求解，这一部分复杂度为
<span class="math inline">\(O(T\log M\log (T\log M)+m)\)</span>
（排序复杂度）</p>
<p>总复杂度可以认为就是 <span class="math inline">\(O(M\log^2 M+Q(T\log
^2 M+m))\)</span></p>
<p>斜率优化的实现可以参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> F[N],A[N],B[N];</span><br><span class="line"><span class="type">int</span> L[N];</span><br><span class="line"><span class="comment">// A: 因子个数</span></span><br><span class="line"><span class="comment">// B: 将B变成1需要的最大步数</span></span><br><span class="line"><span class="type">int</span> C[N],D[N];</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">20</span>];</span><br><span class="line"><span class="comment">// 用了j步，将i变为1的最小代价</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123; </span><br><span class="line">    <span class="comment">// 描述一条直线</span></span><br><span class="line">	ll x,y;</span><br><span class="line">	<span class="comment">// 答案为 x*i+y</span></span><br><span class="line">	ll <span class="keyword">operator</span> [](<span class="type">const</span> ll i)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> i*x+y;</span><br><span class="line">	&#125; <span class="comment">//求直线点值</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node __) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(x!=__.x) <span class="keyword">return</span> x&lt;__.x;</span><br><span class="line">		<span class="keyword">return</span> y&lt;__.y; <span class="comment">//按照斜率排序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; U[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Uc,T[<span class="number">21</span>],R[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) &#123;</span><br><span class="line">		A[i]++;</span><br><span class="line">		<span class="keyword">for</span>(reg <span class="type">int</span> j=i+i;j&lt;N;j+=i) A[j]++,<span class="built_in">cmax</span>(B[j],B[i]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="built_in">rd</span>()) F[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m=<span class="built_in">rd</span>()) L[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">sort</span>(L+<span class="number">1</span>,L+m+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) <span class="built_in">rep</span>(j,<span class="number">0</span>,B[i]) dp[i][j]=INF;</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) <span class="built_in">rep</span>(j,<span class="number">0</span>,B[i]) <span class="keyword">if</span>(dp[i][j]&lt;INF) <span class="keyword">for</span>(reg <span class="type">int</span> k=i+i;k&lt;N;k+=i) <span class="built_in">cmin</span>(dp[k][j+<span class="number">1</span>],dp[i][j]+F[A[k/i]]);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n=<span class="built_in">rd</span>()) C[i]=<span class="built_in">rd</span>(),D[i]=<span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>(),d=x/y;</span><br><span class="line">		<span class="keyword">if</span>(x%y!=<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,-m);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(R,<span class="number">63</span>,<span class="keyword">sizeof</span> R);</span><br><span class="line">		Uc=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(x%C[i]==<span class="number">0</span> &amp;&amp; C[i]%y==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="type">int</span> dx=x/C[i],dy=C[i]/y;</span><br><span class="line">			<span class="built_in">memset</span>(T,<span class="number">63</span>,<span class="keyword">sizeof</span> T);</span><br><span class="line">			<span class="built_in">rep</span>(a,<span class="number">0</span>,B[dx]) <span class="keyword">if</span>(dp[dx][a]&lt;INF) <span class="built_in">rep</span>(b,<span class="number">0</span>,B[dy]) <span class="built_in">cmin</span>(T[a+b],dp[dx][a]+dp[dy][b]);</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,B[dx]+B[dy]) <span class="keyword">if</span>(T[j]&lt;INF) &#123;</span><br><span class="line">				ll a=D[i],b=T[j]-a*j;</span><br><span class="line">				U[++Uc]=(Node)&#123;a,b&#125;;</span><br><span class="line">				<span class="built_in">rep</span>(k,j,B[d]) <span class="built_in">cmin</span>(R[k],(<span class="type">int</span>)U[Uc][k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,B[d]) <span class="built_in">cmin</span>(R[i],dp[d][i]);</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		ll mi=<span class="number">1e18</span>;</span><br><span class="line">		<span class="built_in">sort</span>(U+<span class="number">1</span>,U+Uc+<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> R=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,Uc) &#123;</span><br><span class="line">			<span class="keyword">if</span>(mi&lt;U[i].y) <span class="keyword">continue</span>;</span><br><span class="line">			mi=U[i].y;</span><br><span class="line">			<span class="keyword">while</span>(R&gt;<span class="number">1</span> &amp;&amp; (U[i].y-U[R].y)*(U[R].x-U[R<span class="number">-1</span>].x)&lt;=(U[R].y-U[R<span class="number">-1</span>].y)*(U[i].x-U[R].x)) R--;</span><br><span class="line">			U[++R]=U[i]; <span class="comment">// 单调栈处理凸包，注意加入时满足x递增，y递减</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>(L[i]&lt;=B[d]) ans+=::R[L[i]]&lt;INF?::R[L[i]]:<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span>(R&gt;<span class="number">1</span> &amp;&amp; U[R<span class="number">-1</span>][L[i]]&lt;=U[R][L[i]]) R--;</span><br><span class="line">			<span class="keyword">if</span>(!R) ans--;</span><br><span class="line">			<span class="keyword">else</span> ans+=U[R][L[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/%E4%BD%95%E4%BB%A5%E4%BC%8A%E5%90%8D%E5%A7%8B/</url>
    <content><![CDATA[<hr />
<p>title: '何以伊名始' date: 'Sat Aug 12 11:05:24 2023 categories: -
oi-solutions'</p>
<h1 id="何以伊名始">何以伊名始</h1>
<p>本题现已知四种做法，如果不会后缀系列结构可以直接看Solution4</p>
<p>设初始树大小和查询总长均为 <span
class="math inline">\(O(n)\)</span></p>
<h3 id="solution1">Solution1</h3>
<p>由于查询只有1e6，因此出现的不同查询串长度最多 <span
class="math inline">\(\sqrt {10^6}=1000\)</span> 种</p>
<p>考虑对于每一种做一次dfs，在 <span class="math inline">\(\text{Hash
Table}\)</span> 中查询，复杂度为 <span class="math inline">\(O(n\sqrt
n)\)</span></p>
<h3 id="solution2">Solution2</h3>
<p>将树上节点后缀排序，然后每次插入需要询问的字符就二分后缀区间</p>
<p>预处理复杂度为 <span class="math inline">\(O(n\log n)\)</span>
，查询涉及二分和倍增，复杂度为 <span class="math inline">\(O(n\log ^2
n)\)</span></p>
<h3 id="solution3">Solution3</h3>
<p>给定的树看做trie树，可以对于trie树建广义后缀自动机，然后倒着让询问串去匹配，一旦失配答案为0，</p>
<p>需要预处理 <span class="math inline">\(link\)</span>
树的子树和，时间复杂度为 <span class="math inline">\(O(n)\)</span>
，空间复杂度为 <span class="math inline">\(O(n|\Sigma|)\)</span></p>
<h3 id="solution4">Solution4</h3>
<p>将询问的串倒着插入，构建AC自动机</p>
<p>由于AC自动机预处理，时间空间复杂度为 <span
class="math inline">\(O(n|\Sigma|)\)</span></p>
<p>然后考虑对于树上每一个前缀在AC自动机上匹配，每次从父亲转移过来，复杂度为
<span class="math inline">\(O(n)\)</span></p>
<p>然后是常见的AC自动机操作， <span class="math inline">\(fail\)</span>
树上的子树累和即可</p>
<p>需要询问离线，因此有一定局限性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,len,F[N],A[N];</span><br><span class="line"><span class="type">char</span> s[N],t[N];</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">26</span>],fail[N],cnt,pos[N];</span><br><span class="line"><span class="type">int</span> Q[N],L=<span class="number">1</span>,R;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">25</span>) <span class="keyword">if</span>(nxt[<span class="number">0</span>][i]) Q[++R]=nxt[<span class="number">0</span>][i];</span><br><span class="line">	<span class="keyword">while</span>(L&lt;=R) &#123;</span><br><span class="line">		<span class="type">int</span> u=Q[L++];</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">25</span>) &#123;</span><br><span class="line">			<span class="type">int</span> &amp;v=nxt[u][i];</span><br><span class="line">			<span class="keyword">if</span>(v) fail[v]=nxt[fail[u]][i],Q[++R]=v;</span><br><span class="line">			<span class="keyword">else</span> v=nxt[fail[u]][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,s+i),F[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">drep</span>(j,<span class="built_in">strlen</span>(t+<span class="number">1</span>),<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> c=t[j]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[now][c]) nxt[now][c]=++cnt;</span><br><span class="line">			now=nxt[now][c];</span><br><span class="line">		&#125;</span><br><span class="line">		pos[i]=now;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Build</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) A[F[i]=nxt[F[F[i]]][s[i]-<span class="string">&#x27;A&#x27;</span>]]++;</span><br><span class="line">	<span class="built_in">drep</span>(i,R,<span class="number">1</span>) A[fail[Q[i]]]+=A[Q[i]];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A[pos[i]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/%E7%BE%8E%E4%B8%BD%E7%9A%84%E6%A1%A5%E6%A2%81/</url>
    <content><![CDATA[<hr />
<p>title: '美丽的桥梁' date: 'Sat Aug 12 11:05:24 2023 categories: -
oi-solutions'</p>
<h1 id="美丽的桥梁">美丽的桥梁</h1>
<p>可以得到一个Naive的暴力方法来判断在 <span
class="math inline">\((L,R)\)</span> 上修桥是否合法:</p>
<p>显然的性质: 如果有相交，则一定存在一个关键点相交</p>
<p>设得到的圆半径为 <span
class="math inline">\(r=\frac{x_R-x_L}{2}\)</span> ，圆心为 <span
class="math inline">\((x,y)=(\frac{x_L+x_R}{2},h-r)\)</span></p>
<p>枚举每个 <span class="math inline">\(i\in [L,R]\)</span> 判断是否点
<span class="math inline">\(x_i,y_i\)</span>
是否相交，如果相交，只需要满足</p>
<p><span class="math inline">\(y_i&gt;y\)</span> ，且 其与圆心距离 <span
class="math inline">\(&gt;r\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p>考虑优化判断，将生成的拱形分为左右两部分，分别考虑即可</p>
<p>推论: 对于每个 <span class="math inline">\(L\)</span>
，其左半边不相交的半径为描述为一个范围 <span
class="math inline">\([0,A_L]\)</span></p>
<p>同理的，对于每个 <span class="math inline">\(R\)</span>
也是如此，能求得一个范围 <span
class="math inline">\([0,B_R]\)</span></p>
<p>考虑对于每个 <span class="math inline">\(L\)</span> ，枚举每个 <span
class="math inline">\(i&gt;L\)</span> 来求出 <span
class="math inline">\(A_L\)</span></p>
<p>设半径为 <span class="math inline">\(r\)</span> ，列出圆心与点 <span
class="math inline">\(x_i,y_i\)</span> 距离的表达式，必须满足距离 <span
class="math inline">\(\leq r\)</span> ，就能得到一个二次方程</p>
<p>二次方程的解集为 <span class="math inline">\(x_1,x_2\)</span>
，但是实际上 <span class="math inline">\([0,x_1]\)</span> 这一段不满足
<span class="math inline">\(y_i&gt;y\)</span> ，因此也是合法的</p>
<p>即将每次求得的 <span class="math inline">\([0,x_2]\)</span>
区间取交集即可</p>
<p>复杂度为 <span class="math inline">\(O(n^2)\)</span></p>
<p>同理求得每个 <span class="math inline">\(B_R\)</span></p>
<p>考虑朴素的dp，令 <span class="math inline">\(dp_i\)</span> 表示解决了
<span class="math inline">\([1,i]\)</span> 前缀的最小代价</p>
<p>枚举 <span class="math inline">\(j\)</span> ， <span
class="math inline">\(O(1)\)</span> 判断 <span
class="math inline">\((i,j)\)</span> 是否合法，然后进行转移</p>
<p>tips: 题目的代价计算方法可能没讲清楚。。。</p>
<p>复杂度为 <span class="math inline">\(O(n^2)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">4e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,h,a,b;</span><br><span class="line"><span class="type">int</span> X[N],Y[N];</span><br><span class="line">db L[N],R[N];</span><br><span class="line"><span class="function">db <span class="title">Sqr</span><span class="params">(db x)</span></span>&#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line">ll dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),h=<span class="built_in">rd</span>(),a=<span class="built_in">rd</span>(),b=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) X[i]=<span class="built_in">rd</span>(),Y[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		L[i]=<span class="built_in">min</span>((db)(X[n]-X[i])/<span class="number">2</span>,(db)(h-Y[i]));</span><br><span class="line">		<span class="built_in">rep</span>(j,i+<span class="number">1</span>,n) &#123;</span><br><span class="line">			<span class="keyword">if</span>(X[j]-X[i]&gt;L[i]+eps) <span class="keyword">break</span>;</span><br><span class="line">			db a=<span class="number">1</span>,b=<span class="number">2</span>*(X[i]-X[j]+Y[j]-h),c=<span class="built_in">Sqr</span>(X[i]-X[j])+<span class="built_in">Sqr</span>(Y[j]-h);</span><br><span class="line">			db d=<span class="built_in">sqrt</span>(b*b<span class="number">-4</span>*a*c);</span><br><span class="line">			db r=(-b+d)/(<span class="number">2</span>*a);</span><br><span class="line">			<span class="built_in">cmin</span>(L[i],r);</span><br><span class="line">		&#125;</span><br><span class="line">		L[i]*=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		R[i]=<span class="built_in">min</span>((db)(X[i]-X[<span class="number">1</span>])/<span class="number">2</span>,(db)(h-Y[i]));</span><br><span class="line">		<span class="built_in">drep</span>(j,i<span class="number">-1</span>,<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(X[i]-X[j]&gt;R[i]+eps) <span class="keyword">break</span>;</span><br><span class="line">			db a=<span class="number">1</span>,b=<span class="number">2</span>*(X[j]-X[i]+Y[j]-h),c=<span class="built_in">Sqr</span>(X[j]-X[i])+<span class="built_in">Sqr</span>(Y[j]-h);</span><br><span class="line">			db d=<span class="built_in">sqrt</span>(b*b<span class="number">-4</span>*a*c);</span><br><span class="line">			db r=(-b+d)/(<span class="number">2</span>*a);</span><br><span class="line">			<span class="built_in">cmin</span>(R[i],r);</span><br><span class="line">		&#125;</span><br><span class="line">		R[i]*=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">1</span>]=<span class="number">1ll</span>*a*(h-Y[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n) &#123;</span><br><span class="line">		dp[i]=INF;</span><br><span class="line">		<span class="built_in">drep</span>(j,i<span class="number">-1</span>,<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(X[i]-X[j]&gt;R[i]+eps) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(X[i]-X[j]&gt;L[j]+eps) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">cmin</span>(dp[i],dp[j]+<span class="number">1ll</span>*a*(h-Y[i])+<span class="number">1ll</span>*(X[i]-X[j])*(X[i]-X[j])*b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dp[n]&lt;INF) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[n]);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/%5BCOCI2010-2011#2%5D%20CRNI/</url>
    <content><![CDATA[<hr />
<p>title: '[COCI2010-2011#2] CRNI(单调栈)' date: 'Sat Aug 12 11:05:24
2023 categories: - oi-solutions'</p>
<h1 id="coci2010-20112-crni单调栈">[COCI2010-2011#2] CRNI(单调栈)</h1>
<h2 id="问题分析">问题分析</h2>
<p>首先考虑两个不相交的矩形可能存在的位置关系，我将其分成</p>
<p>1.左右</p>
<p>2.上下</p>
<p>3.左上右下</p>
<p>4.左下右上</p>
<p>发现1,2,3,4之间有相交,考虑四种情况的答案应该是1+2-3-4</p>
<h2 id="统计方法">统计方法</h2>
<p>核心: 统计以一个点作为顶点的矩形数量</p>
<p>以统计 <span class="math inline">\(i,j\)</span>
为右下角的矩形为例，先不考虑矩形大小&gt;1的限制</p>
<p>显然可以在线性时间内处理得到每个 <span
class="math inline">\(i,j\)</span> 向上连续延伸的连续1长度，设其为 <span
class="math inline">\(U_{i,j}\)</span></p>
<p>假设枚举了 <span class="math inline">\(i\)</span> ，从左到右依次扫描
<span class="math inline">\(j\)</span> ，则得到 <span
class="math inline">\(i,j\)</span> 位置的答案应该是</p>
<p><span class="math display">\[\begin{aligned} \sum_{k=1}^{j}
\min_{d=k}^j\lbrace U_{i,d}\rbrace\end{aligned} \]</span></p>
<p>这条式子中，相当于枚举了 <span class="math inline">\(i,(k,j)\)</span>
为底，统计向上延伸的最长长度</p>
<p>这个式子可以用<strong>单调栈</strong>在线性时间内求解，其过程可以描述为</p>
<p>1.每次插入元素 <span class="math inline">\(U_{i,j}\)</span>
，得到它的影响区间 <span class="math inline">\(k\in [L,j]\)</span></p>
<p>2.将原先单调栈内 <span class="math inline">\(k\in [L,j]\)</span>
这段区间的答案减掉，改为 <span class="math inline">\(U_{i,j}\cdot
(j-L+1)\)</span></p>
<p>类似的，可以通过改变循环顺序和额外记录向下延伸的长度 <span
class="math inline">\(D_{i,j}\)</span>
来统计四种顶点的答案(详细见代码)</p>
<p>然后可以用前缀和帮助统计以上4种答案，枚举一个端点，另一个查询前缀和即可</p>
<p>tips: 注意累和顺序，<del>前缀和要开long long</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> a[N][N];</span><br><span class="line"><span class="type">int</span> D[N][N],U[N][N]; <span class="comment">//i,j向下/上延伸的最长长度</span></span><br><span class="line"><span class="type">int</span> stk[N],c[N],top;</span><br><span class="line"><span class="type">int</span> CRR[N][N]; <span class="comment">// 以i,j为右下角的矩形个数</span></span><br><span class="line"><span class="type">int</span> CLL[N][N]; <span class="comment">// 以i,j为左上角的矩形个数</span></span><br><span class="line"><span class="type">int</span> CLR[N][N]; <span class="comment">// 以i,j为右上角的矩形个数</span></span><br><span class="line"><span class="type">int</span> CRL[N][N]; <span class="comment">// 以i,j为左下角的矩形个数</span></span><br><span class="line">ll SLL[N][N],SRL[N][N]; <span class="comment">// 前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;C&#x27;</span>) U[i][j]=U[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">drep</span>(i,n,<span class="number">1</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;C&#x27;</span>) D[i][j]=D[i+<span class="number">1</span>][j]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		<span class="comment">// 统计四种端点的情况</span></span><br><span class="line">		top=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,n) &#123;</span><br><span class="line">			<span class="type">int</span> x=U[i][j],cnt=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(top &amp;&amp; stk[top]&gt;=x) cnt+=c[top],now-=c[top]*stk[top],top--;</span><br><span class="line">			stk[++top]=x,c[top]=cnt; now+=x*cnt;</span><br><span class="line">			CRR[i][j]=<span class="built_in">max</span>(now<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		now=top=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,n) &#123;</span><br><span class="line">			<span class="type">int</span> x=D[i][j],cnt=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(top &amp;&amp; stk[top]&gt;=x) cnt+=c[top],now-=c[top]*stk[top],top--;</span><br><span class="line">			stk[++top]=x,c[top]=cnt; now+=x*cnt;</span><br><span class="line">			CLR[i][j]=<span class="built_in">max</span>(now<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		now=top=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">drep</span>(j,n,<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> x=U[i][j],cnt=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(top &amp;&amp; stk[top]&gt;=x) cnt+=c[top],now-=c[top]*stk[top],top--;</span><br><span class="line">			stk[++top]=x,c[top]=cnt; now+=x*cnt;</span><br><span class="line">			CRL[i][j]=<span class="built_in">max</span>(now<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		now=top=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">drep</span>(j,n,<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> x=D[i][j],cnt=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(top &amp;&amp; stk[top]&gt;=x) cnt+=c[top],now-=c[top]*stk[top],top--;</span><br><span class="line">			stk[++top]=x,c[top]=cnt; now+=x*cnt;</span><br><span class="line">			CLL[i][j]=<span class="built_in">max</span>(now<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">drep</span>(i,n,<span class="number">1</span>) <span class="built_in">drep</span>(j,n,<span class="number">1</span>) SLL[i][j]=SLL[i+<span class="number">1</span>][j]+SLL[i][j+<span class="number">1</span>]-SLL[i+<span class="number">1</span>][j+<span class="number">1</span>]+CLL[i][j];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">drep</span>(j,n,<span class="number">1</span>) SRL[i][j]=SRL[i<span class="number">-1</span>][j]+SRL[i][j+<span class="number">1</span>]-SRL[i<span class="number">-1</span>][j+<span class="number">1</span>]+CRL[i][j];</span><br><span class="line">	<span class="comment">// 前缀和</span></span><br><span class="line"></span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(CRR[i][j]) ans+=CRR[i][j]*(SLL[i+<span class="number">1</span>][<span class="number">1</span>]+SLL[<span class="number">1</span>][j+<span class="number">1</span>]-SLL[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) ans-=CLR[i][j]*SRL[i<span class="number">-1</span>][j+<span class="number">1</span>];</span><br><span class="line">	<span class="comment">// 统计4种情况</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans%<span class="number">10007</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/2014%E5%A4%9A%E6%A0%A16%20Another%20Letter%20Tree/</url>
    <content><![CDATA[<hr />
<p>title: '2014多校6 Another Letter Tree' date: 'Sat Aug 12 11:05:26
2023 categories: - oi-solutions'</p>
<h1 id="多校6-another-letter-tree">2014多校6 Another Letter Tree</h1>
<h2 id="点分治做法">点分治做法</h2>
<p>就裸地离个线，放到点分治上，从每个根开始，维护 <span
class="math inline">\(dp_{u,l,r}\)</span> 表示这条链匹配了序列中 <span
class="math inline">\([l,r]\)</span> 的部分</p>
<p>注意dp数组要一正一反，俩家伙一个含根一个不含</p>
<p>查询要合并两个dp数组，但是只需要知道 <span
class="math inline">\(dp_{1,|s_0|}\)</span> ，因此合并复杂度是 <span
class="math inline">\(O(|s_0|)\)</span> 的</p>
<p>最终复杂度，处理为 <span class="math inline">\(O(n\log
n|s_0|^2+q|s_0|)\)</span></p>
<h2 id="树剖线段树做法">树剖线段树做法</h2>
<p>类似上面的dp，线段树维护即可</p>
<h3 id="问题1">问题1</h3>
<p>需要存正反！</p>
<p>然后你发现内存从中间裂开！！</p>
<p>正反分两次，离线跑两次就可以了啊啊啊啊</p>
<h3 id="问题2">问题2</h3>
<p>如果直接查询合并，合并两个dp数组复杂度为 <span
class="math inline">\(O(|s_0|^3)\)</span></p>
<p>查询复杂度为 <span class="math inline">\(O(q\log
^2n|s_0|^3)\)</span></p>
<p>妙啊!!比 <span class="math inline">\(n^2\)</span> 还大!!</p>
<p>所以最后不能合并dp数组，而应该直接累加到答案数组上</p>
<h3 id="问题3">问题3</h3>
<p>没错现在我们的复杂度为 <span class="math inline">\(O(q\log
^2n|s_0|^2)\)</span></p>
<p>依然大得令人无法忍受</p>
<p><del>但是没想到吧，数据全部都是链，树剖是 <span
class="math inline">\(O(1)\)</span> 的</del></p>
<p>优化：查询重链时，只有最后依次是在链上查询 <span
class="math inline">\([l,r]\)</span>
都在中间的，而对于直接跳到top的部分，可以预处理出来</p>
<p>算上线段树的预处理，这样总复杂度就是 <span
class="math inline">\(O(n|s_0|^3+q\log n |s_0|^2)\)</span></p>
<h2 id="并查集做法">并查集做法</h2>
<p>把问题拆成查询两条 <span class="math inline">\(u\)</span> 到它的祖先
<span class="math inline">\(v\)</span> 的答案</p>
<p>每个节点存储一个dp矩阵，用带权并查集维护</p>
<p>具体方法是:将询问按照 <span class="math inline">\(\text{LCA}\)</span>
深度逆序排序后，每次查询一直将 <span class="math inline">\(u\)</span>
合并到 <span class="math inline">\(v\)</span> 为止</p>
<p>复杂度为 <span class="math inline">\(O(n\alpha(n)|s_0|^3)\)</span>
，理论上来说，这个转移矩阵应当很稀疏，乘法应该很快，但是实际常数比较大</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,P=<span class="number">10007</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,len;</span><br><span class="line"><span class="type">char</span> str[N],t[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123; <span class="built_in">clear</span>(); <span class="built_in">rep</span>(i,<span class="number">1</span>,len) <span class="keyword">if</span>(t[i]==str[u]) a[i][i]=<span class="number">1</span>; &#125;</span><br><span class="line">	Node <span class="keyword">operator</span> + (<span class="type">const</span> Node &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">		Node res; res.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,len) <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;len &amp;&amp; a[i][j];++j) <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;=len &amp;&amp; x.a[j+<span class="number">1</span>][k];++k) res.a[i][k]=(res.a[i][k]+a[i][j]*x.a[j+<span class="number">1</span>][k])%P;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,len) <span class="built_in">rep</span>(j,i,len) &#123;</span><br><span class="line">			res.a[i][j]+=a[i][j],<span class="built_in">Mod1</span>(res.a[i][j]);</span><br><span class="line">			res.a[i][j]+=x.a[i][j],<span class="built_in">Mod1</span>(res.a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; s[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=ecnt; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erep(u,i) for(int i=head[u];i;i=e[i].nxt)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> QX[N],QY[N],QL[N];</span><br><span class="line"><span class="type">int</span> dep[N],id[N],fa[N][<span class="number">18</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	dep[u]=dep[fa[u][<span class="number">0</span>]=f]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">17</span>) fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">erep</span>(u,i) &#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">pre_dfs</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,del=dep[x]-dep[y];(<span class="number">1</span>&lt;&lt;i)&lt;=del;++i) <span class="keyword">if</span>(del&amp;(<span class="number">1</span>&lt;&lt;i)) x=fa[x][i];</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="built_in">drep</span>(i,<span class="number">17</span>,<span class="number">0</span>) <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];</span><br><span class="line">	<span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> F[N],ans[N][<span class="number">31</span>],Ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(F[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="type">int</span> f=F[x]; F[x]=<span class="built_in">Find</span>(f,k);</span><br><span class="line">	<span class="keyword">if</span>(F[f]!=f)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!k) s[x]=s[x]+s[f];</span><br><span class="line">		<span class="keyword">else</span> s[x]=s[f]+s[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> F[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">		n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) head[i]=ecnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">2</span>,n) &#123;</span><br><span class="line">			<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>();</span><br><span class="line">			<span class="built_in">AddEdge</span>(u,v),<span class="built_in">AddEdge</span>(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,str+<span class="number">1</span>,t+<span class="number">1</span>),len=<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">pre_dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m) id[i]=i,QX[i]=<span class="built_in">rd</span>(),QY[i]=<span class="built_in">rd</span>(),QL[i]=<span class="built_in">LCA</span>(QX[i],QY[i]);</span><br><span class="line">		<span class="built_in">sort</span>(id+<span class="number">1</span>,id+m+<span class="number">1</span>,[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123; <span class="keyword">return</span> dep[QL[x]]&gt;dep[QL[y]]; &#125;);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) F[i]=i,s[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">rep</span>(k,<span class="number">1</span>,m)&#123;</span><br><span class="line">			<span class="type">int</span> i=id[k],x=QX[i];</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="type">int</span> y=<span class="built_in">Find</span>(x);</span><br><span class="line">				<span class="keyword">if</span>(y==QL[i]) <span class="keyword">break</span>;</span><br><span class="line">				F[y]=fa[y][<span class="number">0</span>],s[y].<span class="built_in">Init</span>(y);</span><br><span class="line">			&#125;</span><br><span class="line">			ans[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">1</span>,len) ans[i][j]=s[x].a[<span class="number">1</span>][j];</span><br><span class="line">			<span class="built_in">drep</span>(j,len,<span class="number">1</span>) <span class="keyword">if</span>(str[QL[i]]==t[j]) ans[i][j]+=ans[i][j<span class="number">-1</span>],<span class="built_in">Mod1</span>(ans[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) F[i]=i,s[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">rep</span>(k,<span class="number">1</span>,m)&#123;</span><br><span class="line">			<span class="type">int</span> i=id[k],x=QY[i]; Ans[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="type">int</span> y=<span class="built_in">Find</span>(x,<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(y==QL[i]) <span class="keyword">break</span>;</span><br><span class="line">				F[y]=fa[y][<span class="number">0</span>],s[y].<span class="built_in">Init</span>(y);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,len<span class="number">-1</span>) Ans[i]=(Ans[i]+ans[i][j]*s[x].a[j+<span class="number">1</span>][len])%P;</span><br><span class="line">			Ans[i]=(Ans[i]+ans[i][len])%P;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[ \ \]</span></p>
<h2 id="伪矩阵求逆做法">伪矩阵求逆做法</h2>
<p>同样的，把问题拆成查询两条 <span class="math inline">\(u\)</span>
到它的祖先 <span class="math inline">\(v\)</span> 的答案(不包含v)</p>
<p>以从 <span class="math inline">\(v\)</span> 到 <span
class="math inline">\(u\)</span> 的字符串为例，设 <span
class="math inline">\(dp_u\)</span> 为 <span
class="math inline">\(u\)</span> 的祖先链的dp矩阵，我们要求的部分答案是
<span class="math inline">\(x\)</span></p>
<p>则 <span class="math inline">\(dp_v\cdot x=dp_u,
x=\frac{dp_u}{dp_v}\)</span></p>
<p>一般来说，矩阵求逆是一个很难实现的东西</p>
<p>但是发现对于一种 <span class="math inline">\(dp\)</span>
，它的矩阵一定是一个上/下对角的矩阵</p>
<p>我们需要求出矩阵第一维为1或者第二维为 <span
class="math inline">\(|s_0|\)</span> 的部分</p>
<p>如果暴力求，可以看做求解一个 <span
class="math inline">\(|s_0|\)</span> 元的线性方程组，可以用高斯消元在
<span class="math inline">\(O(|s_0|^3)\)</span> 时间内求解</p>
<p>而实际上，这个线性方程组是含拓扑序关系的，任何一个含拓扑关系的线性方程组求解是不需要高斯消元的</p>
<p>而且这个问题列出的方程矩阵就已经是上对角矩阵了</p>
<p>所以写出来就是容斥吧</p>
<p>tips: 预处理部分一次只插入一个字符，复杂度为 <span
class="math inline">\(O(n|s_0|^2)\)</span>
(也可以认为是稀疏矩阵乘法)</p>
<p>查询部分求解线性方程复杂度为 <span
class="math inline">\(O(|s_0|^2)\)</span> ，合并答案复杂度为 <span
class="math inline">\(O(|s_0|)\)</span></p>
<p>因此复杂度为 <span class="math inline">\(O((n+q)|s_0|^2)\)</span></p>
<p>Code: 注意两种dp共用了一个数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>,P=<span class="number">10007</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,len;</span><br><span class="line"><span class="type">char</span> str[N],t[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=ecnt; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erep(u,i) for(int i=head[u];i;i=e[i].nxt)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dep[N],id[N],fa[N][<span class="number">18</span>];</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line"><span class="type">int</span> f1[<span class="number">31</span>],f2[<span class="number">31</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	dep[u]=dep[fa[u][<span class="number">0</span>]=f]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">17</span>) fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,len) <span class="built_in">rep</span>(j,<span class="number">1</span>,len) &#123;</span><br><span class="line">		dp[u][i][j]=dp[f][i][j];</span><br><span class="line">		<span class="keyword">if</span>(str[u]==t[j]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j) dp[u][i][j]++,<span class="built_in">Mod1</span>(dp[u][i][j]);</span><br><span class="line">			<span class="keyword">if</span>(i&lt;j) dp[u][i][j]+=dp[f][i][j<span class="number">-1</span>],<span class="built_in">Mod1</span>(dp[u][i][j]);</span><br><span class="line">			<span class="keyword">if</span>(i&gt;j) dp[u][i][j]+=dp[f][i][j+<span class="number">1</span>],<span class="built_in">Mod1</span>(dp[u][i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">erep</span>(u,i) &#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">pre_dfs</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,d=dep[x]-dep[y];(<span class="number">1</span>&lt;&lt;i)&lt;=d;++i) <span class="keyword">if</span>(d&amp;(<span class="number">1</span>&lt;&lt;i)) x=fa[x][i];</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="built_in">drep</span>(i,<span class="number">17</span>,<span class="number">0</span>) <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];</span><br><span class="line">	<span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Calcdp1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,f1[<span class="number">0</span>]=<span class="number">1</span>,len) &#123;</span><br><span class="line">		f1[i]=dp[u][i][<span class="number">1</span>];</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,i<span class="number">-1</span>) f1[i]=(f1[i]-f1[j]*dp[f][i][j+<span class="number">1</span>])%P;</span><br><span class="line">		<span class="built_in">Mod2</span>(f1[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Calcdp2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">drep</span>(i,len,f2[len+<span class="number">1</span>]=<span class="number">1</span>) &#123;</span><br><span class="line">		f2[i]=dp[u][i][len];</span><br><span class="line">		<span class="built_in">rep</span>(j,i+<span class="number">1</span>,len+<span class="number">1</span>) f2[i]=(f2[i]-dp[f][i][j<span class="number">-1</span>]*f2[j])%P;</span><br><span class="line">		<span class="built_in">Mod2</span>(f2[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Que</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> lca=<span class="built_in">LCA</span>(x,y);</span><br><span class="line">	<span class="built_in">Calcdp1</span>(x,fa[lca][<span class="number">0</span>]),<span class="built_in">Calcdp2</span>(y,lca);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,len) ans=(ans+f1[i]*f2[i+<span class="number">1</span>])%P;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">		n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) head[i]=ecnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">2</span>,n) &#123;</span><br><span class="line">			<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>();</span><br><span class="line">			<span class="built_in">AddEdge</span>(u,v),<span class="built_in">AddEdge</span>(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,str+<span class="number">1</span>,t+<span class="number">1</span>),len=<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">pre_dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">			<span class="type">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Que</span>(x,y));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/2016%E5%A4%9A%E6%A0%A1%20ATM/</url>
    <content><![CDATA[<hr />
<p>title: '2016 多校5 ATM' date: 'Sat Aug 12 11:05:26 2023 categories: -
oi-solutions'</p>
<h1 id="多校5-atm">2016 多校5 ATM</h1>
<p>题意:</p>
<p>有个人富到不知道自己有多少钱，但是知道钱数 <span
class="math inline">\(x\in \Z \cap [0,K]\)</span></p>
<p>它最多可以有 <span class="math inline">\(W\)</span> 次查询超过钱数，
<span class="math inline">\(W\ge 1\)</span></p>
<p>要求在最优决策的情况下，最小次数取出所有钱的期望次数</p>
<p><span class="math display">\[ \ \]</span></p>
<p>设 <span class="math inline">\(K,W\)</span> 上界为 <span
class="math inline">\(O(n)\)</span></p>
<p>先考虑边界情况，如果它手里有 <span class="math inline">\(0\)</span>
块钱，那么需要查询一次才知道自己吃土了</p>
<p>如果手头 <span class="math inline">\(W=1\)</span> ，那么只能每次取
<span class="math inline">\(1\)</span> ，否则就可能被抓走</p>
<p>众所周知，<strong>情况个数有限</strong>的期望问题，可以先直接计数然后除掉情况数，所以</p>
<p>定义 <span class="math inline">\(dp_{i,j}\)</span>
为已知手头的票子上限 <span class="math inline">\(i\)</span> ，且还剩
<span class="math inline">\(j\)</span>
次会被抓去干奇怪的事情的最小代价总和</p>
<p>对于 <span class="math inline">\(j&gt;1\)</span>
的情况，我们需要决策这一次选出多少钱</p>
<p>假设这一次我们选择取出 <span class="math inline">\(k\)</span>
块钱</p>
<p>1.那么对于实际钱数为 <span class="math inline">\([0,k-1]\)</span>
的部分，查询会超限，并且知道上界变为 <span
class="math inline">\(k-1\)</span></p>
<p>2.对于实际钱数 <span class="math inline">\([k,i]\)</span>
的部分，上界变为 <span class="math inline">\(i-k\)</span></p>
<p>而这次决策产生的代价要计算所有情况的代价，即为 <span
class="math inline">\(i+1\)</span></p>
<p>因此，转移的表达式应是 <span class="math inline">\(\begin{aligned}
dp_{i,j}=\min_{k=1}^i\lbrace
dp_{k-1,j-1}+dp_{i-k,j}+i+1\rbrace\end{aligned}\)</span></p>
<p><del>因为不是期望而是计数，决策应该更好理解了吧</del></p>
<p>直接转移，复杂度为 <span class="math inline">\(O(n^3)\)</span></p>
<h3 id="优化1">优化1</h3>
<p>不会证明，但是 <span
class="math inline">\(dp_{k-1,j-1}+dp_{i-k,j}\)</span> 构成了关于 <span
class="math inline">\(k\)</span> 的
<strong>斜率单调非递减的函数</strong>(俗称<strong>单峰函数</strong>)，可以直接三分</p>
<p>复杂度为 <span class="math inline">\(O(n^2\log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ldb;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) dp[<span class="number">1</span>][i]=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) dp[i][<span class="number">1</span>]=i*(i+<span class="number">1</span>)/<span class="number">2</span>+i;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-1</span>) <span class="built_in">rep</span>(j,<span class="number">2</span>,N<span class="number">-1</span>) &#123;</span><br><span class="line">        dp[i][j]=<span class="number">1e9</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=i;</span><br><span class="line">        <span class="built_in">cmin</span>(dp[i][j],dp[<span class="number">0</span>][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j]+i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cmin</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+dp[<span class="number">0</span>][j]+i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">            <span class="type">int</span> a=(l+r)&gt;&gt;<span class="number">1</span>,b=a+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> x=dp[a<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i-a][j]+i+<span class="number">1</span>,y=dp[b<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i-b][j]+i+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cmin</span>(dp[i][j],x),<span class="built_in">cmin</span>(dp[i][j],y);</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=y) l=b;</span><br><span class="line">            <span class="keyword">else</span> r=a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)) <span class="built_in">printf</span>(<span class="string">&quot;%.6Lf\n&quot;</span>,(ldb)dp[n][m]/(n+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="优化2">优化2</h3>
<p>感性理解，钱的上界越大，显然我们每次最优决策要取出的也就越多</p>
<p>即 <span class="math inline">\(dp_{i,j}\)</span> 的最优决策位置关于
<span class="math inline">\(i\)</span> <strong>单调非递减</strong></p>
<p>由于转移的式子比较奇怪，这个题目不好使用决策单调性的分治优化方法<del>(或许很简单吗)</del></p>
<p>但是由于转移是一个单峰函数，不存在波动的问题，所以可以直接记录决策位置
<span class="math inline">\(g_{i,j}\)</span></p>
<p>或者说，就是单峰函数的最值位置是递增的，每次从 <span
class="math inline">\(g_{i-1,j}\)</span> 的最优位置开始向后找到 <span
class="math inline">\(g_{i,j}\)</span> 的峰的位置即可停止</p>
<p>对于每个 <span class="math inline">\(j\)</span> ， <span
class="math inline">\(g_{i,j}\)</span> 最多从 <span
class="math inline">\(1\)</span> 移动到 <span
class="math inline">\(K\)</span> ，所以复杂度为 <span
class="math inline">\(O(n^2)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ldb;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dp[N][N],G[N][N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) dp[<span class="number">1</span>][i]=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) dp[i][<span class="number">1</span>]=i*(i+<span class="number">1</span>)/<span class="number">2</span>+i;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-1</span>) <span class="built_in">rep</span>(j,<span class="number">2</span>,N<span class="number">-1</span>) &#123;</span><br><span class="line">        dp[i][j]=<span class="number">1e9</span>;</span><br><span class="line">        <span class="built_in">rep</span>(k,<span class="built_in">max</span>(G[i<span class="number">-1</span>][j],<span class="number">1</span>),i) &#123; <span class="comment">// 从上一个决策位置开始for</span></span><br><span class="line">            <span class="type">int</span> x=dp[k<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i-k][j]+i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=dp[i][j]) G[i][j]=k,dp[i][j]=x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)) <span class="built_in">printf</span>(<span class="string">&quot;%.6Lf\n&quot;</span>,(ldb)dp[n][m]/(n+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="优化3第二维大小的优化">优化3:第二维大小的优化</h3>
<p>我们知道，存在一种决策方法即每次二分上界，可以取到一个较优值</p>
<p>满足这个决策只需要 <span class="math inline">\(W\ge \log_2 k\)</span>
，大致可以认为 <span class="math inline">\(W\ge 10\)</span></p>
<p>在最优决策的情况下，一定可以在 <span
class="math inline">\(10\)</span> 次错误的范围内查出结果，即 <span
class="math inline">\(W\ge 10\)</span> 之后 <span
class="math inline">\(W\)</span> 的值已经不会影响答案了</p>
<p>所以直接上优化，转移复杂度就是 <span class="math inline">\(O(n^2\log
n)\)</span></p>
<p>加上决策单调性的优化，就是 <span class="math inline">\(O(n\log
n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(reg int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(reg int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,<span class="type">const</span> T &amp;b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">11</span>],G[N][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">10</span>) dp[<span class="number">1</span>][i]=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) dp[i][<span class="number">1</span>]=i*(i+<span class="number">1</span>)/<span class="number">2</span>+i;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-1</span>) <span class="built_in">rep</span>(j,<span class="number">2</span>,<span class="number">10</span>) &#123;</span><br><span class="line">        dp[i][j]=<span class="number">1e9</span>;</span><br><span class="line">        <span class="built_in">rep</span>(k,<span class="built_in">max</span>(G[i<span class="number">-1</span>][j],<span class="number">1</span>),i) &#123;</span><br><span class="line">            <span class="type">int</span> x=dp[k<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i-k][j]+i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=dp[i][j]) G[i][j]=k,dp[i][j]=x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)) <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,<span class="number">1.0</span>*dp[n][<span class="built_in">min</span>(m,<span class="number">10</span>)]/(n+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><del>以下是来自地狱的魔改代码</del> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="keyword">enum</span>&#123;N=<span class="number">2000</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m,dp[<span class="number">11</span>][N|<span class="number">1</span>],i,j,k,x;</span><br><span class="line"><span class="built_in">main</span>()&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N) dp[<span class="number">1</span>][i]=i*(i+<span class="number">1</span>)/<span class="number">2</span>+i;</span><br><span class="line">	<span class="built_in">rep</span>(j,<span class="number">2</span>,<span class="number">10</span>) <span class="built_in">rep</span>(i,dp[j][k=<span class="number">1</span>]=<span class="number">2</span>,N) &#123;</span><br><span class="line">		dp[j][i]=<span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span>(;k&lt;=i &amp;&amp; (x=dp[j<span class="number">-1</span>][k<span class="number">-1</span>]+dp[j][i-k]+i+<span class="number">1</span>)&lt;=dp[j][i];++k) dp[j][i]=x;</span><br><span class="line">		--k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))<span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,<span class="number">1.0</span>*dp[m&gt;<span class="number">10</span>?<span class="number">10</span>:m][n]/(n+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/5608/</url>
    <content><![CDATA[<hr />
<p>title: 'HDU-5608' date: 'Sat Aug 12 11:05:26 2023 categories: -
oi-solutions'</p>
<h1 id="hdu-5608">HDU-5608</h1>
<p>题意： <span
class="math inline">\(G(n)=n^2−3n+2=\sum_{d|n}F(d)\)</span> ，求 <span
class="math inline">\(\sum_1^nF(i)\)</span></p>
<p>反演得到： <span
class="math inline">\(F(n)=\sum_{d|n}\mu(d)G(\frac{n}{d})\)</span></p>
<p>则 <span
class="math inline">\(\sum_1^nF(i)=\sum_i\sum_{d|i}\mu(d)G(\frac{i}{d})\)</span></p>
<p><span
class="math inline">\(\sum_1^nF(i)=\sum_{i=1}^{n}G(i)\sum_{j=1}^{\lfloor
\frac{n}{i}\rfloor }\mu(j)\)</span></p>
<p>问题就是要快速求 <span class="math inline">\(G(i)\)</span> 前缀和和
<span class="math inline">\(\mu(i)\)</span> 前缀和</p>
<p>第一个是 <span class="math inline">\(O(1)\)</span>
求，第二个是杜教筛</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e6</span>+<span class="number">10</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Inv6=<span class="built_in">qpow</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> notpri[N],w[N];</span><br><span class="line"><span class="type">int</span> pri[N/<span class="number">4</span>],pc,Sw[N];</span><br><span class="line">map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SumG</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; <span class="comment">// O(1)求出G函数的前缀和</span></span><br><span class="line">	ll ans=<span class="number">1ll</span>*n*(n+<span class="number">1</span>)%P*(<span class="number">2</span>*n+<span class="number">1</span>)%P*Inv6%P;</span><br><span class="line">	ans=(ans<span class="number">-3ll</span>*n*(n+<span class="number">1</span>)/<span class="number">2</span>%P+<span class="number">2</span>*n)%P;</span><br><span class="line">	ans=(ans%P+P)%P;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sumw</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; <span class="comment">// 杜教筛求mobius函数前缀和</span></span><br><span class="line">	<span class="keyword">if</span>(n&lt;N) <span class="keyword">return</span> Sw[n];</span><br><span class="line">	<span class="keyword">if</span>(M.<span class="built_in">count</span>(n)) <span class="keyword">return</span> M[n];</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j;i&lt;=n;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">		j=n/(n/i);</span><br><span class="line">		ans-=(j-i+<span class="number">1</span>)*<span class="built_in">Sumw</span>(n/i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> M[n]=ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SumF</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; <span class="comment">// 答案</span></span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">		j=n/(n/i);</span><br><span class="line">		ans=(ans+<span class="number">1ll</span>*(<span class="built_in">SumG</span>(j)-<span class="built_in">SumG</span>(i<span class="number">-1</span>))*<span class="built_in">Sumw</span>(n/i))%P;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=(ans%P+P)%P;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	w[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!notpri[i]) pri[++pc]=i,w[i]=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pc &amp;&amp; <span class="number">1ll</span>*i*pri[j]&lt;N;++j) &#123;</span><br><span class="line">			notpri[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) &#123;</span><br><span class="line">				w[i*pri[j]]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			w[i*pri[j]]=-w[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) Sw[i]=Sw[i<span class="number">-1</span>]+w[i];</span><br><span class="line">	<span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">SumF</span>(<span class="built_in">rd</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/COCI20162017%20Contest#7%20F%20/</url>
    <content><![CDATA[<hr />
<p>title: 'COCI20162017 Contest#7 F' date: 'Sat Aug 12 11:05:24 2023
categories: - oi-solutions'</p>
<h1 id="coci20162017-contest7-f">COCI20162017 Contest#7 F</h1>
<h3 id="前置知识"><a
href="https://www.cnblogs.com/chasedeath/p/13396877.html">前置知识</a></h3>
<p>沿用上面的定义，设字符串 <span class="math inline">\(S\)</span> 的
<span class="math inline">\(\text{border}\)</span> 集合为 <span
class="math inline">\(B(S)\)</span></p>
<p>考虑对于单串 <span class="math inline">\(S\)</span> 求答案，设答案为
<span class="math inline">\(Ans\)</span></p>
<p>将所有可能出现的字符串分为两个集合 <span
class="math inline">\(A,B\)</span></p>
<p>其中 <span class="math inline">\(A\)</span> 为所有恰好出现 <span
class="math inline">\(S\)</span> 的字符串集合， <span
class="math inline">\(B\)</span> 为所有还未出现匹配的字符串集合</p>
<p>我们知道每个字符串出现有一定的概率，即为 <span
class="math inline">\(\frac{1}{n^{|T|}}\)</span></p>
<p>设 <span class="math inline">\(A\)</span> 集合中所有长度为 <span
class="math inline">\(i\)</span> 的串出现的概率总和为 <span
class="math inline">\(A_i\)</span> ，同理得到 <span
class="math inline">\(B_i\)</span></p>
<p><span class="math inline">\(A\)</span>
中的概率是不重复的，因为每个匹配过程只有一次会恰好匹配，因此可以得到
<span class="math inline">\(\sum A_i=1\)</span></p>
<p>(而 <span class="math inline">\(B\)</span>
中每个不匹配的串概率会被算多次)</p>
<p>最后的答案期望可以表示为</p>
<p>1.每个匹配的串概率*匹配时串的长度之和，即 <span
class="math inline">\(Ans=\sum_i i\cdot A_i\)</span></p>
<p>2.将匹配成功的长度，转化为匹配失败的次数之和(包含空串)，可以表示为
<span class="math inline">\(Ans=\sum B_i\)</span></p>
<p>直接计算似乎比较麻烦</p>
<p><span class="math display">\[ \ \]</span></p>
<p>考虑如果在 <span class="math inline">\(B\)</span>
中所有字符串的后面接上一个原串 <span class="math inline">\(S\)</span>
（同时概率乘上 <span class="math inline">\(\frac{1}{n^{|S|}}\)</span>
），那么得到的新字符串一定完成匹配</p>
<p>但是实际上，这样的串并不一定完全合法，因为可能在更早的位置出现匹配</p>
<p>由上面的定义，假设原先在 <span class="math inline">\(B\)</span>
中的串为 <span class="math inline">\(T\)</span> ，原先已经在 <span
class="math inline">\(S\)</span> 中匹配了 <span
class="math inline">\(T&#39;\)</span> 作为前缀</p>
<p>那么直接强行加上 <span class="math inline">\(S\)</span> 后，如果
<span class="math inline">\(T&#39;\)</span>
会影响第一个出现匹配位置，设出现匹配时加入的字符串为 <span
class="math inline">\(R\)</span></p>
<p>则显然满足: <span class="math inline">\(R\)</span> 即是 <span
class="math inline">\(S\)</span> 的一段前缀，又是 <span
class="math inline">\(S\)</span> 的一段后缀，也就是 <span
class="math inline">\(R\in B(S)\)</span></p>
<p>而剩下部分( <span class="math inline">\(|S|-|R|\)</span>
)，实际上是无效的，因此概率会被算小了</p>
<p><span class="math display">\[ \ \]</span></p>
<p>不妨设 <span class="math inline">\(B\)</span> 集合接上一个 <span
class="math inline">\(S\)</span> 串得到的集合为 <span
class="math inline">\(C\)</span></p>
<p>可以把 <span class="math inline">\(C\)</span>
中的字符串，按照多余的部分 <span class="math inline">\(|S|-|R|\)</span>
为多个部分 <span class="math inline">\(D_{R}\)</span> 其中 <span
class="math inline">\(R\in B(S)\)</span></p>
<p>发现，实际上去掉多余的部分后，每个 <span
class="math inline">\(D_R\)</span> 集合就与 <span
class="math inline">\(A\)</span> 集合对应，但是多余部分的要乘回去</p>
<p>即 <span class="math inline">\(A_i=D_{|R|,i+|S|-|R|}\cdot
n^{|S|-|R|}\)</span> (偏移多出的部分)</p>
<p>由 <span class="math inline">\(B,C\)</span> 的关系，有 <span
class="math inline">\(\sum_R D_{R,i}=C_i=B_i\cdot
\frac{1}{n^{|S|}}\)</span></p>
<p>也就是 <span class="math inline">\(B_i\frac{1}{n^{|S|}}=\sum _R
D_{R,i+|S|-|R|}=\sum _R \frac{A_{i+|S|-|R|}}{n^{|S|-|R|}}\)</span></p>
<p>即 <span class="math inline">\(B_i=\sum _R
A_{i+|S|-|R|}n^{|R|}\)</span></p>
<p>将上式求和对于 <span class="math inline">\(i\)</span> 求和，得到
<span class="math inline">\(\sum B_i=\sum_i\sum_R
A_{i+|S|-|R|}n^{|R|}\)</span></p>
<p>由于 <span class="math inline">\(\sum A_i=1\)</span> ( <span
class="math inline">\(\sum A_i\)</span> 和 <span
class="math inline">\(\sum A_{i+|S|-|R|}\)</span> 等价)， 即</p>
<p><span class="math inline">\(Ans=\sum B_i=\sum_{R\in B(S)}
n^{|R|}\)</span></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/6791%202020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BAT1/</url>
    <content><![CDATA[<hr />
<p>title: '<a
href="http://acm.hdu.edu.cn/showproblem.php?pid=6791">[HDU-6791]
2020HDU多校第三场T1</a>(回文自动机)' date: 'Sat Aug 12 11:05:26 2023
categories: - oi-solutions'</p>
<p>#<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6791">[HDU-6791]
2020HDU多校第三场T1</a>(回文自动机)</p>
<h3 id="前置知识">前置知识：</h3>
<p>1.<a
href="https://www.cnblogs.com/chasedeath/p/13396877.html">字符串的 <span
class="math inline">\(\text{Border}\)</span></a></p>
<p>2.<a
href="https://www.cnblogs.com/chasedeath/p/13396957.html">回文自动机</a></p>
<p>3.回文串与 <span class="math inline">\(\text{Border}\)</span></p>
<p>3.1:回文串的 <span class="math inline">\(\text{Border}\)</span>
也是回文串</p>
<p>若有回文串 <span class="math inline">\(S\)</span> 的一个 <span
class="math inline">\(\text{Border} :T\)</span> ，则 <span
class="math inline">\(S_{1,|T|}=S_{|S|-|T|+1,|S|}=reverse(S_{1,|T|})\)</span></p>
<p>故 <span class="math inline">\(T\)</span> 也是一个回文串</p>
<p>3.2:遍历回文自动机的 <span class="math inline">\(fail\)</span>
链，能得到当前串的所有 <span
class="math inline">\(\text{Border}\)</span> (基于3.1得到)</p>
<p>约定:串 <span class="math inline">\(S\)</span> 的 <span
class="math inline">\(\text{Border}\)</span> 集合为 <span
class="math inline">\(B(S)\)</span> ，字符集为 <span
class="math inline">\(\Sigma\)</span></p>
<h3 id="题意">题意:</h3>
<p>设随机空串末尾添加 <span class="math inline">\(\Sigma\)</span>
中的字符，第一次出现子串 <span class="math inline">\(S\)</span>
的期望长度为 <span class="math inline">\(E(S)\)</span></p>
<p>给定一个串，每次查询它的两个回文子串 <span
class="math inline">\(A,B\)</span> ，比较 <span
class="math inline">\(E(A),E(B)\)</span></p>
<h3 id="起源">起源？</h3>
<p>一切的起源都是" 国家集训队论文2018
:1-浅谈生成函数在掷骰子问题上的应用 "的一个结论。。。</p>
<p>还有为什么会是回文子串呢？因为只有回文自动机能访问子串的所有 <span
class="math inline">\(\text{Border}\)</span> 。。。</p>
<h3 id="结论-以及-口胡证明">结论 以及 口胡证明?</h3>
<p><span class="math inline">\(\begin{aligned}E(S)=\sum_{T\in
B(S)}|\Sigma|^{|T|}\end{aligned}\)</span> <del>(???)</del></p>
<p>在原论文给出了生成函数性的证明，实际可以直接口胡(好吧也差不多)，大致分成两个步骤</p>
<ol type="1">
<li><span class="math inline">\(E(S)=\sum_{i=0}^{\infty}\)</span> 长度为
<span class="math inline">\(i\)</span> 依然不包含 <span
class="math inline">\(S\)</span> 的概率(即把长度为 <span
class="math inline">\(i\)</span> 时恰好合法转化为了 <span
class="math inline">\(0..i-1\)</span> 时不合法)</li>
</ol>
<p>2.设所有长度下不合法的串集合为 <span class="math inline">\(G\)</span>
(每个不合法串有概率 <span class="math inline">\(G(T)\)</span>
)，合法的串集合为 <span class="math inline">\(F\)</span>
(每个合法串也有概率 <span class="math inline">\(F(T)\)</span> )</p>
<p>由第一步 <span class="math inline">\(E(S)=\sum G(T)\)</span>
，合法串的概率不会重复，所以 <span class="math inline">\(\sum
F(T)=1\)</span></p>
<p>考虑 <span class="math inline">\(G\)</span>
中所有的串，如果在后面接上 <span class="math inline">\(S\)</span>
必然合法，但是可能在更早的时候就结束了，这是必然满足接上的前缀是 <span
class="math inline">\(\text{Border}\)</span></p>
<p>也就是说，在 <span class="math inline">\(G\)</span> 集合后面接上
<span class="math inline">\(S\)</span> 后，不仅会得到 <span
class="math inline">\(F\)</span> 集合，还会得到 <span
class="math inline">\(F\)</span> 集合后面额外接上 <span
class="math inline">\(|S|-|R|,(R\in B(S))\)</span> 长度字符的状态</p>
<p>所以有 <span class="math inline">\(\sum G(T)\cdot
(\frac{1}{|\Sigma|})^{|S|}=\sum_{R\in B(S)}\sum F(T)\cdot
(\frac{1}{|\Sigma|})^{|S|-|R|}\)</span></p>
<p>化简且带入 <span class="math inline">\(\sum F(T)=1\)</span> ，得到
<span class="math inline">\(E(S)=\sum G(T)=\begin{aligned}\sum_{R\in
B(S)}|\Sigma|^{|R|}\end{aligned}\)</span></p>
<p>那么比较问题就落到了比较 <span
class="math inline">\(\text{Border}\)</span> 上面</p>
<p>视答案为为一个 <span class="math inline">\(26\)</span>
进制数从高位到低位比较，转化为直接从大到小比较 <span
class="math inline">\(\text{Border}\)</span> 序列的字典序即可</p>
<p>建出回文自动机后，倍增找到当前查询串对应的状态，所有的 <span
class="math inline">\(\text{Border}\)</span> 就是 <span
class="math inline">\(fail\)</span> 链上所有非空状态长度</p>
<p>比较字典序可以</p>
<p>1.倍增+hash</p>
<p>2.可以根据 <span class="math inline">\(\text{Border}\)</span>
的性质分解为等差数列后暴力比较</p>
<p>3.像后缀数组一样，倍增地去为所有节点的字典序排序，这样查询是 <span
class="math inline">\(O(1)\)</span> 的</p>
<p>hash应该细节比较少，但是常数大</p>
<p>以下是hash版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll P1=<span class="number">1e9</span>+<span class="number">13</span>,P2=<span class="number">19260817</span>;</span><br><span class="line"><span class="type">const</span> ll K1=<span class="number">123213</span>,K2=<span class="number">342525</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> now,len[N],fail[N],nxt[N][<span class="number">26</span>],pos[N],cnt;</span><br><span class="line"><span class="type">int</span> Pow1[N],Pow2[N];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">18</span>],h1[N][<span class="number">18</span>],h2[N][<span class="number">18</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,cnt) <span class="built_in">memset</span>(nxt[i],fail[i]=<span class="number">0</span>,<span class="number">104</span>);</span><br><span class="line">	len[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">	fail[now=<span class="number">0</span>]=fail[<span class="number">1</span>]=cnt=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(s[y]!=s[y-len[x]<span class="number">-1</span>]) x=fail[x];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Extend</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	now=<span class="built_in">Find</span>(now,i);</span><br><span class="line">	<span class="keyword">if</span>(!nxt[now][c])&#123;</span><br><span class="line">		fail[++cnt]=nxt[<span class="built_in">Find</span>(fail[now],i)][c];</span><br><span class="line">		len[nxt[now][c]=cnt]=len[now]+<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pos[i]=now=nxt[now][c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Que</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	l=p-l+<span class="number">1</span>,p=pos[p];</span><br><span class="line">	<span class="built_in">drep</span>(i,<span class="number">17</span>,<span class="number">0</span>) <span class="keyword">if</span>(len[fa[p][i]]&gt;=l) p=fa[p][i];</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,Pow1[<span class="number">0</span>]=Pow2[<span class="number">0</span>]=<span class="number">1</span>,N<span class="number">-1</span>) Pow1[i]=<span class="number">1ll</span>*Pow1[i<span class="number">-1</span>]*K1%P1,Pow2[i]=Pow2[i<span class="number">-1</span>]*K2%P2;</span><br><span class="line">	<span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>())&#123;</span><br><span class="line">		<span class="built_in">Init</span>(),n=<span class="built_in">rd</span>(),<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">Extend</span>(i,s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">2</span>,cnt) &#123;</span><br><span class="line">			fa[i][<span class="number">0</span>]=fail[i],h1[i][<span class="number">0</span>]=h2[i][<span class="number">0</span>]=len[i];</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">1</span>,<span class="number">17</span>)&#123;</span><br><span class="line">				fa[i][j]=fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">if</span>(fa[i][j]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">					h1[i][j]=(<span class="number">1ll</span>*h1[i][j<span class="number">-1</span>]*Pow1[<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)]+h1[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>])%P1;</span><br><span class="line">					h2[i][j]=(<span class="number">1ll</span>*h2[i][j<span class="number">-1</span>]*Pow2[<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)]+h2[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>])%P2;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(q,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">			<span class="type">int</span> A=<span class="built_in">rd</span>(),B=<span class="built_in">rd</span>(),C=<span class="built_in">rd</span>(),D=<span class="built_in">rd</span>();</span><br><span class="line">			A=<span class="built_in">Que</span>(A,B),C=<span class="built_in">Que</span>(C,D);</span><br><span class="line">			<span class="built_in">drep</span>(i,<span class="number">17</span>,<span class="number">0</span>) <span class="keyword">if</span>(fa[A][i]&gt;<span class="number">1</span> &amp;&amp; fa[C][i]&gt;<span class="number">1</span> &amp;&amp; h1[A][i]==h1[C][i] &amp;&amp; h2[A][i]==h2[C][i]) A=fa[A][i],C=fa[C][i];</span><br><span class="line">			A=<span class="built_in">max</span>(len[A],<span class="number">0</span>),C=<span class="built_in">max</span>(len[C],<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(A==C) <span class="built_in">puts</span>(<span class="string">&quot;draw&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(A&lt;C) <span class="built_in">puts</span>(<span class="string">&quot;sjfnb&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;cslnb&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/5869/</url>
    <content><![CDATA[<hr />
<p>title: 'HDU-5869 Different GCD Subarray Query(树状数组)' date: 'Sat
Aug 12 11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="hdu-5869-different-gcd-subarray-query树状数组">HDU-5869
Different GCD Subarray Query(树状数组)</h1>
<p>先不考虑查询的区间 <span class="math inline">\([L,R]\)</span></p>
<p>首先我们枚举一个 <span class="math inline">\(\gcd\)</span> 区间的
<span class="math inline">\(l\)</span> ，考虑不同的 <span
class="math inline">\(\gcd(l..r)\)</span> 实际上只有 <span
class="math inline">\(\log n\)</span> 个，因为每次改变， <span
class="math inline">\(\gcd\)</span> 的值至少减少一倍</p>
<p>维护一个倍增数组，可以 <span class="math inline">\(\log n\)</span>
二分出下一个 <span class="math inline">\(\gcd\)</span> 不同的 <span
class="math inline">\(r\)</span> ，统计出每一个的 <span
class="math inline">\(r\)</span> ，那么就能得到 <span
class="math inline">\(n\log n\)</span> 个不同的区间</p>
<p>问题就转化为求 <span class="math inline">\([L,R]\)</span>
包含的权值不同的 <span class="math inline">\([l,r]\)</span> 个数</p>
<p>那么可以把同一种权值的区间拉出来，离线之后，按照 <span
class="math inline">\(l\)</span> 和 <span
class="math inline">\(L\)</span> 倒序，每次对于 <span
class="math inline">\([l,r]\)</span> 更新的区间就是 <span
class="math inline">\(r\)</span> 到这个权值之前出现过的最小 <span
class="math inline">\(r\)</span></p>
<p>一共有 <span class="math inline">\(n\log n\)</span>
个更新，用树状数组维护区间更新，复杂度 <span
class="math inline">\(O(n\log^2n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> b==<span class="number">0</span>?a:<span class="built_in">gcd</span>(b,a%b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">	<span class="type">int</span> s[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">rep</span>(i,<span class="number">1</span>,n) s[i]=<span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">while</span>(p&lt;=n) s[p]+=x,p+=p&amp;-p; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Que</span><span class="params">(<span class="type">int</span> p)</span></span>&#123; </span><br><span class="line">		<span class="type">int</span> res=<span class="number">0</span>; </span><br><span class="line">		<span class="keyword">while</span>(p) res+=s[p],p-=p&amp;-p; </span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123; <span class="type">int</span> p,id; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Update</span>&#123; <span class="type">int</span> p,x; &#125;;</span><br><span class="line">vector &lt;Query&gt; Q[N];</span><br><span class="line">vector &lt;Update&gt; U[N];</span><br><span class="line"><span class="type">int</span> A[N],ans[N],G[N][<span class="number">18</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> apr[N],apc,mk[N*<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddUpdate</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!mk[x]) apr[++apc]=x,mk[x]=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;=mk[x]) <span class="keyword">return</span>;</span><br><span class="line">	U[l].<span class="built_in">pb</span>((Update)&#123;r,<span class="number">1</span>&#125;),U[l].<span class="built_in">pb</span>((Update)&#123;mk[x],<span class="number">-1</span>&#125;);</span><br><span class="line">	mk[x]=r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)) &#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">			A[i]=<span class="built_in">rd</span>(),Q[i].<span class="built_in">clear</span>(),U[i].<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">drep</span>(i,n,<span class="number">1</span>) &#123;</span><br><span class="line">			G[i][<span class="number">0</span>]=A[i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)&lt;=n+<span class="number">1</span>;++j) G[i][j]=<span class="built_in">gcd</span>(G[i][j<span class="number">-1</span>],G[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">			<span class="type">int</span> x=A[i],r=i;</span><br><span class="line">			<span class="keyword">while</span>(r&lt;=n) &#123;</span><br><span class="line">				<span class="built_in">AddUpdate</span>(i,r,x);</span><br><span class="line">				<span class="built_in">drep</span>(j,<span class="number">17</span>,<span class="number">0</span>) <span class="keyword">if</span>(r+(<span class="number">1</span>&lt;&lt;j)&lt;=n+<span class="number">1</span> &amp;&amp; G[r][j]%x==<span class="number">0</span>) r+=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">				x=<span class="built_in">gcd</span>(x,A[r]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">			<span class="type">int</span> l=<span class="built_in">rd</span>(),r=<span class="built_in">rd</span>();</span><br><span class="line">			Q[l].<span class="built_in">pb</span>((Query)&#123;r,i&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		Tree.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">drep</span>(i,n,<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> j:U[i]) Tree.<span class="built_in">Add</span>(j.p,j.x);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> j:Q[i]) ans[j.id]=Tree.<span class="built_in">Que</span>(j.p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,apc) mk[apr[i]]=<span class="number">0</span>; apc=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/6801%202020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BAT11/</url>
    <content><![CDATA[<hr />
<p>title: 'HDU-6801 2020HDU多校第三场T11 (生成函数)' date: 'Sat Aug 12
11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="hdu-6801-2020hdu多校第三场t11-生成函数">HDU-6801
2020HDU多校第三场T11 (生成函数)</h1>
<p>题解又给式子不解释了。。</p>
<p>设未被选中的概率 <span class="math inline">\(q=1-p\)</span></p>
<p>设 <span class="math inline">\(a_i\)</span> 为 <span
class="math inline">\(c\)</span> 号点被选中前有 <span
class="math inline">\(i\)</span> 个点被选中的概率，它的普通生成函数为
<span class="math inline">\(A(x)\)</span></p>
<p>考虑枚举 <span class="math inline">\(c\)</span> 在第 <span
class="math inline">\(i\)</span> 次被访问到时被选中</p>
<p>则 <span class="math inline">\(c\)</span> 前面的 <span
class="math inline">\(c-1\)</span> 个点在转的过程中被访问了 <span
class="math inline">\(i\)</span> 次，后面的 <span
class="math inline">\(n-c\)</span> 个点被访问了 <span
class="math inline">\(i-1\)</span>
次(可能在没有经过这么多次时就已经被删掉了，但是不影响概率的计算)，因此可以简单考虑这两种点在
<span class="math inline">\(c\)</span> 之前被选中的概率</p>
<p>得到一个 <span class="math inline">\(A(x)\)</span> 的表示</p>
<p><span class="math inline">\(\begin{aligned}
A(x)=\sum_{i=1}^{\infty}p\cdot q^{i-1}\cdot (q^i+(1-q^i)x)^{c-1}\cdot
(q^{i-1}+(1-q^{i-1}x))^{n-c}\end{aligned}\)</span></p>
<p>也即题解中的式子</p>
<p><span class="math inline">\(\begin{aligned}
A(x)=\sum_{i=0}^{\infty}p\cdot q^i\cdot
(q^{i+1}+(1-q^{i+1})x)^{c-1}\cdot
(q^i+(1-q^ix))^{n-c}\end{aligned}\)</span></p>
<p>然后是暴力展开</p>
<p><span class="math inline">\(\begin{aligned}
A(x)=\sum_{i=0}^{\infty}p\cdot q^i\cdot (q^{i+1}(1-x)+x)^{c-1}\cdot
(q^i(1-x)+x)^{n-c}\end{aligned}\)</span></p>
<p><span class="math inline">\(\begin{aligned}
A(x)=\sum_{i=0}^{\infty}p\cdot q^i\cdot (\sum_{j=0}^{c-1}C(c-1,j)\cdot
q^{(i+1)j}(1-x)^jx^{c-1-j})\cdot (\sum_{k=0}^{n-c}C(n-c,k)\cdot
q^{ik}(1-x)^kx^{n-c-k})\end{aligned}\)</span></p>
<p><span class="math inline">\(\begin{aligned}
A(x)=\sum_{i=0}^{\infty}p\cdot q^i\cdot \sum_{j=0}^{c-1}\sum_{k=0}^{n-c}
C(c-1,j)\cdot C(n-c,k)\cdot
q^{(i+1)j+ik}(1-x)^{j+k}x^{n-j-k-1}\end{aligned}\)</span></p>
<p>这个式子极其反人类，把 <span class="math inline">\(i\)</span>
换到右边化掉</p>
<p><span class="math inline">\(\begin{aligned}
A(x)=\sum_{j=0}^{c-1}\sum_{k=0}^{n-c} C(c-1,j)\cdot C(n-c,k)\cdot
(1-x)^{j+k}x^{n-j-k-1}\cdot \sum_{i=0}^{\infty}p\cdot q^i
q^{(i+1)j+ik}\end{aligned}\)</span></p>
<p>右边是一个收敛的无穷等比数列</p>
<p><span class="math inline">\(\begin{aligned}
A(x)=\sum_{j=0}^{c-1}\sum_{k=0}^{n-c} C(c-1,j)\cdot C(n-c,k)\cdot
(1-x)^{j+k}x^{n-j-k-1}\cdot
\frac{pq^j}{1-q^{j+k+1}}\end{aligned}\)</span></p>
<p><span class="math inline">\(\begin{aligned}
A(x)=\sum_{j=0}^{c-1}\sum_{k=0}^{n-c} C(c-1,j)\cdot C(n-c,k)\cdot
x^{n-j-k-1}\frac{pq^j}{1-q^{j+k+1}}\cdot (\sum_{i=0}^{j+k} C(j+k,i)
\cdot (-x)^i)\end{aligned}\)</span></p>
<p>虽然有三个循环，但是很显然可以先对于 <span
class="math inline">\(j,k\)</span> 进行一次卷积，然后再对于 <span
class="math inline">\(j+k,-i\)</span> 进行一次卷积得到</p>
<p>Code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">21</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,c,p,q;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N],Fac[N+<span class="number">1</span>],Inv[N+<span class="number">1</span>],FInv[N+<span class="number">1</span>],rev[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Fac[<span class="number">0</span>]=Fac[<span class="number">1</span>]=Inv[<span class="number">0</span>]=Inv[<span class="number">1</span>]=FInv[<span class="number">0</span>]=FInv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,N) &#123;</span><br><span class="line">		Fac[i]=<span class="number">1ll</span>*Fac[i<span class="number">-1</span>]*i%P;</span><br><span class="line">		Inv[i]=<span class="number">1ll</span>*(P-P/i)*Inv[P%i]%P;</span><br><span class="line">		FInv[i]=<span class="number">1ll</span>*FInv[i<span class="number">-1</span>]*Inv[i]%P;</span><br><span class="line">	&#125;</span><br><span class="line">	w[N&gt;&gt;<span class="number">1</span>]=<span class="number">1</span>; ll t=<span class="built_in">qpow</span>(<span class="number">3</span>,(P<span class="number">-1</span>)/N);</span><br><span class="line">	<span class="built_in">rep</span>(i,(N&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>,N<span class="number">-1</span>) w[i]=w[i<span class="number">-1</span>]*t%P;</span><br><span class="line">	<span class="built_in">drep</span>(i,(N&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>,<span class="number">1</span>) w[i]=w[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> R=<span class="number">1</span>,c=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(R&lt;n) R&lt;&lt;=<span class="number">1</span>,c++;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,R<span class="number">-1</span>) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;c);</span><br><span class="line">	<span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *a,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> *e=w+i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;n;l+=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) &#123;</span><br><span class="line">				<span class="type">int</span> t=<span class="number">1ll</span>*a[j+i]*e[j-l]%P;</span><br><span class="line">				a[j+i]=a[j]-t; <span class="built_in">Mod2</span>(a[j+i]);</span><br><span class="line">				a[j]+=t; <span class="built_in">Mod1</span>(a[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=<span class="number">1ll</span>*a[i]*Inv[n]%P;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[N],B[N],C[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">	<span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">		n=<span class="built_in">rd</span>(),p=<span class="built_in">rd</span>(),q=<span class="built_in">rd</span>(),p=p*<span class="built_in">qpow</span>(q)%P,q=P+<span class="number">1</span>-p,c=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="type">int</span> R=<span class="built_in">Init</span>(n),t=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) A[i]=B[i]=C[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,c<span class="number">-1</span>) &#123;</span><br><span class="line">			A[i]=<span class="number">1ll</span>*Fac[c<span class="number">-1</span>]*FInv[i]%P*FInv[c<span class="number">-1</span>-i]%P*t%P;</span><br><span class="line">			t=<span class="number">1ll</span>*t*q%P; <span class="comment">// t= q^i</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n-c) B[i]=<span class="number">1ll</span>*Fac[n-c]*FInv[i]%P*FInv[n-c-i]%P;</span><br><span class="line">		<span class="built_in">NTT</span>(R,A,<span class="number">1</span>),<span class="built_in">NTT</span>(R,B,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) A[i]=<span class="number">1ll</span>*A[i]*B[i]%P;</span><br><span class="line">		<span class="built_in">NTT</span>(R,A,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		R=<span class="built_in">Init</span>(n*<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,n,R<span class="number">-1</span>) A[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) B[i]=<span class="number">0</span>;</span><br><span class="line">		t=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">			t=<span class="number">1ll</span>*t*q%P; <span class="comment">// t=q^&#123;i+1&#125;</span></span><br><span class="line">			A[i]=<span class="number">1ll</span>*A[i]*Fac[i]%P*<span class="built_in">qpow</span>(P+<span class="number">1</span>-t)%P;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n) B[n-i]=(i&amp;<span class="number">1</span>)?P-FInv[i]:FInv[i];</span><br><span class="line">		<span class="built_in">NTT</span>(R,A,<span class="number">1</span>),<span class="built_in">NTT</span>(R,B,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,R<span class="number">-1</span>) A[i]=<span class="number">1ll</span>*A[i]*B[i]%P;</span><br><span class="line">		<span class="built_in">NTT</span>(R,A,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">int</span>(<span class="number">1ll</span>*FInv[n-i]*A[<span class="number">2</span>*n-i]%P*p%P));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际跑两次卷积，写得丑几乎就是顶着时限过去的。。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/COCI/%5BCOCI2010-2011#7%5D%20UPIT/</url>
    <content><![CDATA[<hr />
<p>title: '[COCI2010-2011#7] UPIT' date: 'Sat Aug 12 11:05:24 2023
categories: - oi-solutions'</p>
<h1 id="coci2010-20117-upit">[COCI2010-2011#7] UPIT</h1>
<p>约定:视 <span class="math inline">\(n,q\)</span> 同阶</p>
<p>看一下题目的操作</p>
<p>1.区间赋值</p>
<p>2.区间差分加</p>
<p>3.插入元素</p>
<p>4.区间查询</p>
<p>我们知道1,2操作都是可以用懒标记维护的，具体过程可能有一点细节</p>
<p>1.记录区间差分加的过程，要记录等差数列首项和公差，两个等差数列相加直接首项和公差都相加即可</p>
<p>2.区间赋值的优先级要高于加法，即打上赋值标记就要清空加法标记，标记下传时注意先下传赋值标记</p>
<p>然后具体问题落到如何实现插入元素这个操作上</p>
<h3 id="块状链表">块状链表</h3>
<p>对于静态的数组，可以直接静态分块来做</p>
<p>而要动态插入时，找到对应块，插入即可，但是涉及到编号问题</p>
<p>所以需要每个块维护一个 <span class="math inline">\(Size\)</span>
，块内每个元素维护一个标号 <span class="math inline">\(id_i\)</span></p>
<p>同时需要对于块的 <span class="math inline">\(Size\)</span> 累前缀和
<span class="math inline">\(SumSize\)</span> ，则块 <span
class="math inline">\(i\)</span> 内编号为 <span
class="math inline">\(j\)</span> 的元素在数组中的实际编号为 <span
class="math inline">\(SumSize_{i-1}+j\)</span></p>
<p>插入时把整个块内的元素取出重新标号即可</p>
<p>但是这样插入后，一个块的 <span class="math inline">\(Size\)</span>
会变大，再实现分块的操作时复杂度没有保证</p>
<p>因此需要加入一个操作:当 <span class="math inline">\(Size_i&gt;2\sqrt
n\)</span> 时, <span class="math inline">\(O(n)\)</span>
重构整个序列，这样每 <span class="math inline">\(\sqrt n\)</span>
次插入操作会导致一次重构，复杂度为均摊的 <span
class="math inline">\(O(n\sqrt n)\)</span></p>
<p>然后可以用类似分块的方法来直接维护</p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="线段树">线段树</h3>
<p>静态的操作线段树可以直接维护</p>
<p>在线段树上额外维护一个01，表示这个元素是否出现</p>
<p>将插入操作转化为在让对应位置的0变为1，但是由于不知道插入后的位置，所以不能直接操作</p>
<p>于是有两种解决办法</p>
<h4 id="暴力值域">暴力值域</h4>
<p>静态情况下我们对于 <span class="math inline">\([1,n]\)</span>
建树，但是动态可以对于 <span class="math inline">\([1,n\cdot q]\)</span>
建函数式线段树</p>
<h3 id="离线">离线</h3>
<p>离线维护，预处理出插入的位置</p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="平衡树">平衡树</h3>
<p><del>下面是安利时间</del></p>
<p>来学Treap吧</p>
<p>它可以</p>
<p>1.查询k大</p>
<p>2.插入元素</p>
<p>3.区间修改</p>
<p>4.区间翻转</p>
<p>5.可持久化!!</p>
<p><del>6.吊打Splay</del></p>
<p>Treap 即树堆，意思是在满足二叉查找树的性质同时满足二叉堆的性质</p>
<p>给定每个节点一个额外的随机权值，让二叉查找树对于这个权值满足堆的性质即可</p>
<p>这样构造的二叉查找树，树高是 <span class="math inline">\(O(\log
n)\)</span> 的</p>
<h4 id="带旋treap">带旋Treap</h4>
<p>像普通二叉查找树一样每次插入节点到叶子位置后，可能不满足二叉堆的性质，因此需要不断向上zig/zag来调整满足</p>
<p>区间操作可以尝试像写线段树一样写</p>
<p>但是它不可持久化</p>
<h4 id="非旋treap">非旋Treap</h4>
<p>维护两个基础操作</p>
<p>1.平衡树合并，操作需要满足两棵树的大小顺序确定，返回新的根</p>
<p>2.平衡树分裂为 <span class="math inline">\([1,d],[d+1,n]\)</span>
的两部分，返回两棵树的根</p>
<p>1.合并操作 <span class="math inline">\(x,y\)</span></p>
<p>按照节点的权值比较谁是平衡树的根，然后将根的左/右子树与另一棵树合并作为新的子树，递归实现</p>
<p>2.分裂 <span class="math inline">\(x,d\)</span></p>
<p>维护 <span class="math inline">\(Size\)</span>
判断是要分裂左子树还是右子树，将子树分裂得到的部分作为 <span
class="math inline">\(x\)</span> 新的子树，递归实现即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x|y;</span><br><span class="line">	<span class="built_in">Down</span>(x),<span class="built_in">Down</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(key[x]&lt;key[y]) <span class="keyword">return</span> rs[x]=<span class="built_in">Union</span>(rs[x],y),<span class="built_in">Up</span>(x),x;</span><br><span class="line">	<span class="keyword">return</span> ls[y]=<span class="built_in">Union</span>(x,ls[y]),<span class="built_in">Up</span>(y),y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Pii <span class="title">Split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="built_in">mp</span>(x,x);</span><br><span class="line">	<span class="keyword">if</span>(sz[x]&lt;=d) <span class="keyword">return</span> <span class="built_in">mp</span>(x,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(d==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">0</span>,x);</span><br><span class="line">	<span class="built_in">Down</span>(x);</span><br><span class="line">	<span class="keyword">if</span>(sz[ls[x]]+<span class="number">1</span>&lt;=d) &#123;</span><br><span class="line">		Pii y=<span class="built_in">Split</span>(rs[x],d-sz[ls[x]]<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> rs[x]=y.first,<span class="built_in">Up</span>(x),<span class="built_in">mp</span>(x,y.second);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Pii y=<span class="built_in">Split</span>(ls[x],d);</span><br><span class="line">		<span class="keyword">return</span> ls[x]=y.second,<span class="built_in">Up</span>(x),<span class="built_in">mp</span>(y.first,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入操作可以分裂前 <span class="math inline">\(k\)</span>
个，将新节点和得到的两棵树按次合并</p>
<p>区间更新可以分裂两次，将对应区间的子树操作即可</p>
<h2 id="code">Code</h2>
<p>块状链表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ldb;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">    T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line"><span class="type">int</span> head[N],nxt[N],sz[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123; <span class="type">int</span> rk,id; &#125; E[N];</span><br><span class="line">ll s[N],st[N],t[N],d[N],a[N]; </span><br><span class="line"><span class="type">int</span> ssz[N];</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">Get</span><span class="params">(ll l,ll r)</span></span>&#123; <span class="keyword">return</span> (r-l+<span class="number">1</span>)*(l+r)/<span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Down</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    s[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[p];i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(~st[p]) a[E[i].id]=st[p];</span><br><span class="line">        a[E[i].id]+=<span class="number">1ll</span>*(E[i].rk<span class="number">-1</span>)*d[p]+t[p];</span><br><span class="line">        s[p]+=a[E[i].id];</span><br><span class="line">    &#125;</span><br><span class="line">    st[p]=<span class="number">-1</span>,t[p]=d[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    s[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[p];i;i=nxt[i]) s[p]+=a[E[i].id];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(E+<span class="number">1</span>,E+n+<span class="number">1</span>,[&amp;](Node x,Node y)&#123; <span class="keyword">return</span> x.rk&lt;y.rk; &#125;);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,cnt) sz[i]=head[i]=<span class="number">0</span>,st[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">        <span class="type">int</span> p=i/cnt+<span class="number">1</span>;</span><br><span class="line">        nxt[i]=head[p],E[i].rk=++sz[p];</span><br><span class="line">        head[p]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,cnt) ssz[i]=ssz[i<span class="number">-1</span>]+sz[i],<span class="built_in">Up</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Break</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,cnt) &#123;</span><br><span class="line">        sz[i]+=sz[i<span class="number">-1</span>],<span class="built_in">Down</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[i];j;j=nxt[j]) E[j].rk+=sz[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Build</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    x--;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(sz[l]&lt;=x) x-=sz[l++];</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=p&lt;=n?<span class="built_in">Get</span>(p):cnt;</span><br><span class="line">    <span class="built_in">Down</span>(l),p-=ssz[l<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[l];i;i=nxt[i]) <span class="keyword">if</span>(E[i].rk&gt;=p) E[i].rk++;</span><br><span class="line">    a[++n]=x,E[n]=(Node)&#123;p,n&#125;,nxt[n]=head[l],head[l]=n;</span><br><span class="line">    sz[l]++,s[l]+=x;</span><br><span class="line">    <span class="keyword">if</span>(sz[l]&gt;cnt*<span class="number">2.4</span>) <span class="built_in">Break</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,cnt) ssz[i]=ssz[i<span class="number">-1</span>]+sz[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p1=<span class="built_in">Get</span>(l),p2=<span class="built_in">Get</span>(r);</span><br><span class="line">    <span class="keyword">if</span>(p1==p2) &#123;</span><br><span class="line">        <span class="built_in">Down</span>(p1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[p1];i;i=nxt[i]) <span class="keyword">if</span>(ssz[p1<span class="number">-1</span>]+E[i].rk&gt;=l &amp;&amp; ssz[p1<span class="number">-1</span>]+E[i].rk&lt;=r) a[E[i].id]=x;</span><br><span class="line">        <span class="built_in">Up</span>(p1);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Down</span>(p1),<span class="built_in">Down</span>(p2);</span><br><span class="line">    s[p1]=s[p2]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[p1];i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ssz[p1<span class="number">-1</span>]+E[i].rk&gt;=l) a[E[i].id]=x;</span><br><span class="line">        s[p1]+=a[E[i].id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[p2];i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ssz[p2<span class="number">-1</span>]+E[i].rk&lt;=r) a[E[i].id]=x;</span><br><span class="line">        s[p2]+=a[E[i].id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,p1+<span class="number">1</span>,p2<span class="number">-1</span>) st[i]=x,d[i]=t[i]=<span class="number">0</span>,s[i]=<span class="number">1ll</span>*x*sz[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p1=<span class="built_in">Get</span>(l),p2=<span class="built_in">Get</span>(r);</span><br><span class="line">    <span class="keyword">if</span>(p1==p2) &#123;</span><br><span class="line">        <span class="built_in">Down</span>(p1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[p1];i;i=nxt[i]) <span class="keyword">if</span>(ssz[p1<span class="number">-1</span>]+E[i].rk&gt;=l &amp;&amp; ssz[p1<span class="number">-1</span>]+E[i].rk&lt;=r) a[E[i].id]+=<span class="number">1ll</span>*(ssz[p1<span class="number">-1</span>]+E[i].rk-l+<span class="number">1</span>)*x;</span><br><span class="line">        <span class="built_in">Up</span>(p1);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Down</span>(p1),<span class="built_in">Down</span>(p2);</span><br><span class="line">    s[p1]=s[p2]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[p1];i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ssz[p1<span class="number">-1</span>]+E[i].rk&gt;=l) a[E[i].id]+=<span class="number">1ll</span>*(ssz[p1<span class="number">-1</span>]+E[i].rk-l+<span class="number">1</span>)*x;</span><br><span class="line">        s[p1]+=a[E[i].id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[p2];i;i=nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ssz[p2<span class="number">-1</span>]+E[i].rk&lt;=r) a[E[i].id]+=<span class="number">1ll</span>*(ssz[p2<span class="number">-1</span>]+E[i].rk-l+<span class="number">1</span>)*x;</span><br><span class="line">        s[p2]+=a[E[i].id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,p1+<span class="number">1</span>,p2<span class="number">-1</span>) &#123;</span><br><span class="line">        t[i]+=<span class="number">1ll</span>*(ssz[i<span class="number">-1</span>]-l+<span class="number">2</span>)*x,d[i]+=x;</span><br><span class="line">        s[i]+=<span class="built_in">Get</span>(ssz[i<span class="number">-1</span>]-l+<span class="number">2</span>,ssz[i]-l+<span class="number">1</span>)*x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">Que</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p1=<span class="built_in">Get</span>(l),p2=<span class="built_in">Get</span>(r);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Down</span>(p1),<span class="built_in">Down</span>(p2);</span><br><span class="line">    <span class="keyword">if</span>(p1==p2) &#123;</span><br><span class="line">        <span class="built_in">Down</span>(p1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[p1];i;i=nxt[i]) <span class="keyword">if</span>(ssz[p1<span class="number">-1</span>]+E[i].rk&gt;=l &amp;&amp; ssz[p1<span class="number">-1</span>]+E[i].rk&lt;=r) ans+=a[E[i].id];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Down</span>(p1),<span class="built_in">Down</span>(p2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[p1];i;i=nxt[i]) <span class="keyword">if</span>(ssz[p1<span class="number">-1</span>]+E[i].rk&gt;=l) ans+=a[E[i].id];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[p2];i;i=nxt[i]) <span class="keyword">if</span>(ssz[p2<span class="number">-1</span>]+E[i].rk&lt;=r) ans+=a[E[i].id];</span><br><span class="line">    <span class="built_in">rep</span>(i,p1+<span class="number">1</span>,p2<span class="number">-1</span>) ans+=s[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">    cnt=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n+m));</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">rd</span>(),E[i]=(Node)&#123;i,i&#125;;</span><br><span class="line">    <span class="built_in">Build</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">        <span class="type">int</span> opt=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="built_in">rd</span>(),r=<span class="built_in">rd</span>(),x=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">Set</span>(l,r,x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="built_in">rd</span>(),r=<span class="built_in">rd</span>(),x=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">Add</span>(l,r,x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> p=<span class="built_in">rd</span>(),x=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">Insert</span>(p,x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="built_in">rd</span>(),r=<span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">Que</span>(l,r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>旋Treap:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ldb;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> rt,son[N][<span class="number">2</span>],fa[N];</span><br><span class="line">ll s[N],t[N],d[N],st[N],val[N];</span><br><span class="line">ll sz[N],key[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	s[p]=s[son[p][<span class="number">0</span>]]+s[son[p][<span class="number">1</span>]]+val[p];</span><br><span class="line">	sz[p]=sz[son[p][<span class="number">0</span>]]+sz[son[p][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> p,ll x)</span></span>&#123;</span><br><span class="line">	t[p]=d[p]=<span class="number">0</span>,st[p]=val[p]=x,s[p]=sz[p]*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> p,ll x,ll d)</span> </span>&#123;</span><br><span class="line">	val[p]+=x+d*sz[son[p][<span class="number">0</span>]];</span><br><span class="line">	s[p]+=sz[p]*(sz[p]<span class="number">-1</span>)/<span class="number">2</span>*d+x*sz[p];</span><br><span class="line">	t[p]+=x,::d[p]+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Down</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(~st[p]) <span class="built_in">Set</span>(son[p][<span class="number">0</span>],st[p]),<span class="built_in">Set</span>(son[p][<span class="number">1</span>],st[p]),st[p]=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(t[p] || d[p]) <span class="built_in">Add</span>(son[p][<span class="number">0</span>],t[p],d[p]),<span class="built_in">Add</span>(son[p][<span class="number">1</span>],t[p]+(sz[son[p][<span class="number">0</span>]]+<span class="number">1</span>)*d[p],d[p]),t[p]=d[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> f=fa[u],ff=fa[f],d=son[f][<span class="number">1</span>]==u;</span><br><span class="line">	fa[u]=ff; <span class="keyword">if</span>(ff) son[ff][son[ff][<span class="number">1</span>]==f]=u;</span><br><span class="line">	son[f][d]=son[u][!d]; <span class="keyword">if</span>(son[u][!d]) fa[son[u][!d]]=f;</span><br><span class="line">	son[u][!d]=f,fa[f]=u;</span><br><span class="line">	<span class="built_in">Up</span>(f),<span class="built_in">Up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> v=++n;</span><br><span class="line">	val[v]=s[v]=x,sz[v]=<span class="number">1</span>,st[v]=<span class="number">-1</span>,key[v]=<span class="built_in">rand</span>();</span><br><span class="line">	<span class="keyword">if</span>(!rt)&#123; rt=v; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="type">int</span> u=rt;</span><br><span class="line">	<span class="keyword">while</span>(u) &#123;</span><br><span class="line">		<span class="built_in">Down</span>(u);</span><br><span class="line">		<span class="keyword">if</span>(sz[son[u][<span class="number">0</span>]]&gt;=p) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!son[u][<span class="number">0</span>]) &#123; son[fa[v]=u][<span class="number">0</span>]=v; <span class="keyword">break</span>; &#125;</span><br><span class="line">			u=son[u][<span class="number">0</span>]; </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			p-=sz[son[u][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!son[u][<span class="number">1</span>]) &#123; son[fa[v]=u][<span class="number">1</span>]=v; <span class="keyword">break</span>; &#125;</span><br><span class="line">			u=son[u][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(fa[v] &amp;&amp; key[v]&lt;key[fa[v]]) <span class="built_in">rotate</span>(v);</span><br><span class="line">	<span class="keyword">if</span>(!fa[v]) rt=v;</span><br><span class="line">	<span class="keyword">while</span>(fa[v]) <span class="built_in">Up</span>(v=fa[v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p || r&lt;=<span class="number">0</span> || l&gt;sz[p]) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=<span class="number">1</span> &amp;&amp; r&gt;=sz[p]) <span class="keyword">return</span> <span class="built_in">Set</span>(p,x);</span><br><span class="line">	<span class="type">int</span> t=sz[son[p][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Down</span>(p),<span class="built_in">Set</span>(son[p][<span class="number">0</span>],l,r,x),<span class="built_in">Set</span>(son[p][<span class="number">1</span>],l-t,r-t,x);</span><br><span class="line">	<span class="keyword">if</span>(t&gt;=l &amp;&amp; t&lt;=r) val[p]=x;</span><br><span class="line">	<span class="built_in">Up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,ll x,ll d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p || r&lt;=<span class="number">0</span> || l&gt;sz[p]) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=<span class="number">1</span> &amp;&amp; r&gt;=sz[p]) <span class="keyword">return</span> <span class="built_in">Add</span>(p,x,d);</span><br><span class="line">	<span class="type">int</span> t=sz[son[p][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Down</span>(p),<span class="built_in">Add</span>(son[p][<span class="number">0</span>],l,r,x,d),<span class="built_in">Add</span>(son[p][<span class="number">1</span>],l-t,r-t,x+d*t,d);</span><br><span class="line">	<span class="keyword">if</span>(t&gt;=l &amp;&amp; t&lt;=r) val[p]+=(t<span class="number">-1</span>)*d+x;</span><br><span class="line">	<span class="built_in">Up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Que</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p || r&lt;=<span class="number">0</span> || l&gt;sz[p]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=<span class="number">1</span> &amp;&amp; r&gt;=sz[p]) <span class="keyword">return</span> s[p];</span><br><span class="line">	ll t=sz[son[p][<span class="number">0</span>]]+<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">Down</span>(p),res+=<span class="built_in">Que</span>(son[p][<span class="number">0</span>],l,r),res+=<span class="built_in">Que</span>(son[p][<span class="number">1</span>],l-t,r-t);</span><br><span class="line">	<span class="keyword">if</span>(t&gt;=l &amp;&amp; t&lt;=r) res+=val[p];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="built_in">Insert</span>(i,<span class="built_in">rd</span>());</span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> opt=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> l=<span class="built_in">rd</span>(),r=<span class="built_in">rd</span>();</span><br><span class="line">			<span class="built_in">Set</span>(rt,l,r,<span class="built_in">rd</span>());</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="type">int</span> l=<span class="built_in">rd</span>(),r=<span class="built_in">rd</span>(),x=<span class="built_in">rd</span>();</span><br><span class="line">			<span class="built_in">Add</span>(rt,l,r,x<span class="number">-1ll</span>*(l<span class="number">-1</span>)*x,x);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">3</span>) &#123;</span><br><span class="line">			<span class="type">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>();</span><br><span class="line">			<span class="built_in">Insert</span>(x<span class="number">-1</span>,y);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> l=<span class="built_in">rd</span>(),r=<span class="built_in">rd</span>();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">Que</span>(rt,l,r));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>非旋Treap:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())&lt;<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">do</span> s=s*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())&gt;<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span>&#123;N=<span class="number">200010</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m,rt,ls[N],rs[N],key[N];</span><br><span class="line">ll s[N],t[N],d[N],st[N],val[N],sz[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Up</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    s[p]=s[ls[p]]+s[rs[p]]+val[p];</span><br><span class="line">    sz[p]=sz[ls[p]]+sz[rs[p]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">int</span> p,ll x)</span></span>&#123; t[p]=d[p]=<span class="number">0</span>,st[p]=val[p]=x,s[p]=sz[p]*x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> p,ll x,ll d)</span> </span>&#123;</span><br><span class="line">    val[p]+=x+d*sz[ls[p]];</span><br><span class="line">    s[p]+=sz[p]*(sz[p]<span class="number">-1</span>)/<span class="number">2</span>*d+x*sz[p];</span><br><span class="line">    t[p]+=x,::d[p]+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Down</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    ~st[p] &amp;&amp; (<span class="built_in">Set</span>(ls[p],st[p]),<span class="built_in">Set</span>(rs[p],st[p]),st[p]=<span class="number">-1</span>);</span><br><span class="line">    (t[p] || d[p]) &amp;&amp; (<span class="built_in">Add</span>(ls[p],t[p],d[p]),<span class="built_in">Add</span>(rs[p],t[p]+(sz[ls[p]]+<span class="number">1</span>)*d[p],d[p]),t[p]=d[p]=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">return</span> key[x]&lt;key[y]?(<span class="built_in">Down</span>(x),rs[x]=<span class="built_in">Union</span>(rs[x],y),<span class="built_in">Up</span>(x),x):(<span class="built_in">Down</span>(y),ls[y]=<span class="built_in">Union</span>(x,ls[y]),<span class="built_in">Up</span>(y),y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Pii <span class="title">Split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sz[x]&lt;=d) <span class="keyword">return</span> <span class="built_in">mp</span>(x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(d==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">0</span>,x);</span><br><span class="line">    <span class="built_in">Down</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(sz[ls[x]]+<span class="number">1</span>&lt;=d) &#123;</span><br><span class="line">        Pii y=<span class="built_in">Split</span>(rs[x],d-sz[ls[x]]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> rs[x]=y.first,<span class="built_in">Up</span>(x),<span class="built_in">mp</span>(x,y.second);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Pii y=<span class="built_in">Split</span>(ls[x],d);</span><br><span class="line">        <span class="keyword">return</span> ls[x]=y.second,<span class="built_in">Up</span>(x),<span class="built_in">mp</span>(y.first,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;++i) key[i]=<span class="built_in">rand</span>(),st[i]=<span class="number">-1</span>,sz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) val[i]=s[i]=<span class="built_in">rd</span>(),rt=<span class="built_in">Union</span>(rt,i);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> opt=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">3</span>) &#123;</span><br><span class="line">            Pii t=<span class="built_in">Split</span>(rt,<span class="built_in">rd</span>()<span class="number">-1</span>); ++n,val[n]=s[n]=<span class="built_in">rd</span>();</span><br><span class="line">            rt=<span class="built_in">Union</span>(<span class="built_in">Union</span>(t.first,n),t.second);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="built_in">rd</span>(),r=<span class="built_in">rd</span>();</span><br><span class="line">            Pii a=<span class="built_in">Split</span>(rt,l<span class="number">-1</span>),b=<span class="built_in">Split</span>(a.second,r-l+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(opt==<span class="number">1</span>) <span class="built_in">Set</span>(b.first,<span class="built_in">rd</span>());</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>) &#123;<span class="type">int</span> x=<span class="built_in">rd</span>(); <span class="built_in">Add</span>(b.first,x,x); &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,s[b.first]);</span><br><span class="line">            rt=<span class="built_in">Union</span>(<span class="built_in">Union</span>(a.first,b.first),b.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/6847%20Decision%20/</url>
    <content><![CDATA[<hr />
<p>title: '[HDU-6847] Decision (2020多校7T4) (类欧几里得问题)' date:
'Sat Aug 12 11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="hdu-6847-decision-2020多校7t4-类欧几里得问题">[HDU-6847]
Decision (2020多校7T4) (类欧几里得问题)</h1>
<p>枚举 <span class="math inline">\(|v_1-v_2|\)</span>
后，可以递推，用含首项( <span class="math inline">\(v_1+v_2\)</span>
)的一次函数表示函数值为 <span
class="math inline">\(a(v_1+v_2)+b\)</span> ，则问题等价于求</p>
<p><span class="math inline">\(\begin{aligned} \sum_{i=0}^n
[2|(ai+b)\mod m] \end{aligned}\)</span> ，其中 <span
class="math inline">\(n\)</span> 对于每个 <span
class="math inline">\(v_1-v_2\)</span> 是不同的</p>
<p>这个问题，可以转化为一个简单的类欧几里得问题</p>
<p><span class="math inline">\((ai+b)\mod m \mod 2= ((ai+b)-(m\mod
2)\cdot \lfloor \frac{ai+b}{m}\rfloor )\mod 2\)</span></p>
<p>这个式子即把每次被 <span class="math inline">\(m\)</span> 取模减少的
<span class="math inline">\(m\)</span> 算进贡献</p>
<p>可以看到操作非常简单，可以直接套上万能欧几里得的板子</p>
<p>当然，也可以对于 <span class="math inline">\(m\)</span>
的各种情况讨论，转化为求 <span class="math inline">\(\lfloor
\frac{ai+b}{m}\rfloor\)</span> ，其主要思想还有应用 <span
class="math inline">\(x\mod 2=x-2\cdot \lfloor
\frac{x}{2}\rfloor\)</span> 的转化</p>
<p>我比赛时去抄了自己的类欧几里得模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">    T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t,a,c,m;</span><br><span class="line"><span class="type">int</span> fx[N],fy[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123; <span class="keyword">return</span> b==<span class="number">0</span>?a:<span class="built_in">gcd</span>(b,a%b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">D2</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">F</span><span class="params">(ll a,ll b,ll c,ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> (b/c)*(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=c || b&gt;=c) &#123;</span><br><span class="line">        ll ans=<span class="built_in">F</span>(a%c,b%c,c,n)+<span class="built_in">D2</span>(n)*(a/c)+(n+<span class="number">1</span>)*(b/c);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    ll t=(a*n+b)/c;</span><br><span class="line">    ll ans=t*n-<span class="built_in">F</span>(c,-b+c<span class="number">-1</span>,a,t<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">CalcMod</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> m,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">F</span>(a,b,m,n)-<span class="built_in">F</span>(a,b,m*<span class="number">2</span>,n)*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Calc</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// for i= [l,r] (ax+b) %m %2</span></span><br><span class="line">    <span class="keyword">if</span>(~m&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// (ax+b)%2;</span></span><br><span class="line">        a%=<span class="number">2</span>,b%=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> b*(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (n+<span class="number">1</span>+b)/<span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// (ax+b) %m %2 = ((ax+b)/m + ax+b)%2</span></span><br><span class="line">        <span class="type">int</span> c=a%<span class="number">2</span>,d=b%<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// =((ax+b)/m+b)%2;</span></span><br><span class="line">            <span class="keyword">if</span>(d==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">CalcMod</span>(a,b,m,n);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">return</span> (n+<span class="number">1</span>)-<span class="built_in">CalcMod</span>(a,b,m,n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// (ax+b) %m %2 = ((ax+b)/m + (x&amp;1)+d)%2</span></span><br><span class="line">            ll ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i%2 == 0</span></span><br><span class="line">            ll t=<span class="built_in">CalcMod</span>(a*<span class="number">2</span>,b,m,n/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(d) t=n/<span class="number">2</span>+<span class="number">1</span>-t;</span><br><span class="line">            ans+=t;</span><br><span class="line"></span><br><span class="line">            b+=a;</span><br><span class="line">            <span class="comment">// i%2 == 1</span></span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">            t=<span class="built_in">CalcMod</span>(a*<span class="number">2</span>,b,m,n/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(!d) t=n/<span class="number">2</span>+<span class="number">1</span>-t;</span><br><span class="line">            ans+=t;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">        t=<span class="built_in">rd</span>(),a=<span class="built_in">rd</span>(),c=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">        fx[<span class="number">0</span>]=<span class="number">1</span>,fy[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,t) fx[i]=<span class="number">1ll</span>*fx[i<span class="number">-1</span>]*a%m,fy[i]=(<span class="number">1ll</span>*fy[i<span class="number">-1</span>]*a+c)%m;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,t) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">                ans+=<span class="built_in">Calc</span>(fx[i]*<span class="number">2</span>%m,fy[i],t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a&lt;b, b - a = i</span></span><br><span class="line">                <span class="comment">// a=[0,m-i]</span></span><br><span class="line">                <span class="comment">// b=[i,m]</span></span><br><span class="line">                ll tmp=(<span class="number">1ll</span>*i*fx[i]+fy[i])%m;</span><br><span class="line">                ans+=<span class="built_in">Calc</span>(fx[i]*<span class="number">2</span>%m,tmp,t-i)*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll tmp=<span class="number">1ll</span>*(t+<span class="number">1</span>)*(t+<span class="number">1</span>);</span><br><span class="line">        ans=tmp-ans;</span><br><span class="line">        ll g=<span class="built_in">gcd</span>(tmp,ans);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>,ans/g,tmp/g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/6848%20Expectation/</url>
    <content><![CDATA[<hr />
<p>title: '[HDU-6848] Expectation (2020多校7T5) (dp)' date: 'Sat Aug 12
11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="hdu-6848-expectation-2020多校7t5-dp">[HDU-6848] Expectation
(2020多校7T5) (dp)</h1>
<p><del>比赛时疯狂脑抽写了3个小时祭</del></p>
<p>考虑计算每条 <span class="math inline">\(x_i\rightarrow
x_{i+1}\)</span> 的边被在所有情况下被经过的次数总和</p>
<p>令 <span class="math inline">\(dp[i][j]\)</span> 为有 <span
class="math inline">\(i\)</span> 个球时， <span
class="math inline">\(x_j\rightarrow x_{j+1}\)</span>
这段被经过的次数总和( <span class="math inline">\(j\leq 2i\)</span>
)</p>
<p>考虑转移，对于 <span class="math inline">\(dp[i]\)</span>
，枚举每个球向左或者右走，发现把两边的部分拉拢过来后，合并形成一条包含了原先
<span class="math inline">\(3\)</span> 条边的新边，变成了 <span
class="math inline">\(i-1\)</span> 阶的子问题</p>
<p>画图理解，发现 <span class="math inline">\(j\)</span> 这条边，在
<span class="math inline">\(i-1\)</span> 阶的子问题上对应的编号只可能是
<span class="math inline">\(j,j-1,j-2\)</span></p>
<p>视选择了 <span class="math inline">\(j\)</span>
这条边为将边一端的球滚进另一端的洞里</p>
<p>那么对于任意一条编号为 <span class="math inline">\(j\)</span>
的边</p>
<p><span class="math inline">\(j\)</span> 变为编号为 <span
class="math inline">\(j-2\)</span> 的情况为选择了编号 <span
class="math inline">\([1,j-1]\)</span> 范围内的边</p>
<p><span class="math inline">\(j\)</span> 变为编号为 <span
class="math inline">\(j-1\)</span> 的情况为选择了编号为 <span
class="math inline">\(j\)</span> 的边</p>
<p><span class="math inline">\(j\)</span> 变为编号为 <span
class="math inline">\(j\)</span> 的情况为选择了编号为 <span
class="math inline">\([j+1,2i]\)</span> 的边</p>
<p>对于 <span class="math inline">\(j\)</span>
在子问题中被访问的次数可以直接 <span class="math inline">\(O(1)\)</span>
继承过来</p>
<p>同时，考虑当第一次就选了 <span class="math inline">\(j\)</span>
时，后面的操作随意，即加上 <span class="math inline">\((i-1)!\cdot
2^{i-1}\)</span></p>
<p>于是得到一个 <span class="math inline">\(O(n^2)\)</span> 的 <span
class="math inline">\(dp\)</span> 预处理</p>
<p>而对于每个询问，求解 <span class="math inline">\(n\)</span>
阶的答案复杂度为 <span class="math inline">\(O(n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">    T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3010</span>,P=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> dp[N][N*<span class="number">2</span>],Fac[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,Fac[<span class="number">0</span>]=<span class="number">1</span>,N<span class="number">-1</span>) Fac[i]=<span class="number">1ll</span>*i*Fac[i<span class="number">-1</span>]%P;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>]=dp[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-1</span>) &#123;</span><br><span class="line">        t=<span class="number">1ll</span>*t*(i<span class="number">-1</span>)*<span class="number">2</span>%P;</span><br><span class="line">        <span class="built_in">rep</span>(j,<span class="number">1</span>,i*<span class="number">2</span>) &#123;</span><br><span class="line">            dp[i][j]=(<span class="number">1ll</span>*(i*<span class="number">2</span>-j)*dp[i<span class="number">-1</span>][j]+<span class="number">1ll</span>*dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1ll</span>*(j<span class="number">-1</span>)*(j&gt;=<span class="number">2</span>?dp[i<span class="number">-1</span>][j<span class="number">-2</span>]:<span class="number">0</span>)+t)%P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">        n=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>,x=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> y=<span class="built_in">rd</span>();</span><br><span class="line">            ans=(ans+<span class="number">1ll</span>*(y-x)*dp[n][i])%P;</span><br><span class="line">            x=y;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=ans*<span class="built_in">qpow</span>((P+<span class="number">1</span>)/<span class="number">2</span>,n)%P*<span class="built_in">qpow</span>(Fac[n])%P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/6854%20Kcats/</url>
    <content><![CDATA[<hr />
<p>title: '[HDU-6854] Kcats (2020多校7 T11) (笛卡尔树+区间dp)' date:
'Sat Aug 12 11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="hdu-6854-kcats-2020多校7-t11-笛卡尔树区间dp">[HDU-6854] Kcats
(2020多校7 T11) (笛卡尔树+区间dp)</h1>
<p>前缀 <span class="math inline">\(p_1,p_2,\cdots,p_i\)</span>
的单调栈大小，即 <span class="math inline">\(i\)</span>
号节点在全局的笛卡尔树上对应的位置的所有在左边的祖先个数</p>
<p>因此，区间 <span class="math inline">\(dp\)</span>
笛卡尔树的树形，合并时，为了满足题目的限制，只需要记录左边的祖先个数
<span class="math inline">\(d\)</span></p>
<p>即定义 <span class="math inline">\(dp[l][r][d]\)</span> 为区间 <span
class="math inline">\(l,r\)</span>
对应笛卡尔树子树，且根节点左祖先个数为 <span
class="math inline">\(d\)</span> 的方案数</p>
<p>合并两个子树时注意补上组合数，且自己这个点对于左儿子深度没有贡献</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">    T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">10</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[N],C[N][N],dp[N][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,N<span class="number">-1</span>) <span class="built_in">rep</span>(j,C[i][<span class="number">0</span>]=<span class="number">1</span>,i) C[i][j]=(C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j])%P;</span><br><span class="line">    <span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n=<span class="built_in">rd</span>()) a[i]=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">drep</span>(i,n,<span class="number">1</span>) <span class="built_in">rep</span>(j,i,n) <span class="built_in">rep</span>(k,i,j) </span><br><span class="line">            <span class="built_in">rep</span>(d,~a[k]?a[k]:<span class="number">1</span>,~a[k]?a[k]:n) </span><br><span class="line">                dp[i][j][d]=(dp[i][j][d]+<span class="number">1ll</span>*(i&lt;k?dp[i][k<span class="number">-1</span>][d]:<span class="number">1</span>)*(k&lt;j?dp[k+<span class="number">1</span>][j][d+<span class="number">1</span>]:<span class="number">1</span>)%P*C[j-i][k-i])%P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[<span class="number">1</span>][n][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/6883/</url>
    <content><![CDATA[<hr />
<p>title: '[HDU-6883] Coin Game(2020HDU多校第十场T7)' date: 'Sat Aug 12
11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="hdu-6883-coin-game2020hdu多校第十场t7">[HDU-6883] Coin
Game(2020HDU多校第十场T7)</h1>
<p>题目给出的模型看起来比较奇怪，但是简单推理后，发现可以转化为一个简单的01背包问题</p>
<p>对于题目给定的权值 <span class="math inline">\(a_i,b_i\)</span>
，分为 <span class="math inline">\(a_i,a_i+b_i\)</span>
两个物品，发现可以得到这个机器的所有合法贡献情况</p>
<p>也就是说，有两种大小分别为 <span class="math inline">\(1,2\)</span>
的物品，要做01背包</p>
<p>这个刚刚在<a
href="https://www.cnblogs.com/chasedeath/p/13460468.html">WC2020</a>考过。。。</p>
<p>设两类转化后的权值分别为 <span class="math inline">\(a_i,b_i\)</span>
，则转移过程可以简单描述为</p>
<p>1.将两类权值分别从大到小排序</p>
<p>2.将dp值转化为在两个序列中分别选取一段前缀和</p>
<p>3.转移时枚举下一次决策的选取是那种物品，选取最优一个，记录指针转移即可</p>
<p>主要复杂度可能还在于排序，Trick:有一点卡内存</p>
<p>但是实测桶排和直接sort好像差距不大。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e6</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line">ull k1,k2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Shift</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ull k3=k1,k4=k2;</span><br><span class="line">    k1=k4;</span><br><span class="line">    k3^=k3&lt;&lt;<span class="number">23</span>;</span><br><span class="line">    k2=k3^k4^(k3&gt;&gt;<span class="number">17</span>)^(k4&gt;&gt;<span class="number">26</span>);</span><br><span class="line">    <span class="keyword">return</span> (k2+k4)%<span class="number">10000000</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> A[N*<span class="number">3</span>],B[N*<span class="number">3</span>]; <span class="comment">// 记录在两个序列中的指针</span></span><br><span class="line">ll dp[<span class="number">3</span>]; <span class="comment">// dp数组滚动了一下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%llu%llu&quot;</span>,&amp;n,&amp;m,&amp;k1,&amp;k2)) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">Shift</span>(),b[i]=<span class="built_in">Shift</span>()+a[i];</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()),<span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        A[<span class="number">0</span>]=B[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">2</span>) dp[i]=<span class="number">0</span>;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,m) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;=m &amp;&amp; A[i]&lt;=n) &#123;</span><br><span class="line">                <span class="type">int</span> nxt=(cur+<span class="number">1</span>)%<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[cur]+a[A[i]]&gt;dp[nxt]) dp[nxt]=dp[cur]+a[A[i]],A[i+<span class="number">1</span>]=A[i]+<span class="number">1</span>,B[i+<span class="number">1</span>]=B[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">2</span>&lt;=m &amp;&amp; B[i]&lt;=n) &#123;</span><br><span class="line">                <span class="type">int</span> nxt=(cur+<span class="number">2</span>)%<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[cur]+b[B[i]]&gt;dp[nxt]) dp[nxt]=dp[cur]+b[B[i]],A[i+<span class="number">2</span>]=A[i],B[i+<span class="number">2</span>]=B[i]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans^=dp[cur];</span><br><span class="line">            cur=(cur+<span class="number">1</span>)%<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/6833%20A%20Very%20Easy%20Math%20Problem/</url>
    <content><![CDATA[<hr />
<p>title: '[HDU - 6833] A Very Easy Math Problem (莫比乌斯反演)' date:
'Sat Aug 12 11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="hdu---6833-a-very-easy-math-problem-莫比乌斯反演">[HDU - 6833] A
Very Easy Math Problem (莫比乌斯反演)</h1>
<p>与 <span class="math inline">\(\gcd\)</span>
有关的问题，很容易想到莫比乌斯反演</p>
<p>设 <span class="math inline">\(G(a,n)=(\sum_{i=1}^{\lfloor
\frac{n}{a} \rfloor } (ai)^k)^x\)</span></p>
<p><span class="math inline">\(Ans=\sum_{g=1}^{n} g\cdot f(g)\cdot \sum
_{d=1}^{\lfloor\frac{n}{g}\rfloor} \mu(d) G(gd,n)\)</span></p>
<p>对于单组询问，显然可以 <span class="math inline">\(O(n\ln n)\)</span>
求解</p>
<p>考虑优化</p>
<p>可以在 <span class="math inline">\(O(n\ln n)\)</span>
的时间内，对于每个 <span class="math inline">\(i\)</span> ，求出 <span
class="math inline">\(F(i)=\sum_{d|i}\mu(d)\cdot \frac{i}{d}
f(\frac{i}{d})\)</span></p>
<p>对于 <span class="math inline">\(G(a,n)\)</span>
的求解，参数分离后发现 <span
class="math inline">\(G(a,n)=a^{kx}(\sum_{i=1}^{\lfloor \frac{n}{a}
\rfloor } i^k)^x\)</span></p>
<p>可以预处理出 <span class="math inline">\(S(n)=\sum_{i=1}^n
i^{kx}\cdot F(i)\)</span> 前缀和以及 <span
class="math inline">\(A(n)=(\sum_{i=1}^{n}i^k)^x\)</span> ，对于每个
<span class="math inline">\(\lfloor \frac{n}{a}\rfloor\)</span>
考虑即可</p>
<p>数论分段的复杂度为单组查询 <span class="math inline">\(O(\sqrt
n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">    T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T,n,k,x;</span><br><span class="line"><span class="type">int</span> mk[N],notpri[N],pri[N],pc,w[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll k=P<span class="number">-2</span>)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,x=x*x%P) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*x%P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s[N],F[N],S[N],A[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    w[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">2</span>,N<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!notpri[i]) pri[++pc]=i,w[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=pc &amp;&amp; <span class="number">1ll</span>*i*pri[j]&lt;N;++j) &#123;</span><br><span class="line">            notpri[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) &#123;</span><br><span class="line">                w[i*pri[j]]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            w[i*pri[j]]=-w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;N;++i) <span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;N;j+=i*i) mk[j]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) <span class="keyword">if</span>(!mk[i]) <span class="built_in">rep</span>(j,<span class="number">1</span>,(N<span class="number">-1</span>)/i) F[i*j]=(F[i*j]+i*w[j]+P)%P;</span><br><span class="line">    T=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>(),x=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) S[i]=(S[i<span class="number">-1</span>]+F[i]*<span class="built_in">qpow</span>(i,<span class="number">1ll</span>*k*x))%P;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) A[i]=(A[i<span class="number">-1</span>]+<span class="built_in">qpow</span>(i,k))%P;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) A[i]=<span class="built_in">qpow</span>(A[i],x);</span><br><span class="line">    <span class="built_in">rep</span>(kase,<span class="number">1</span>,T) &#123;</span><br><span class="line">        n=<span class="built_in">rd</span>();</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>) &#123;</span><br><span class="line">            j=n/(n/i);</span><br><span class="line">            ans=(ans+<span class="number">1ll</span>*(S[j]-S[i<span class="number">-1</span>])*A[n/i])%P;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans%P+P)%P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/6886%202020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%8D%81%E5%9C%BAT10/</url>
    <content><![CDATA[<hr />
<p>title: 'HDU-6886 Tic-Tac-Toe-Nim(2020HDU多校第十场T10)' date: 'Sat
Aug 12 11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="hdu-6886-tic-tac-toe-nim2020hdu多校第十场t10">HDU-6886
Tic-Tac-Toe-Nim(2020HDU多校第十场T10)</h1>
<p>正如题目名字，这是一个nim游戏</p>
<p>观察题目条件，前两次操作一定会清空两个位置，那么考虑后面得到的状态是否先手必胜即可</p>
<p>对于这两个位置，发现只有两种情况</p>
<h3 id="两个位置共线">两个位置共线</h3>
<p>此时先手者直接选择同线的另一个即可，必胜</p>
<h3 id="两个位置不共线">两个位置不共线</h3>
<p>此时还剩下一个位置与这两个空位均不共线，其他6个位置均共线</p>
<p>考虑可能存在的结束情况:</p>
<p>1.6个位置中有一个被清空，则下一个人直接清空共线的另一个位置必胜</p>
<p>2.不共线的位置被清空，不影响结局</p>
<p>考虑把这个问题转化为普通的Nim游戏</p>
<p>可以认为如果那6个位置均为1时游戏必败，而不共线的一个位置随意</p>
<p>则转化为 <strong>六个共线位置的值-1</strong> 与
<strong>不共线位置的值</strong>
形成的普通Nim游戏，根据常识，直接异或判断即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> IO,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Check</span><span class="params">()</span></span>&#123; <span class="comment">// 判断是否必胜</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">3</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">if</span>(a[i][j]) &#123;</span><br><span class="line">        <span class="type">int</span> fl=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(k,<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">if</span>(j!=k &amp;&amp; !a[i][k]) fl=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(k,<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">if</span>(k!=i &amp;&amp; !a[k][j]) fl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!fl) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> x=a[i][j],ans=<span class="number">0</span>;</span><br><span class="line">        a[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">3</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">if</span>(a[i][j]) ans^=a[i][j]<span class="number">-1</span>; <span class="comment">// 共线位置</span></span><br><span class="line">        ans^=x,a[i][j]=x; <span class="comment">// 不共线位置</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">3</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,<span class="number">3</span>) a[i][j]=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">3</span>) <span class="built_in">rep</span>(j,<span class="number">1</span>,<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> t=a[i][j];</span><br><span class="line">            a[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> fl=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(x,<span class="number">1</span>,<span class="number">3</span>) <span class="built_in">rep</span>(y,<span class="number">1</span>,<span class="number">3</span>) &#123; <span class="comment">// 枚举两次初始操作，注意两次操作不共线!</span></span><br><span class="line">                <span class="keyword">if</span>(x==i || y==j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> t=a[x][y];</span><br><span class="line">                a[x][y]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">Check</span>()) fl=<span class="number">1</span>;</span><br><span class="line">                a[x][y]=t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!fl) ans++;</span><br><span class="line">            a[i][j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/HDU/6834%20Yukikaze%20and%20Smooth%20numbers/</url>
    <content><![CDATA[<hr />
<p>title: '[HDU-6834] Yukikaze and Smooth numbers' date: 'Sat Aug 12
11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="hdu-6834-yukikaze-and-smooth-numbers">[HDU-6834] Yukikaze and
Smooth numbers</h1>
<p>题意：计算 <span class="math inline">\([1,n]\)</span> 中只包含 <span
class="math inline">\([1,k]\)</span> 的质因数的数个数</p>
<p>让人联想到Min25筛的 <span class="math inline">\(dp\)</span> 模型</p>
<p>设 <span class="math inline">\(m=\sqrt n\)</span> ，可以对于 <span
class="math inline">\(k &gt; m\)</span> 和 <span
class="math inline">\(k\leq m\)</span> 讨论</p>
<h2 id="case1-kleq-m">Case1: <span class="math inline">\(k\leq
m\)</span></h2>
<p>此时可以直接套用类似Min25筛的 <span class="math inline">\(dp\)</span>
模型求解</p>
<p>令 <span class="math inline">\(dp_{i,j}\)</span> 为 <span
class="math inline">\([1,j]\)</span> 只包含 <span
class="math inline">\([1,i]\)</span> 的质因数的数个数</p>
<p>则 <span class="math inline">\(dp_{i,j}=\sum_k dp_{i-1,\lfloor
\frac{j}{prime_i^k}\rfloor }\)</span></p>
<p>要求的是 <span class="math inline">\(dp_{k,n}\)</span> ，第二维状态是
<span class="math inline">\(O(m)\)</span> 级别的</p>
<p>直接写当然是近似于 <span class="math inline">\(O(m\cdot
\pi(n))=O(\frac{n}{\log n})\)</span> 级别的</p>
<p>加上Min25筛的优化，令 <span class="math inline">\(dp_i,j\)</span>
不包含单质数和1的情况，以减少转移情况</p>
<p>如果从大到小考虑每个质数，那么只需要考虑 <span
class="math inline">\(j\ge prime_i^2\)</span> 的第二维状态，以减少很多的
<span class="math inline">\(dp\)</span> 时间</p>
<p>沿用Min25筛复杂度证明，是 <span
class="math inline">\(O(\frac{n^{\frac{3}{4}}}{\log n})\)</span> 的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> id(x) (x&lt;=m?x:cnt-n/x+1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[N],g[N],st[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)&#123; <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">m=<span class="built_in">sqrt</span>(n),cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n) st[++cnt]=i=n/(n/i),dp[cnt]=<span class="number">0</span>; <span class="comment">// 不包括质数本身和1</span></span><br><span class="line"><span class="type">int</span> sz=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(pri[sz+<span class="number">1</span>]&lt;=k) sz++;</span><br><span class="line"><span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,cnt)&#123;</span><br><span class="line">    <span class="keyword">while</span>(p&lt;sz &amp;&amp; pri[p+<span class="number">1</span>]&lt;=st[i]) p++;</span><br><span class="line">    g[i]=p;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,cnt) <span class="keyword">for</span>(ll x=pri[sz]*pri[sz];x&lt;=st[i];x*=pri[sz]) dp[i]++;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="type">int</span> i=sz<span class="number">-1</span>;i;--i) &#123;</span><br><span class="line">    <span class="keyword">for</span>(reg <span class="type">int</span> j=cnt,tmp=pri[i]*pri[i];st[j]&gt;=tmp;--j) &#123;</span><br><span class="line">        reg <span class="type">int</span> x=st[j];</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=tmp) &#123;</span><br><span class="line">            x/=pri[i];</span><br><span class="line">            dp[j]+=dp[<span class="built_in">id</span>(x)]+g[<span class="built_in">id</span>(x)]-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[cnt]+sz+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[\ \]</span></p>
<h2 id="case2-k-m">Case2 : <span class="math inline">\(k&gt;
m\)</span></h2>
<p>可以把问题转化为求不合法部分，即 <span
class="math inline">\(\sum_{prime_i&gt;k}\lfloor
\frac{n}{prime_i}\rfloor\)</span></p>
<p>采用数论分段计算 <span class="math inline">\(\lfloor
\frac{n}{i}\rfloor\)</span>
，那么剩下的问题就是要求一段区间内的质数个数</p>
<p>同样采用类似上面的模型，</p>
<p>令 <span class="math inline">\(dp_{i,j}\)</span> 为 <span
class="math inline">\([1,j]\)</span> 内与前 <span
class="math inline">\([1,i]\)</span>
内质数互质的个数以及这些质数本身，不包括1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dp[N],g[N],st[N],cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> id(x) (x&lt;=m?x:cnt-n/x+1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Count</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;N) <span class="keyword">return</span> pcount[n];</span><br><span class="line">    ::n=n,m=<span class="built_in">sqrt</span>(n),cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) st[++cnt]=i=n/(n/i),dp[cnt]=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(reg <span class="type">int</span> i=<span class="number">1</span>;pri[i]&lt;=m;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(reg <span class="type">int</span> j=cnt,tmp=pri[i]*pri[i];st[j]&gt;=tmp;--j) &#123;</span><br><span class="line">            reg <span class="type">int</span> k=st[j]/pri[i];</span><br><span class="line">            dp[j]-=dp[<span class="built_in">id</span>(k)]-(i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cnt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体复杂度没有算过，应该不会太高</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/JOI,JOISC/%E3%80%8CJOI%202020%20Final%E3%80%8D%E5%A5%A5%E8%BF%90%E5%85%AC%E4%BA%A4%20/</url>
    <content><![CDATA[<hr />
<p>title: '「JOI 2020 Final」奥运公交 (最短路)' date: 'Sat Aug 12
11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="joi-2020-final奥运公交-最短路">「JOI 2020 Final」奥运公交
(最短路)</h1>
<p>问题实际上就是要分别求 <span class="math inline">\(1-n\)</span> 和
<span class="math inline">\(n-1\)</span>
对于每一条边翻转之后的最短路</p>
<p>由于 <span class="math inline">\(m\)</span> 的上限为 <span
class="math inline">\(n^2\)</span> ，下面所说的 <span
class="math inline">\(\text{Dijkstra}\)</span> 都是没有堆优化的板本，即
<span class="math inline">\(n^2\)</span> 找最小点， <span
class="math inline">\(m\)</span> 更新</p>
<p>以计算 <span class="math inline">\(1-n\)</span> 为例</p>
<p>不妨先考虑计算删除每一条边 <span
class="math inline">\((u,v,c)\)</span> 之后，1为源点的的最短路情况</p>
<p>我们知道从源点 <span class="math inline">\(S\)</span>
出发的最短路可以用最短路图描述，而最短路图是一张拓扑图（fix:这道题含有0边，所以并不是，但是没有关系）</p>
<p>如果从最短路图中提取一棵树，那么显然只有这些树边需要考虑删除之后对于最短路的影响</p>
<p>对于这些边重新求最短路即可，复杂度为 <span
class="math inline">\(O(n(m+n^2))\)</span></p>
<p>如何考虑翻转一条边之后的贡献？</p>
<p>不妨再求出以 <span class="math inline">\(n\)</span>
为结束的最短路，即求反图 <span class="math inline">\(n\)</span>
为源点的答案</p>
<p>然后在两个最短路上查询一下即可得到 <span
class="math inline">\(1-n\)</span> 的最短路</p>
<p>同理得到 <span class="math inline">\(n-1\)</span> 的答案</p>
<p>复杂度为 <span class="math inline">\(O(n(m+n^2))\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T&amp; a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T&amp; a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) f|=IO==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Mbe;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">210</span>,M=<span class="number">5e4</span>+<span class="number">10</span>,INF=<span class="number">2e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> E[N][N],E2[N][N],EI[N][N],dis[N],vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n) dis[i]=INF,vis[i]=<span class="number">0</span>;</span><br><span class="line">	dis[S]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!vis[i] &amp;&amp; dis[i]&lt;dis[u]) u=i;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">break</span>;</span><br><span class="line">		vis[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(E[u][i]&lt;INF) <span class="built_in">cmin</span>(dis[i],dis[u]+E[u][i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> U[M],V[M],C[M],D[M];</span><br><span class="line"><span class="type">int</span> mk[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!vis[i] &amp;&amp; E[u][i]&lt;INF &amp;&amp; dis[i]==dis[u]+E[u][i]) mk[EI[u][i]]=<span class="number">1</span>,<span class="built_in">dfs</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Res1[M][N],Res2[M][N];</span><br><span class="line">ll Ans[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> S,<span class="type">int</span> Res[M][N])</span></span>&#123; </span><br><span class="line">    <span class="comment">// 计算删除每条边之后，S为源点的最短路情况，放在Res[M][N]中</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) E[i][j]=INF,E2[i][j]=INF;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="type">int</span> u=U[i],v=V[i],c=C[i];</span><br><span class="line">		<span class="keyword">if</span>(E[u][v]&gt;c) E2[u][v]=E[u][v],E[u][v]=c,EI[u][v]=i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(E2[u][v]&gt;c) E2[u][v]=c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Dijkstra</span>(S);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) vis[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) mk[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(S);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>(!mk[i]) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) Res[i][j]=dis[j];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>(mk[i]) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(E[U[i]][V[i]],E2[U[i]][V[i]]);</span><br><span class="line">		<span class="built_in">Dijkstra</span>(S);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,n) Res[i][j]=dis[j];</span><br><span class="line">		<span class="built_in">swap</span>(E[U[i]][V[i]],E2[U[i]][V[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="built_in">Solve</span>(<span class="number">1</span>,Res1);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">swap</span>(U[i],V[i]);</span><br><span class="line">    <span class="comment">// 反图计算</span></span><br><span class="line">	<span class="built_in">Solve</span>(n,Res2);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">swap</span>(U[i],V[i]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="type">int</span> t=<span class="built_in">min</span>(Res1[i][n],Res2[i][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(Res1[i][V[i]]&lt;INF &amp;&amp; Res2[i][U[i]]&lt;INF) <span class="built_in">cmin</span>(t,Res1[i][V[i]]+Res2[i][U[i]]+C[i]);</span><br><span class="line">		Ans[i]+=t; <span class="comment">// 合并贡献</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Med;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="comment">//fprintf(stderr,&quot;%.2lf\n&quot;,(&amp;Med-&amp;Mbe)/1024.0/1024.0);</span></span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) U[i]=<span class="built_in">rd</span>(),V[i]=<span class="built_in">rd</span>(),C[i]=<span class="built_in">rd</span>(),D[i]=<span class="built_in">rd</span>();</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) E[i][j]=INF;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">cmin</span>(E[U[i]][V[i]],C[i]);</span><br><span class="line">	<span class="built_in">Dijkstra</span>(<span class="number">1</span>),ans+=dis[n];</span><br><span class="line">	<span class="built_in">Dijkstra</span>(n),ans+=dis[<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 计算1-n</span></span><br><span class="line">	<span class="built_in">Solve</span>();</span><br><span class="line">    <span class="comment">// 计算n-1</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) U[i]=n-U[i]+<span class="number">1</span>,V[i]=n-V[i]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Solve</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">cmin</span>(ans,Ans[i]+D[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans&gt;=INF?<span class="number">-1</span>:ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/JOI,JOISC/%E3%80%8CJOI%202018%20Final%E3%80%8D%E6%AF%92%E8%9B%87%E8%B6%8A%E7%8B%B1%20/</url>
    <content><![CDATA[<hr />
<p>title: '「JOI 2018 Final」毒蛇越狱' date: 'Sat Aug 12 11:05:26 2023
categories: - oi-solutions'</p>
<h1 id="joi-2018-final毒蛇越狱">「JOI 2018 Final」毒蛇越狱</h1>
<h3 id="algorithm-1-暴力计算">Algorithm 1: 暴力计算</h3>
<p>对于所有 <span class="math inline">\(0,1,?\)</span> 组成的 <span
class="math inline">\(3^n\)</span> 种串处理出答案</p>
<p>具体的，对于当前串包含的最后一个 <span
class="math inline">\(?\)</span>
位置，枚举它变成0/1的答案，按照一定的顺序累和即可</p>
<p>(代码可以在Algo2里面看到)</p>
<h3 id="algorithm-2-meet-in-the-middle">Algorithm 2 : Meet in the
Middle</h3>
<p><span class="math inline">\(3^{20}\)</span>
太大，优化上面的暴力，容易想到把复杂度从预处理分一部分给查询</p>
<p>取出 <span class="math inline">\(n\)</span> 中前 <span
class="math inline">\(k\)</span> 个位置，这些位置不处理 <span
class="math inline">\(3^k\)</span>
，而是让每个询问暴力地去枚举这些位置上的 <span
class="math inline">\(?\)</span> 变成 <span
class="math inline">\(0/1\)</span></p>
<p>显然每个询问有最多 <span class="math inline">\(2^k\)</span>
次枚举，即复杂度为 <span class="math inline">\(O(Q\cdot
2^k)\)</span></p>
<p>对于剩下的 <span class="math inline">\(n-k\)</span>
个位置，采取上面的暴力方法预处理，三进制枚举，预处理复杂度为 <span
class="math inline">\(O(2^k3^{n-k})\)</span></p>
<p>因此复杂度为 <span class="math inline">\(O(Q\cdot 2^k
+2^k3^{n-k})\)</span> ，计算在 <span
class="math inline">\(k=6,7\)</span> 时复杂度约为 <span
class="math inline">\(3.5\cdot 10^8\)</span></p>
<p><del>(这是一个非常稳的复杂度)</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function">ll <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll s=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) <span class="keyword">if</span>(IO==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">20</span>,M3=<span class="number">1600000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DM=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> Pow[N],S[M3],Low[M3],trans[M3];</span><br><span class="line"><span class="type">int</span> QX[M],QY[M],QZ[M],Ans[M],rev[M];</span><br><span class="line"><span class="type">char</span> val[M],q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">rep</span>(i,Pow[<span class="number">0</span>]=<span class="number">1</span>,N<span class="number">-1</span>) Pow[i]=Pow[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),k=<span class="built_in">min</span>(DM,n),<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,val);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>) &#123;</span><br><span class="line">		rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(n<span class="number">-1</span>));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(val[i],val[rev[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	Low[<span class="number">0</span>]=<span class="number">1e9</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,Pow[n-k]<span class="number">-1</span>) &#123;</span><br><span class="line">		Low[i]=(i%<span class="number">3</span>==<span class="number">2</span>)?<span class="number">0</span>:Low[i/<span class="number">3</span>]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(Low[i]&gt;n) trans[i]=(trans[i/<span class="number">3</span>]&lt;&lt;<span class="number">1</span>)|(i%<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,q);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(q[j]==<span class="string">&#x27;?&#x27;</span>) QY[i]|=<span class="number">1</span>&lt;&lt;j,q[j]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> QX[i]|=(q[j]-<span class="string">&#x27;0&#x27;</span>)&lt;&lt;j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(j,k,n<span class="number">-1</span>) QZ[i]+=Pow[j-k]*(q[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> A=(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,A) &#123;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,Pow[n-k]<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Low[j]&gt;n) S[j]=val[(trans[j]&lt;&lt;k)|i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> S[j]=S[j-Pow[Low[j]]]+S[j<span class="number">-2</span>*Pow[Low[j]]];</span><br><span class="line">		&#125; <span class="comment">// 暴力预处理前缀和</span></span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,m) <span class="keyword">if</span>((QX[j]&amp;A)==(i&amp;~QY[j])) Ans[j]+=S[QZ[j]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="algorithm-3-高位前缀和容斥">Algorithm 3 : 高位前缀和+容斥</h3>
<p>起始学过高位前缀和/FMT的看到这个题第一反应可能都是这个。。</p>
<p>-&gt; 对于 <span class="math inline">\(?\)</span>
的位置，直接赋值成1，然后对于这个数从高位前缀和里查询</p>
<p>然后你发现不知道怎么对于1的把0的去掉</p>
<p>显然这个可以通过一个暴力的容斥来完成，枚举一些1的位置变成0，然后就是容斥的奇数减偶数加</p>
<p>复杂度为 <span class="math inline">\(O(Q\cdot 2^{1的个数}\ \ \ \ \
)\)</span></p>
<p>同理，处理高位后缀和，复杂度为 <span
class="math inline">\(\begin{aligned}O(Q\cdot 2^{0的个数}\ \ \  \
)\end{aligned}\)</span></p>
<p>而直接暴力枚举 <span class="math inline">\(?\)</span>
变成0/1，复杂度为 <span class="math inline">\(\begin{aligned}O(Q\cdot
2^{?的个数}\ \ \ \ \ )\end{aligned}\)</span></p>
<p>综合这三种算法，选一个更优的做，就得到一个复杂度为</p>
<p><span class="math inline">\(\begin{aligned}O(Q \ \cdot 2^{
\begin{aligned}\ \ \ \ \ \ \ \ \ \ \min\lbrace
1的个数,0的个数,?的个数\rbrace\end{aligned}})\ \ \ \ \ \
\end{aligned}\)</span></p>
<p>显然查询复杂度就是 <span class="math inline">\(O(Q\cdot 2^{\lfloor
\frac{n}{3}\rfloor }=Q\cdot 2^6)\)</span></p>
<p>算上预处理，复杂度为 <span class="math inline">\(O(2^nn+Q\cdot
2^6)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">enum</span>&#123;N=<span class="number">1</span>&lt;&lt;<span class="number">20</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,k,m,A[N],B[N],C[N],P[N];</span><br><span class="line"><span class="comment">// A 高位前缀和</span></span><br><span class="line"><span class="comment">// B 高位后缀和</span></span><br><span class="line"><span class="comment">// C 点值(打扰了)</span></span><br><span class="line"><span class="comment">// P __builtin_parity</span></span><br><span class="line"><span class="type">char</span> val[N],q[<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>,&amp;n,&amp;m,val),k=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i) A[i]=B[i]=C[i]=val[i]-<span class="string">&#x27;0&#x27;</span>,P[i]=P[i&gt;&gt;<span class="number">1</span>]^(i&amp;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i&lt;&lt;=<span class="number">1</span>) <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;k;l+=i*<span class="number">2</span>) <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) A[j+i]+=A[j],B[j]+=B[j+i];</span><br><span class="line">    <span class="comment">//预处理高位前缀和，高位后缀和</span></span><br><span class="line">	<span class="keyword">while</span>(m--) &#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,a=<span class="number">0</span>,b=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,q+<span class="number">1</span>);i&lt;=n;++i) &#123;</span><br><span class="line">			<span class="keyword">if</span>(q[i]==<span class="string">&#x27;?&#x27;</span>) x|=<span class="number">1</span>&lt;&lt;(n-i),a++;</span><br><span class="line">			<span class="keyword">if</span>(q[i]==<span class="string">&#x27;1&#x27;</span>) y|=<span class="number">1</span>&lt;&lt;(n-i),b++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a&lt;=n/<span class="number">3</span>) <span class="keyword">for</span>(<span class="type">int</span> S=x;~S;S=S?(S<span class="number">-1</span>)&amp;x:<span class="number">-1</span>) ans+=C[y|S]; <span class="comment">// 枚举?变成0/1</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(b&lt;=n/<span class="number">3</span>) <span class="keyword">for</span>(<span class="type">int</span> S=y;~S;S=S?(S<span class="number">-1</span>)&amp;y:<span class="number">-1</span>) ans+=P[S^y]?-A[S|x]:A[S|x]; <span class="comment">// 对于高位前缀和容斥</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> S=x=(k<span class="number">-1</span>)^x^y;~S;S=S?(S<span class="number">-1</span>)&amp;x:<span class="number">-1</span>) ans+=P[S]?-B[S|y]:B[S|y]; <span class="comment">// 对于高位后缀和容斥</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/JOI,JOISC/%E3%80%8CJOI%202021%20Final%E3%80%8D%E5%9C%B0%E7%89%A2%203/</url>
    <content><![CDATA[<hr />
<p>title: '「JOI 2021 Final」地牢 3' date: 'Sat Aug 12 11:05:26 2023
categories: - oi-solutions'</p>
<h1 id="joi-2021-final地牢-3">「JOI 2021 Final」地牢 3</h1>
<h3 id="判定无解">判定无解</h3>
<p>无解即： <span class="math inline">\(\exists
i\in[S,T-1],A_i&gt;U\)</span></p>
<p>是一个简单的区间最值问题</p>
<p><span class="math display">\[\  \]</span></p>
<h3 id="onm"><span class="math inline">\(O(nm)\)</span></h3>
<p>关于用单调队列之类的东西维护每个点权值的方法这里就不提了</p>
<p>形式化地，我们把一层层点放到数轴上，令 <span
class="math inline">\(X_i=\sum_{j&lt;i}A_j\)</span></p>
<p>在数轴上坐标每 <span class="math inline">\(+1\)</span>
消耗一点能量，我们要从 <span class="math inline">\(X_S\)</span> 走到
<span class="math inline">\(X_T\)</span></p>
<p>考虑每个点的情况，不妨看做是用 <span
class="math inline">\(B_i\)</span> 去覆盖 <span
class="math inline">\((X_S,X_T]\)</span> ，求最小权值</p>
<p>发现对于 <span class="math inline">\(B_i\)</span>
，它能够合法覆盖的区间一定是 <span
class="math inline">\((X_i,X_i+U]\)</span></p>
<p>暴力地，可以直接让 <span class="math inline">\(B_i\)</span>
更新这段区间的最小权值，然后暴力求和</p>
<p><span class="math display">\[\  \]</span></p>
<p>进一步分析每个 <span class="math inline">\(B_i\)</span>
覆盖的区间，可以发现是合法区间 <span
class="math inline">\((X_i,X_i+U]\)</span> 中的某一连续段 <span
class="math inline">\((L_i,R_i]\)</span></p>
<p>而 <span class="math inline">\(L_i\)</span> 取决于 <span
class="math inline">\(B_i\)</span> 前面第一个 <span
class="math inline">\(B_{pre}&lt;B_i\)</span> ， <span
class="math inline">\(R_i\)</span> 取决于后面第一个 <span
class="math inline">\(B_{nxt}\leq B_i\)</span></p>
<p>关于 <span class="math inline">\(pre,nxt\)</span>
的求解显然只是一个单调栈解决</p>
<p>得到 <span class="math inline">\((L_i,R_i]\)</span> 简单的描述</p>
<p><span class="math inline">\(L_i=\max\{X_i,X_{pre}+U\}\)</span></p>
<p><span class="math inline">\(R_i=\min\{X_i+U,X_{nxt}\}\)</span></p>
<p>(ps:这样求得的 <span class="math inline">\(L_i\)</span> 不一定 <span
class="math inline">\(&lt;R_i\)</span> )</p>
<p>暴力枚举即可 <span class="math inline">\(O(n)\)</span> 查询</p>
<p><span class="math display">\[ \ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="t_in1-从这里开始需要一些数据结构"><span
class="math inline">\(T_i=n+1\)</span>
<del>从这里开始需要一些数据结构？</del></h3>
<p>考虑倒着从 <span class="math inline">\(n\)</span> 到 <span
class="math inline">\(1\)</span> 计算每一个 <span
class="math inline">\(S_i\)</span> 的答案</p>
<p>发现在刚插入 <span class="math inline">\(i\)</span> 的时候， <span
class="math inline">\(pre_i\)</span> 还未出现，可以看做 <span
class="math inline">\(-\infty\)</span> ， <span
class="math inline">\(nxt_i\)</span> 已经确定</p>
<p>当 <span class="math inline">\(pre_i\)</span>
出现时可以重新进行一次插入</p>
<p>每次插入可以用三元组表示 <span
class="math inline">\((i,pre,nxt)\)</span> ，为了便于叙述这里 <span
class="math inline">\(pre,nxt\)</span> 直接是坐标</p>
<p>考虑对于 <span class="math inline">\(L_i,R_i\)</span>
进行参数分离计算，首先要考虑何时满足 <span
class="math inline">\(L_i&lt;R_i\)</span></p>
<p>显然条件就是 <span class="math inline">\(nxt-pre&gt;U\)</span></p>
<p><span class="math inline">\(\displaystyle
L_i=\max\{X_i,X_{pre}+U\}=X_{pre}+\max\{X_i-X_{pre},U\}\)</span></p>
<p><span class="math inline">\(\displaystyle
R_i=\min\{X_i+U,X_{nxt}\}=X_i+\min\{U,X_{nxt}-X_i\}\)</span></p>
<p><span class="math inline">\(\displaystyle Answer=\sum_{nxt-pre&gt;U}
(R_i-L_i)\cdot B_i\)</span></p>
<p>离线询问，离散之后可以用树状数组维护上述式子，对于不合法部分不要加入即可</p>
<p><span class="math display">\[\ \]</span></p>
<p><span class="math display">\[ \ \]</span></p>
<h3 id="onlog-n"><span class="math inline">\(O(n\log n)\)</span></h3>
<p>上面已经能计算 <span class="math inline">\(T_i=n+1\)</span>
的询问，考虑将 <span class="math inline">\(S,T\)</span> 转化为 <span
class="math inline">\(T_{i}=n+1\)</span> 的问题</p>
<p>如果直接 <span class="math inline">\(S,T\)</span>
相减显然不合法，不妨找到在 <span class="math inline">\((S,n+1)\)</span>
的方案中，覆盖的 <span class="math inline">\(T\)</span> 的点 <span
class="math inline">\(T&#39;\)</span></p>
<p><span class="math inline">\((S,n+1)-(T&#39;,n+1)\)</span> 会抵消掉在
<span class="math inline">\(S\)</span> 的方案中 <span
class="math inline">\(T\)</span> 右边的部分，而 <span
class="math inline">\((X_{T&#39;},X_T]\)</span> 显然仍然是由 <span
class="math inline">\(B_{T&#39;}\)</span> 覆盖，补回来即可</p>
<p>由此完成分离操作，而根据上面区间覆盖的定义， <span
class="math inline">\(T&#39;\)</span> 实际上就是 <span
class="math inline">\((X_T-U,X_T]\)</span> 中最小的 <span
class="math inline">\(B_i\)</span></p>
<p>所有操作都可以 <span class="math inline">\(O(n\log n)\)</span>
完成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) f|=IO==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,A[N],B[N],nxt[N],stk[N],top,C;</span><br><span class="line">ll ans[N],X[N],H[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123; <span class="type">int</span> U,k,id; &#125;;</span><br><span class="line">vector &lt;Node&gt; Q[N];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">	ll s[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> p,ll x)</span></span>&#123; </span><br><span class="line">		<span class="keyword">while</span>(p&lt;=C) s[p]+=x,p+=p&amp;-p; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">Que</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">		ll res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(p) res+=s[p],p-=p&amp;-p;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; T1,T2;</span><br><span class="line"><span class="comment">// T1维护式子中含U项的和</span></span><br><span class="line"><span class="comment">// T2维护式子中常数和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MaxTree</span>&#123;</span><br><span class="line">	<span class="type">int</span> s[N&lt;&lt;<span class="number">2</span>],bit;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(bit=<span class="number">1</span>;bit&lt;=n+<span class="number">1</span>;bit&lt;&lt;=<span class="number">1</span>) ;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) s[bit+i]=A[i];</span><br><span class="line">		<span class="built_in">drep</span>(i,bit,<span class="number">1</span>) s[i]=<span class="built_in">max</span>(s[i&lt;&lt;<span class="number">1</span>],s[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Que</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> s[l+bit];</span><br><span class="line">		<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(l+=bit<span class="number">-1</span>,r+=bit+<span class="number">1</span>;l^r^<span class="number">1</span>;l&gt;&gt;=<span class="number">1</span>,r&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(~l&amp;<span class="number">1</span>) <span class="built_in">cmax</span>(res,s[l^<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span>(r&amp;<span class="number">1</span>) <span class="built_in">cmax</span>(res,s[r^<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; Max;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinTree</span>&#123;</span><br><span class="line">	<span class="type">int</span> s[N&lt;&lt;<span class="number">2</span>],bit;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">mp</span>(B[x],x)&lt;<span class="built_in">mp</span>(B[y],y)?x:y; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">()</span></span>&#123;</span><br><span class="line">		B[<span class="number">0</span>]=<span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span>(bit=<span class="number">1</span>;bit&lt;=n+<span class="number">1</span>;bit&lt;&lt;=<span class="number">1</span>) ;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n) s[bit+i]=i;</span><br><span class="line">		<span class="built_in">drep</span>(i,bit,<span class="number">1</span>) s[i]=<span class="built_in">Min</span>(s[i&lt;&lt;<span class="number">1</span>],s[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Que</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> s[l+bit];</span><br><span class="line">		<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(l+=bit<span class="number">-1</span>,r+=bit+<span class="number">1</span>;l^r^<span class="number">1</span>;l&gt;&gt;=<span class="number">1</span>,r&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(~l&amp;<span class="number">1</span>) res=<span class="built_in">Min</span>(res,s[l^<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span>(r&amp;<span class="number">1</span>) res=<span class="built_in">Min</span>(res,s[r^<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; Min;</span><br><span class="line"><span class="comment">// Min 用于寻找T&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> i,ll pre,ll nxt,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="built_in">lower_bound</span>(H+<span class="number">1</span>,H+C+<span class="number">1</span>,X[i]-pre)-H,r=<span class="built_in">lower_bound</span>(H+<span class="number">1</span>,H+C+<span class="number">1</span>,nxt-pre)-H;</span><br><span class="line">	<span class="comment">// -L</span></span><br><span class="line">	T1.<span class="built_in">Add</span>(p,-B[i]*k), T1.<span class="built_in">Add</span>(r,B[i]*k);</span><br><span class="line">	T2.<span class="built_in">Add</span>(p,k*B[i]*(X[i]-pre)), T2.<span class="built_in">Add</span>(r,-k*B[i]*(X[i]-pre));</span><br><span class="line">	<span class="comment">// +R </span></span><br><span class="line">	p=<span class="built_in">lower_bound</span>(H+<span class="number">1</span>,H+C+<span class="number">1</span>,nxt-X[i])-H;</span><br><span class="line">	T1.<span class="built_in">Add</span>(<span class="number">1</span>,k*B[i]),T1.<span class="built_in">Add</span>(p,-k*B[i]);</span><br><span class="line">	T2.<span class="built_in">Add</span>(p,k*(nxt-X[i])*B[i]),T2.<span class="built_in">Add</span>(r,-k*(nxt-X[i])*B[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) A[i]=<span class="built_in">rd</span>(),X[i+<span class="number">1</span>]=X[i]+A[i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) B[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">drep</span>(i,n+<span class="number">1</span>,<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span>(top &amp;&amp; B[stk[top]]&gt;=B[i]) G[i].<span class="built_in">pb</span>(stk[top--]);</span><br><span class="line">		nxt[i]=stk[top],stk[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	Min.<span class="built_in">Build</span>(),Max.<span class="built_in">Build</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="type">int</span> S=<span class="built_in">rd</span>(),T=<span class="built_in">rd</span>(),U=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="keyword">if</span>(Max.<span class="built_in">Que</span>(S,T<span class="number">-1</span>)&gt;U)&#123; ans[i]=<span class="number">-1</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		H[++C]=U,Q[S].<span class="built_in">pb</span>((Node)&#123;U,<span class="number">1</span>,i&#125;);</span><br><span class="line">		<span class="type">int</span> l=<span class="built_in">lower_bound</span>(X+<span class="number">1</span>,X+n+<span class="number">2</span>,X[T]-U)-X; <span class="built_in">cmax</span>(l,S);</span><br><span class="line">		<span class="type">int</span> t=Min.<span class="built_in">Que</span>(l,T);</span><br><span class="line">		ans[i]+=(X[T]-X[t])*B[t];</span><br><span class="line">		Q[t].<span class="built_in">pb</span>((Node)&#123;U,<span class="number">-1</span>,i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(H+<span class="number">1</span>,H+C+<span class="number">1</span>),C=<span class="built_in">unique</span>(H+<span class="number">1</span>,H+C+<span class="number">1</span>)-H<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">drep</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">Add</span>(i,<span class="number">-1e9</span>,X[nxt[i]],<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j:G[i]) <span class="built_in">Add</span>(j,<span class="number">-1e9</span>,X[nxt[j]],<span class="number">-1</span>),<span class="built_in">Add</span>(j,X[i],X[nxt[j]],<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(Node j:Q[i])&#123;</span><br><span class="line">			<span class="type">int</span> p=<span class="built_in">lower_bound</span>(H+<span class="number">1</span>,H+C+<span class="number">1</span>,j.U)-H;</span><br><span class="line">			ans[j.id]+=j.k*(j.U*T1.<span class="built_in">Que</span>(p)+T2.<span class="built_in">Que</span>(p));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/JOI,JOISC/%E3%80%8CJOI%202021%20Final%E3%80%8D%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<hr />
<p>title: '「JOI 2021 Final」机器人' date: 'Sat Aug 12 11:05:26 2023
categories: - oi-solutions'</p>
<h1 id="joi-2021-final机器人">「JOI 2021 Final」机器人</h1>
<p>原问题中颜色什么时候改没有影响</p>
<p>显然不能记录每条边的颜色，显然在行走过程中不会回到原先的点</p>
<p>因此考虑简化状态</p>
<p>从一个点出去时，走了一条边 <span
class="math inline">\((u,v,c,w)\)</span> ，从 <span
class="math inline">\(u\)</span> 出发颜色为 <span
class="math inline">\(c\)</span> 的边 <span
class="math inline">\(w\)</span> 之和为 <span
class="math inline">\(S_{u,c}\)</span> ，则有两种转移：</p>
<p>1.走过来时的边被改变了，权值 <span
class="math inline">\(w\)</span></p>
<p>2.改变了其他同种颜色的边，权值 <span
class="math inline">\(S_{u,c}-w\)</span></p>
<p>对于2情况在前面修改的边，在后面不会产生贡献（否则可以直接通过这条边过去，而不需要绕路）</p>
<p>可以直接转移到对应节点</p>
<p>1类转移的贡献相当于下次走这种颜色时，可以少改变一条边的颜色</p>
<p>即下一次转移2时，权值变为 <span
class="math inline">\(S_{v,c}-w-w&#39;\)</span></p>
<p>可以增加一个额外权值 <span class="math inline">\(-w\)</span>
，然后对于下一个点 <span class="math inline">\(v\)</span> 所有颜色为
<span class="math inline">\(c\)</span>
的出边转移，这可以通过构建虚点解决</p>
<p>实际上总权值就是 <span class="math inline">\(0\)</span></p>
<p>考虑到一种不合法的情况，即走回 <span class="math inline">\(u\)</span>
，但是这样的转移权值就是 <span class="math inline">\(S_{v,c}-w&#39;\ge
0\)</span></p>
<p>非法情况无影响</p>
<p>最终得到的转移就是一个非负边权的最短路图，可以跑 <span
class="math inline">\(Dijkstra\)</span> 解决</p>
<p>总点数 <span class="math inline">\(\leq n+2m\)</span> ，总边数 <span
class="math inline">\(\leq 6m\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> v,c,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector &lt;Edge&gt; G[N];</span><br><span class="line"><span class="type">int</span> U[N],V[N],C[N],W[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> u; ll d;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node __) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;__.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;Node&gt; que;</span><br><span class="line">ll dis[N],S[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Upd</span><span class="params">(<span class="type">int</span> u,ll d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dis[u]&lt;=d) <span class="keyword">return</span>;</span><br><span class="line">	dis[u]=d,que.<span class="built_in">push</span>((Node)&#123;u,d&#125;);</span><br><span class="line">&#125;</span><br><span class="line">map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> c,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!st[u].<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">		st[u][c]=++k;</span><br><span class="line">		G[u].<span class="built_in">pb</span>((Edge)&#123;k,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t=st[u][c];</span><br><span class="line">	G[t].<span class="built_in">pb</span>((Edge)&#123;v,c,w&#125;),S[t]+=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">63</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	dis[<span class="number">1</span>]=<span class="number">0</span>,que.<span class="built_in">push</span>((Node)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u=que.<span class="built_in">top</span>().u; ll d=que.<span class="built_in">top</span>().d; que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(dis[u]&lt;d) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(u&lt;=n) &#123;</span><br><span class="line">			<span class="keyword">for</span>(Edge dd:G[u]) &#123;</span><br><span class="line">				<span class="type">int</span> t=dd.v;</span><br><span class="line">				<span class="keyword">for</span>(Edge i:G[t]) &#123;</span><br><span class="line">					<span class="built_in">Upd</span>(i.v,d+<span class="built_in">min</span>((ll)i.w,S[t]-i.w));</span><br><span class="line">					<span class="built_in">Upd</span>(st[i.v][i.c],d);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">for</span>(Edge i:G[u]) <span class="built_in">Upd</span>(i.v,d+S[u]-i.w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dis[n]&lt;<span class="number">1e17</span>?dis[n]:<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;robot.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),<span class="built_in">freopen</span>(<span class="string">&quot;robot.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),k=n;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>(),c=<span class="built_in">rd</span>(),w=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">AddEdge</span>(u,v,c,w),<span class="built_in">AddEdge</span>(v,u,c,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Dijkstra</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/JOI,JOISC/%E3%80%8CJOISC%202020%20Day3%E3%80%8D%E6%94%B6%E8%8E%B7/</url>
    <content><![CDATA[<hr />
<p>title: '「JOISC 2020 Day3」收获' date: 'Sat Aug 12 11:05:26 2023
categories: - oi-solutions'</p>
<h1 id="joisc-2020-day3收获">「JOISC 2020 Day3」收获</h1>
<p><del>分类讨论.jpg</del></p>
<p>分析一棵苹果树被不断摘掉的过程，找到第一个摘它的人 <span
class="math inline">\(i\)</span></p>
<p>此后，每次摘它的人，就是 <span class="math inline">\(i\)</span>
前面第一个距离它 <span class="math inline">\(\ge C\)</span>
的人，不妨设其为 <span class="math inline">\(nxt_i\)</span></p>
<p>显然， <span class="math inline">\(i,nxt_i\)</span>
的关系，会构成基环内向树森林，每条内向边有一个权值 <span
class="math inline">\(w_i\)</span></p>
<p>容易 <span class="math inline">\(O(n)\)</span> 尺取得到 <span
class="math inline">\(nxt_i,w_i\)</span> ，考虑选择环上的一个点 <span
class="math inline">\(u\)</span> ，断开 <span
class="math inline">\(u\)</span> 对应的内向边，得到一棵树</p>
<figure>
<img src="https://i.loli.net/2021/03/13/WmyTG6ksfDpoJVl.png"
alt="Snipaste_2021-03-13_13-26-19.png" />
<figcaption
aria-hidden="true">Snipaste_2021-03-13_13-26-19.png</figcaption>
</figure>
<p>处理得到环长 <span class="math inline">\(len_u\)</span> ，令 <span
class="math inline">\(dis_u=w_u\)</span> ，树上每个点的 <span
class="math inline">\(dis_v=dis_{nxt_v}+w_v\)</span></p>
<p>考虑一棵苹果树被第一次摘的情况，用一个二元组表示 <span
class="math inline">\((v,t)\)</span> ，即被 <span
class="math inline">\(v\)</span> 在 <span
class="math inline">\(t\)</span> 时刻摘掉</p>
<p>我们认为是苹果树在基环内向树上走</p>
<p>1.苹果树不跨过 <span class="math inline">\(u\)</span> 时的贡献</p>
<p>此时相当于每个 <span class="math inline">\((v,t)\)</span>
在往根节点走，贡献来自每个查询 <span
class="math inline">\((x,d)\)</span> 的子树</p>
<p>即满足 <span class="math inline">\(v\in subtree_x,dis_v-dis_x+t\leq
d\)</span></p>
<p>离散之后可以用简单的 询问离线+ <span
class="math inline">\(dfs\)</span> 作差+树状数组解决</p>
<p><span class="math display">\[ \ \]</span></p>
<p>2.跨过 <span class="math inline">\(u\)</span>
，先将苹果树的贡献移动到 <span class="math inline">\(last\)</span>
上，变为 <span class="math inline">\((last,t&#39;=t+dis_v)\)</span></p>
<p>对于每个询问，显然必须满足 <span class="math inline">\(x\)</span>
在环上</p>
<p>我们也可以令 <span
class="math inline">\(d&#39;=d-(len_u-dis_v)\)</span> ，同样将 <span
class="math inline">\(x\)</span> 移动到 <span
class="math inline">\(last\)</span> 上</p>
<p>此时只需要考虑每个 <span class="math inline">\(t&#39;\)</span> 对于
<span class="math inline">\(d&#39;\)</span> 的贡献</p>
<p>按照 <span class="math inline">\(len_u\)</span> ，我们可以将 <span
class="math inline">\(t&#39;,d&#39;\)</span> 分段，每段都是 <span
class="math inline">\([i\cdot len_u,(i+1)\cdot len_u)\)</span>
的形式</p>
<p>2-1.对于不是同一段内的，每个 <span
class="math inline">\(t&#39;\)</span> 的对于 <span
class="math inline">\(d&#39;\)</span> 的贡献次数 就是 段编号 之差</p>
<p>2-2.同一段内，就是满足 <span class="math inline">\(t&#39;\leq
d&#39;\)</span> 且 <span class="math inline">\(t&#39;\mod len_u\leq
d&#39;\mod len_u\)</span> 的个数</p>
<p>将所有 <span class="math inline">\(d&#39;,t&#39;\)</span>
排序后依次处理，容易通过参数分离处理2-1</p>
<p>对于2-2，将 <span class="math inline">\(t&#39;\mod len_u\)</span>
离散后可以用树状数组处理</p>
<p><a href="https://loj.ac/s/1089106">Loj Submission</a></p>
<p>空间复杂度为 <span class="math inline">\(O(n)\)</span> ，时间复杂度为
<span class="math inline">\(O(n\log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">int64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="function">ll <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(c=<span class="built_in">getchar</span>(),c&lt;<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(c^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span>(c=<span class="built_in">getchar</span>(),c&gt;<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span>&#123;N=<span class="number">200010</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m,q,nxt[N],L,C,C2,A[N*<span class="number">2</span>],B[N],id[N],incir[N];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; E[N],G[N];</span><br><span class="line">ll H[N],dis[N],H2[N],len[N],ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:E[u]) H[++C]=dis[u]+i;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(id[v]==id[u]) <span class="keyword">continue</span>;</span><br><span class="line">        tmp.<span class="built_in">pb</span>(v),id[v]=id[u];</span><br><span class="line">        dis[v]+=dis[u],<span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    G[u]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123; ll d; <span class="type">int</span> id; &#125;;</span><br><span class="line">vector &lt;Node&gt; Q[N],que;</span><br><span class="line">vector &lt;ll&gt; upd;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">    <span class="type">int</span> s[N],n;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> m)</span></span>&#123; n=m,<span class="built_in">memset</span>(s,<span class="number">0</span>,(n+<span class="number">1</span>)&lt;&lt;<span class="number">2</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">while</span>(p&lt;=n) s[p]+=x,p+=p&amp;-p; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Que</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p) res+=s[p],p-=p&amp;-p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T,X;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs作差处理情况1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Node &amp;i:Q[u]) &#123;</span><br><span class="line">        <span class="comment">// 如果满足查询点在环上，就要加入2-1,2-2的计算</span></span><br><span class="line">        <span class="keyword">if</span>(incir[u]) &#123;</span><br><span class="line">            ll d=i.d-(len[id[u]]-dis[u]);</span><br><span class="line">            <span class="keyword">if</span>(d&gt;=<span class="number">0</span>) que.<span class="built_in">pb</span>((Node)&#123;d,i.id&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs作差-1</span></span><br><span class="line">        ans[i.id]-=T.<span class="built_in">Que</span>(i.d=<span class="built_in">upper_bound</span>(H+<span class="number">1</span>,H+C+<span class="number">1</span>,dis[u]+i.d)-H<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:E[u]) T.<span class="built_in">Add</span>(<span class="built_in">lower_bound</span>(H+<span class="number">1</span>,H+C+<span class="number">1</span>,dis[u]+i)-H,<span class="number">1</span>),upd.<span class="built_in">pb</span>(dis[u]+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u]) <span class="built_in">dfs2</span>(v);</span><br><span class="line">    <span class="comment">// dfs作差+1</span></span><br><span class="line">    <span class="keyword">for</span>(Node i:Q[u]) ans[i.id]+=T.<span class="built_in">Que</span>(i.d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),L=<span class="built_in">rd</span>(),C=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=<span class="built_in">rd</span>(),A[i+n]=A[i]+L;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) B[i]=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="type">int</span> C_=C%L,p=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 尺取预处理i,nxt[i],w[i]</span></span><br><span class="line">    <span class="built_in">rep</span>(i,n,n*<span class="number">2</span><span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;i &amp;&amp; A[i]-A[p+<span class="number">1</span>]&gt;=C_) p++;</span><br><span class="line">        nxt[i-n]=p%n,G[p%n].<span class="built_in">pb</span>(i-n);</span><br><span class="line">        dis[i-n]=C-C_+A[i]-A[p];</span><br><span class="line">    &#125;</span><br><span class="line">    p=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 预处理(v,t)</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;n*<span class="number">2</span><span class="number">-1</span> &amp;&amp; B[i]+L&gt;=A[p+<span class="number">1</span>]) p++;</span><br><span class="line">        E[p%n].<span class="built_in">pb</span>(B[i]+L-A[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    C=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 断环构建树</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) id[i]=<span class="number">-2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(id[i]==<span class="number">-2</span>) &#123;</span><br><span class="line">        <span class="type">int</span> u=i;</span><br><span class="line">        <span class="keyword">for</span>(;~id[u];u=nxt[u]) id[u]=<span class="number">-1</span>;</span><br><span class="line">        id[u]=u,len[u]=dis[u],incir[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v=nxt[u];v!=u;v=nxt[v]) len[u]+=dis[v],incir[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(H+<span class="number">1</span>,H+C+<span class="number">1</span>),T.<span class="built_in">Init</span>(C=<span class="built_in">unique</span>(H+<span class="number">1</span>,H+C+<span class="number">1</span>)-H<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 离线询问，权值离散</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,q=<span class="built_in">rd</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">rd</span>()<span class="number">-1</span>; ll d=<span class="built_in">rd</span>();</span><br><span class="line">        Q[u].<span class="built_in">pb</span>((Node)&#123;d,i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(id[i]==i) &#123;</span><br><span class="line">        que.<span class="built_in">clear</span>(),upd.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">dfs2</span>(i);</span><br><span class="line">        <span class="built_in">sort</span>(upd.<span class="built_in">begin</span>(),upd.<span class="built_in">end</span>()),<span class="built_in">sort</span>(que.<span class="built_in">begin</span>(),que.<span class="built_in">end</span>(),[&amp;](Node x,Node y)&#123; <span class="keyword">return</span> x.d&lt;y.d; &#125;);</span><br><span class="line">        C2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll x:upd) H2[++C2]=x%len[i];</span><br><span class="line">        <span class="built_in">sort</span>(H2+<span class="number">1</span>,H2+C2+<span class="number">1</span>),X.<span class="built_in">Init</span>(C2=<span class="built_in">unique</span>(H2+<span class="number">1</span>,H2+C2+<span class="number">1</span>)-H2<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> it=upd.<span class="built_in">begin</span>();</span><br><span class="line">        ll s=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node &amp;q:que) &#123;</span><br><span class="line">            <span class="keyword">while</span>(it!=upd.<span class="built_in">end</span>() &amp;&amp; *it&lt;=q.d) </span><br><span class="line">                X.<span class="built_in">Add</span>(<span class="built_in">lower_bound</span>(H2+<span class="number">1</span>,H2+C2+<span class="number">1</span>,*it%len[i])-H2,<span class="number">1</span>),s+=*(it++)/len[i],c++;</span><br><span class="line">            <span class="comment">// 参数分离处理2-1</span></span><br><span class="line">            ans[q.id]+=q.d/len[i]*c-s;</span><br><span class="line">            <span class="comment">// 树状数组查询2-2</span></span><br><span class="line">            ans[q.id]+=X.<span class="built_in">Que</span>(<span class="built_in">upper_bound</span>(H2+<span class="number">1</span>,H2+C2+<span class="number">1</span>,q.d%len[i])-H2<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,q) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/JOI,JOISC/%E3%80%8CJOISC%202014%20Day4%E3%80%8D%E4%B8%A4%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%98%9F%E5%BA%A7%20/</url>
    <content><![CDATA[<hr />
<p>title: 'LOJ 2882. 「JOISC 2014 Day4」两个人的星座' date: 'Sat Aug 12
11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="loj-2882.-joisc-2014-day4两个人的星座">LOJ 2882. 「JOISC 2014
Day4」两个人的星座</h1>
<p>对于任意两个凸多边形相离，一定可以找到一条直线将它们分在平面的两个区域</p>
<p>而对于三角形的情况更为特殊</p>
<p>分析可以发现，很难直接枚举三角形外直线计算，而对于任意的两个合法的三角形，在其6点中较近的4个点中</p>
<p>一定可以从两个三角形中各选一个点，连出两条交错的合法的分界线，例如下图</p>
<figure>
<img src="https://i.loli.net/2020/11/02/9Yc4vJuLlxtjbBG.png"
alt="QQ截图20201102153211.png" />
<figcaption aria-hidden="true">QQ截图20201102153211.png</figcaption>
</figure>
<p>那么可以考虑枚举这样的一条直线，即确定了两个分界线上的端点，然后从两个半平面内选出不同颜色的点</p>
<p>直接枚举，然后 <span class="math inline">\(O(n)\)</span>
数出这样的点，复杂度为 <span class="math inline">\(O(n^3)\)</span></p>
<p>显然可以想到枚举一个顶点，然后对于其他极角排序，旋转另一个点，同步统计半平面内的点个数，复杂度为
<span class="math inline">\(O(n^2\log n)\)</span></p>
<p>实现上，可以枚举一个点，尺取一个半平面内的点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">int64_t</span>;</span><br><span class="line"><span class="keyword">enum</span>&#123;N=<span class="number">3010</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,X[N],Y[N],I[N],C[N],c,s[<span class="number">2</span>][<span class="number">3</span>],i;</span><br><span class="line"><span class="type">double</span> T[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function">ll <span class="title">E</span><span class="params">(<span class="type">int</span> j,<span class="type">int</span> k)</span></span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*(X[j]-X[i])*(Y[k]-Y[i])<span class="number">-1ll</span>*(Y[j]-Y[i])*(X[k]-X[i]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,X+i,Y+i,C+i);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">		c=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span> s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j) <span class="keyword">if</span>(i!=j) I[++c]=j,T[j]=<span class="built_in">atan2</span>(Y[j]-Y[i],X[j]-X[i]),s[<span class="number">0</span>][C[j]]++;</span><br><span class="line">		<span class="built_in">sort</span>(I+<span class="number">1</span>,I+n,[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123; <span class="keyword">return</span> T[x]&lt;T[y]; &#125;);</span><br><span class="line">		<span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;++j) &#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">E</span>(I[j],I[p])&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">				s[<span class="number">0</span>][C[I[p]]]--,s[<span class="number">1</span>][C[I[p]]]++;</span><br><span class="line">				p=p%c+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(p==j) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans+=<span class="number">1ll</span>*s[<span class="number">0</span>][(C[i]+<span class="number">1</span>)%<span class="number">3</span>]*s[<span class="number">0</span>][(C[i]+<span class="number">2</span>)%<span class="number">3</span>]*s[<span class="number">1</span>][(C[I[j]]+<span class="number">1</span>)%<span class="number">3</span>]*s[<span class="number">1</span>][(C[I[j]]+<span class="number">2</span>)%<span class="number">3</span>];</span><br><span class="line">			s[<span class="number">1</span>][C[I[j]]]--,s[<span class="number">0</span>][C[I[j]]]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个更好的写法是把在 <span class="math inline">\(y\)</span>
轴以下的点中心对称上来，统计时每跨过一个点改变一次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">enum</span>&#123;N=<span class="number">3010</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,X[N],Y[N],C[N],c,s[<span class="number">2</span>][<span class="number">3</span>],i,j,d,a,b,x,y;</span><br><span class="line"><span class="type">int64_t</span> ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,d,c;</span><br><span class="line">	<span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> r) &#123;</span><br><span class="line">		x=p,y=q,c=r,d=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(y&lt;<span class="number">0</span>||(x&lt;<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)) d=<span class="number">1</span>,x=-x,y=-y; </span><br><span class="line">		s[d][c]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; A[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123; <span class="function"><span class="type">int</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="type">const</span> Node &amp;a,<span class="type">const</span> Node &amp;b)</span></span>&#123; <span class="keyword">return</span> <span class="number">1ll</span>*a.x*b.y&lt;<span class="number">1ll</span>*a.y*b.x; &#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,X+i,Y+i,C+i);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(s,c=<span class="number">0</span>,<span class="keyword">sizeof</span> s),a=(C[i]+<span class="number">1</span>)%<span class="number">3</span>,b=(a+<span class="number">1</span>)%<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;++j) <span class="keyword">if</span>(i!=j) A[++c]=<span class="built_in">Node</span>(X[j]-X[i],Y[j]-Y[i],C[j]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">sort</span>(A+<span class="number">1</span>,A+n,<span class="built_in">cmp</span>()),j=<span class="number">1</span>;j&lt;n;++j) &#123;</span><br><span class="line">			s[A[j].d][c=A[j].c]--,x=(c+<span class="number">1</span>)%<span class="number">3</span>,y=(x+<span class="number">1</span>)%<span class="number">3</span>;</span><br><span class="line">			<span class="keyword">for</span>(d=<span class="number">0</span>;d&lt;<span class="number">2</span>;++d) ans+=<span class="number">1ll</span>*s[d][a]*s[d][b]*s[!d][x]*s[!d][y];</span><br><span class="line">			s[!A[j].d][c]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans/<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/JOI,JOISC/%E3%80%8CJOISC%202020%20Day3%E3%80%8D%E6%98%9F%E5%BA%A7%203/</url>
    <content><![CDATA[<hr />
<p>title: '「JOISC 2020 Day3」星座 3 (dp)' date: 'Sat Aug 12 11:05:26
2023 categories: - oi-solutions'</p>
<h1 id="joisc-2020-day3星座-3-dp">「JOISC 2020 Day3」星座 3 (dp)</h1>
<p>考虑根据 <span class="math inline">\(A_i\)</span>
的值建立笛卡尔树，此时平面被划分为个矩形空间</p>
<p>下称选择一个点为保留一个星星</p>
<figure>
<img src="https://i.loli.net/2021/03/13/SLHx8PR4rwIo1h3.png"
alt="Snipaste_2021-03-13_11-21-27.png" />
<figcaption
aria-hidden="true">Snipaste_2021-03-13_11-21-27.png</figcaption>
</figure>
<p>具体的，对于笛卡尔树上的节点 <span
class="math inline">\((u,l,r)\)</span>
，它的矩形就是父节点矩形以下，且满足 <span
class="math inline">\(x\in[l,r],y&gt;A_u\)</span> 的部分</p>
<p>可以用一个线段树来查询矩形内部的点，线段树上每个节点维护 <span
class="math inline">\(y_{max}\)</span> ，每次剥掉 <span
class="math inline">\(y_{max}&gt;A_u\)</span> 的部分</p>
<p>复杂度为均摊 <span class="math inline">\(O(n\log n)\)</span></p>
<p><span class="math display">\[ \ \]</span></p>
<p>观察笛卡尔树的树形，容易发现，</p>
<p>1.笛卡尔树左右子树的矩形之间不会产生贡献</p>
<p>2.每个节点对应的矩形区间内最多选择一个点</p>
<p>3.如果一个节点 <span class="math inline">\((u,l,r)\)</span>
的祖先中有一个 <span class="math inline">\(x_i\in[l,r]\)</span>
的点选择了，那么自己的矩形内不能选择点</p>
<p>那么令 <span class="math inline">\(dp_{u,i}\)</span>
表示父节点传下来的点 <span class="math inline">\(x=i\)</span> 时， <span
class="math inline">\(u\)</span> 子树内的答案</p>
<p>对于 <span class="math inline">\(i\in[l,r]\)</span>
的情况，可以直接将儿子的值合并，加上自己区间内部的权值总和 <span
class="math inline">\(C_i\)</span></p>
<p>对于 <span class="math inline">\(i\not \in[l,r]\)</span>
的情况，这一部分答案相同</p>
<p>可以从自己子区间内选择一个点 <span
class="math inline">\((x_i,y_i,c_i)\)</span>
下传，此时沿用上面合并得到的 <span class="math inline">\(dp\)</span>
值</p>
<p><span
class="math inline">\(outans=\min\{dp_{x_i}+sum-c_i\}\)</span></p>
<p>如何实现这个奇怪的 <span class="math inline">\(dp\)</span> 过程？</p>
<p>考虑子树的区间不交，因此对于 <span
class="math inline">\((u,l,r)\)</span> ，只维护 <span
class="math inline">\(l,r\)</span> 内部的答案，对于 <span
class="math inline">\(i\not \in[l,r]\)</span> 的部分额外记录一个值 <span
class="math inline">\(dp_u\)</span></p>
<p>考虑用一棵静态的线段树维护 <span class="math inline">\(dp\)</span>
，线段树上存储 <span class="math inline">\(i\in[l,r]\)</span> 的答案</p>
<p>合并左右儿子时，两个儿子的区间不交</p>
<p>因此，实际上答案就是将 <span class="math inline">\(dp_{ls}\)</span>
加到 <span class="math inline">\([u,r]\)</span> 上，将 <span
class="math inline">\(dp_{rs}\)</span> 加到 <span
class="math inline">\([l,u]\)</span> 上</p>
<p>处理出 <span class="math inline">\(sum\)</span> 之后，区间修改 <span
class="math inline">\([l,r]\)</span> 的答案，对于 <span
class="math inline">\(dp_u\)</span> 直接按照上面的方法枚举 <span
class="math inline">\((x_i,y_i,c_i)\)</span> 来计算即可</p>
<p>复杂度为 <span class="math inline">\(O(n\log n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,A[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegFinder</span>&#123;</span><br><span class="line">	vector &lt;Pii&gt; V[N];</span><br><span class="line">	<span class="type">int</span> s[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">			<span class="built_in">sort</span>(V[l].<span class="built_in">begin</span>(),V[l].<span class="built_in">end</span>());</span><br><span class="line">			s[p]=V[l].<span class="built_in">empty</span>()?<span class="number">0</span>:V[l].<span class="built_in">back</span>().first;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">Build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		s[p]=<span class="built_in">max</span>(s[p&lt;&lt;<span class="number">1</span>],s[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr,<span class="type">int</span> x,vector &lt;Pii&gt; &amp;Res)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[p]&lt;x) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">			<span class="keyword">while</span>(!V[l].<span class="built_in">empty</span>() &amp;&amp; V[l].<span class="built_in">back</span>().first&gt;=x) Res.<span class="built_in">pb</span>(<span class="built_in">mp</span>(l,V[l].<span class="built_in">back</span>().second)),V[l].<span class="built_in">pop_back</span>();</span><br><span class="line">			s[p]=V[l].<span class="built_in">empty</span>()?<span class="number">0</span>:V[l].<span class="built_in">back</span>().first;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(ql&lt;=mid) <span class="built_in">Get</span>(p&lt;&lt;<span class="number">1</span>,l,mid,ql,qr,x,Res);</span><br><span class="line">		<span class="keyword">if</span>(qr&gt;mid) <span class="built_in">Get</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,ql,qr,x,Res);</span><br><span class="line">		s[p]=<span class="built_in">max</span>(s[p&lt;&lt;<span class="number">1</span>],s[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; Finder;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ls[N],rs[N],stk[N],top,mk[N];</span><br><span class="line"><span class="type">int</span> rt[N];</span><br><span class="line">ll dp[N],s[N&lt;&lt;<span class="number">2</span>],t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">Que</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) <span class="keyword">return</span> s[p];</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>; ll res=<span class="number">1e18</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) <span class="built_in">cmin</span>(res,<span class="built_in">Que</span>(p&lt;&lt;<span class="number">1</span>,l,mid,ql,qr));</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;mid) <span class="built_in">cmin</span>(res,<span class="built_in">Que</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line">	<span class="keyword">return</span> res+t[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Upd</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr,ll x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;</span><br><span class="line">		s[p]+=x,t[p]+=x;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) <span class="built_in">Upd</span>(p&lt;&lt;<span class="number">1</span>,l,mid,ql,qr,x);</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;mid) <span class="built_in">Upd</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,ql,qr,x);</span><br><span class="line">	s[p]=<span class="built_in">min</span>(s[p&lt;&lt;<span class="number">1</span>],s[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])+t[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树内存储的是 如果父节点有下传下来的答案</span></span><br><span class="line"><span class="comment">// dp 存储没有父节点下传的答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	vector &lt;Pii&gt; V; Finder.<span class="built_in">Get</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,A[p]+<span class="number">1</span>,V);</span><br><span class="line">	<span class="comment">// 拿出我的决策矩形</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(l&lt;p) <span class="built_in">Solve</span>(ls[p],l,p<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(p&lt;r) <span class="built_in">Solve</span>(rs[p],p+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">if</span>(rs[p]) <span class="built_in">Upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,p,dp[rs[p]]);</span><br><span class="line">	<span class="keyword">if</span>(ls[p]) <span class="built_in">Upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,p,r,dp[ls[p]]);</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(Pii i:V) sum+=i.second;</span><br><span class="line">	<span class="keyword">if</span>(sum) <span class="built_in">Upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,sum); </span><br><span class="line">	<span class="comment">// 如果父节点有下传，那么自己必须被清空</span></span><br><span class="line">	<span class="comment">// 否则考虑选择一个下传下去，这样就能得到 没有父节点下传时的值</span></span><br><span class="line">	dp[p]=<span class="built_in">Que</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">	<span class="keyword">for</span>(Pii i:V) <span class="built_in">cmin</span>(dp[p],<span class="built_in">Que</span>(<span class="number">1</span>,<span class="number">1</span>,n,i.first,i.first)-i.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		A[i]=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="keyword">while</span>(top &amp;&amp; A[stk[top]]&lt;=A[i]) ls[i]=stk[top--];</span><br><span class="line">		stk[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	top=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">drep</span>(i,n,<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span>(top &amp;&amp; A[stk[top]]&lt;A[i]) rs[i]=stk[top--];</span><br><span class="line">		stk[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) mk[ls[i]]=mk[rs[i]]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(_,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>(),c=<span class="built_in">rd</span>();</span><br><span class="line">		Finder.V[x].<span class="built_in">pb</span>(<span class="built_in">mp</span>(y,c));</span><br><span class="line">	&#125;</span><br><span class="line">	Finder.<span class="built_in">Build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!mk[i]) &#123;</span><br><span class="line">		<span class="built_in">Solve</span>(i,<span class="number">1</span>,n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[i]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/JOI,JOISC/%E3%80%8CJOISC%202020%20Day4%E3%80%8D%E4%BC%A0%E5%A5%87%E5%9B%A2%E5%AD%90%E5%B8%88%E5%82%85/</url>
    <content><![CDATA[<hr />
<p>title: '「JOISC 2020 Day4」传奇团子师傅 (假模拟退火)' date: 'Sat Aug
12 11:05:26 2023 categories: - oi-solutions'</p>
<h1 id="joisc-2020-day4传奇团子师傅-假模拟退火">「JOISC 2020
Day4」传奇团子师傅 (假模拟退火)</h1>
<p>感觉每次想写模拟退火，调着调着就不知道变成什么东西了</p>
<p>首先是分析原图，每个方案对应选择三个点，不同的方案之间显然存在排斥关系</p>
<p>将这些关系建立成边，问题就转化为一个
<strong>一般图最大独立集</strong> 问题</p>
<p><del>这怎么搞得定。。</del></p>
<p>因此考虑退火，每次操作随机选择一个点，检查周围的点是否选择，数一下如果自己被选，要弹掉的点的个数</p>
<p>同普通的退火，一开始温度高不停随机</p>
<p>到了后面就直接变成
选择答案不劣的方案（也就是交换两个点），事实证明这样的效率比较高</p>
<p>但是直接随机容易随机到选过的点，需要稍微加速一下</p>
<p>具体的，退火每若干次为一轮，每轮随机一个排列</p>
<p>在排列中从左到右找到前面 <span class="math inline">\(L\)</span>
个未选点，然后在 <span class="math inline">\(L\)</span>
个点中随机若干次进行决策</p>
<p>我是直接暴力bitset存答案的，但是效率好像还可以</p>
<p>因为是跑一个点调一次参数的，前面的代码都没存。。。</p>
<p>tips:代码对于不同数据需要修改前面三行的常量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,M=N*N/<span class="number">2</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> infile[]=<span class="string">&quot;5.in&quot;</span>,outfile[]=<span class="string">&quot;output_05.txt&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">48620</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,C;</span><br><span class="line"><span class="type">char</span> s[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chk</span><span class="params">(<span class="type">char</span> x)</span></span>&#123; <span class="keyword">return</span> x==<span class="string">&#x27;P&#x27;</span> || x==<span class="string">&#x27;G&#x27;</span>; &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,t;</span><br><span class="line">&#125; R[M];</span><br><span class="line">bitset &lt;M&gt; Ansmap,Nowmap;</span><br><span class="line"><span class="type">int</span> ans,now;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> S[]=<span class="string">&quot;-|\\/&quot;</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; G[N][N],E[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Naive_Simulator</span>&#123;</span><br><span class="line">    ~<span class="built_in">Naive_Simulator</span>()&#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,C) <span class="keyword">if</span>(Ansmap[i]) s[R[i].x][R[i].y]=S[R[i].t];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">puts</span>(s[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> P[M],D[M],F[M],PC,counter,lst,L;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Work</span><span class="params">(db T,db d,db End,<span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(T&gt;End &amp;&amp; ans&lt;MAX) &#123;</span><br><span class="line">            <span class="keyword">if</span>(++counter%<span class="number">4000</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                cerr&lt;&lt;ans&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;T&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(counter%<span class="number">500</span>==<span class="number">0</span>) <span class="built_in">random_shuffle</span>(D+<span class="number">1</span>,D+C+<span class="number">1</span>),lst=<span class="number">1</span>;</span><br><span class="line">            PC=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">rep</span>(i,lst,C) <span class="keyword">if</span>(!Nowmap[D[i]]) &#123;</span><br><span class="line">                P[++PC]=D[i];</span><br><span class="line">                lst=i;</span><br><span class="line">                <span class="keyword">if</span>(PC&gt;=L) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(PC&lt;L) &#123;</span><br><span class="line">                lst=<span class="number">1</span>;</span><br><span class="line">                PC=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">rep</span>(i,lst,C) <span class="keyword">if</span>(!Nowmap[D[i]]) &#123;</span><br><span class="line">                    P[++PC]=D[i];</span><br><span class="line">                    lst=i;</span><br><span class="line">                    <span class="keyword">if</span>(PC&gt;=L) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="number">50</span>) &#123;</span><br><span class="line">                <span class="type">int</span> u,v;</span><br><span class="line">                u=P[<span class="built_in">rand</span>()%PC+<span class="number">1</span>],v=P[<span class="built_in">rand</span>()%PC+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(u==v || Nowmap[u]) &#123;</span><br><span class="line">                    kase--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v:E[u]) cnt+=Nowmap[v];</span><br><span class="line">                <span class="keyword">if</span>(cnt-delta&lt;=T) &#123;</span><br><span class="line">                    Nowmap[u]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> v:E[u]) Nowmap[v]=<span class="number">0</span>;</span><br><span class="line">                    now+=<span class="number">1</span>-cnt;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span>(kase%<span class="number">5</span>==<span class="number">0</span> &amp;&amp; now&gt;ans) ans=now,Ansmap=Nowmap;</span><br><span class="line">            &#125;</span><br><span class="line">            T*=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Simulate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//srand(114514);</span></span><br><span class="line">        <span class="comment">//srand(1919810);</span></span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        now=<span class="number">0</span>,Nowmap.<span class="built_in">reset</span>();</span><br><span class="line">        counter=<span class="number">0</span>,lst=<span class="number">1</span>,L=<span class="number">200</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,C) D[i]=i;</span><br><span class="line">        <span class="built_in">rep</span>(kase,<span class="number">1</span>,<span class="number">10</span>) <span class="built_in">Work</span>(<span class="number">2</span>,<span class="number">0.95</span>,<span class="number">1e-2</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Work</span>(<span class="number">0.99</span>,<span class="number">0.99993</span>,<span class="number">1e-8</span>,<span class="number">2</span>);</span><br><span class="line">        Nowmap=Ansmap,now=ans;</span><br><span class="line">        <span class="built_in">Work</span>(<span class="number">0.99</span>,<span class="number">0.99999</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Naive_Simulator</span>()&#123;</span><br><span class="line">        <span class="built_in">freopen</span>(infile,<span class="string">&quot;r&quot;</span>,stdin),<span class="built_in">freopen</span>(outfile,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">        n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,m) <span class="keyword">if</span>(!<span class="built_in">chk</span>(s[i][j])) &#123;</span><br><span class="line">            s[i][j]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">            <span class="built_in">rep</span>(d,<span class="number">0</span>,<span class="number">3</span>) <span class="keyword">if</span>(<span class="built_in">chk</span>(s[i+z[d][<span class="number">0</span>]][j+z[d][<span class="number">1</span>]]) &amp;&amp; <span class="built_in">chk</span>(s[i-z[d][<span class="number">0</span>]][j-z[d][<span class="number">1</span>]]) &amp;&amp; s[i+z[d][<span class="number">0</span>]][j+z[d][<span class="number">1</span>]]!=s[i-z[d][<span class="number">0</span>]][j-z[d][<span class="number">1</span>]]) &#123;</span><br><span class="line">                R[++C]=(Node)&#123;i,j,d&#125;;</span><br><span class="line">                G[i][j].<span class="built_in">pb</span>(C);</span><br><span class="line">                G[i+z[d][<span class="number">0</span>]][j+z[d][<span class="number">1</span>]].<span class="built_in">pb</span>(C);</span><br><span class="line">                G[i-z[d][<span class="number">0</span>]][j-z[d][<span class="number">1</span>]].<span class="built_in">pb</span>(C);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">rep</span>(j,<span class="number">1</span>,m) <span class="built_in">rep</span>(k,<span class="number">0</span>,G[i][j].<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">rep</span>(l,k+<span class="number">1</span>,kend) &#123;</span><br><span class="line">            E[G[i][j][k]].<span class="built_in">pb</span>(G[i][j][l]);</span><br><span class="line">            E[G[i][j][l]].<span class="built_in">pb</span>(G[i][j][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Simulate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Solver;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; ; &#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1037H%20%20-%20Security/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1037H - Security' date: 'Sat Aug 12 11:05:25 2023
categories: - oi-solutions'</p>
<h1 id="cf1037h---security">CF1037H - Security</h1>
<h3 id="题目大意">题目大意</h3>
<p>给定一个串 <span class="math inline">\(S\)</span> ，每次查询一个区间
<span class="math inline">\([l,r]\)</span> 和一个串 <span
class="math inline">\(T\)</span></p>
<p>求 <span class="math inline">\([l,r]\)</span> 内字典序 <span
class="math inline">\(&gt;T\)</span> 的最小的子串 <span
class="math inline">\(R\)</span></p>
<p><br></p>
<h3 id="分析">分析</h3>
<p>~~复习 <span class="math inline">\(\text{SAM}\)</span> ~~</p>
<p>显然可以枚举 <span class="math inline">\(T\)</span> 匹配 <span
class="math inline">\(R\)</span>
的长度，然后枚举下一位字符，判断形成的串是否在 <span
class="math inline">\([l,r]\)</span> 内有出现</p>
<p>匹配问题用 <span class="math inline">\(\text{SAM}\)</span>
维护比较方便，求出匹配节点后，判断其 <span
class="math inline">\(\text{endpos}\)</span> 集是否包含所求范围</p>
<p>可以在线线段树合并，也可以将所所有询问离线后树状数组+ <span
class="math inline">\(\text{dfs}\)</span> 作差</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> trans[N][<span class="number">26</span>],link[N],len[N],End[N],cnt,lst;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Extend</span><span class="params">(<span class="type">int</span> c)</span></span>&#123; </span><br><span class="line">	<span class="type">int</span> p=lst,cur=++cnt; len[cur]=len[lst]+<span class="number">1</span>,lst=cur;</span><br><span class="line">	End[cur]=len[cur];</span><br><span class="line">	<span class="keyword">while</span>(~p &amp;&amp; !trans[p][c]) trans[p][c]=cur,p=link[p];</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="number">-1</span>)&#123; link[cur]=<span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="type">int</span> q=trans[p][c];</span><br><span class="line">	<span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>)&#123; link[cur]=q; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="type">int</span> r=++cnt;</span><br><span class="line">	len[r]=len[p]+<span class="number">1</span>,<span class="built_in">memcpy</span>(trans[r],trans[q],<span class="number">104</span>);</span><br><span class="line">	<span class="keyword">while</span>(~p &amp;&amp; trans[p][c]==q) trans[p][c]=r,p=link[p];</span><br><span class="line">	link[r]=link[q],link[q]=link[cur]=r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=N*<span class="number">32</span>;</span><br><span class="line"><span class="type">int</span> ls[M],rs[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Upd</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	p=++cnt;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	x&lt;=mid?<span class="built_in">Upd</span>(ls[p],l,mid,x):<span class="built_in">Upd</span>(rs[p],mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Uni</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">	<span class="type">int</span> z=++cnt;</span><br><span class="line">	ls[z]=<span class="built_in">Uni</span>(ls[x],ls[y]),rs[z]=<span class="built_in">Uni</span>(rs[x],rs[y]);</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Que</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql&gt;qr || !p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid &amp;&amp; <span class="built_in">Que</span>(ls[p],l,mid,ql,qr)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;mid &amp;&amp; <span class="built_in">Que</span>(rs[p],mid+<span class="number">1</span>,r,ql,qr)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(End[u]) <span class="built_in">Upd</span>(rt[u],<span class="number">1</span>,n,End[u]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:G[u]) <span class="built_in">dfs</span>(v),rt[u]=<span class="built_in">Uni</span>(rt[u],rt[v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> K[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> l=<span class="built_in">rd</span>(),r=<span class="built_in">rd</span>(); </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>),m=<span class="built_in">strlen</span>(s+<span class="number">1</span>),s[m+<span class="number">1</span>]=<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		K[i]=trans[K[i<span class="number">-1</span>]][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		<span class="keyword">if</span>(!K[i]) <span class="keyword">break</span>;</span><br><span class="line">		p=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">drep</span>(i,p,<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">rep</span>(j,s[i+<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>,<span class="number">25</span>) &#123;</span><br><span class="line">			<span class="type">int</span> x=trans[K[i]][j];</span><br><span class="line">			<span class="keyword">if</span>(!x) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">Que</span>(rt[x],<span class="number">1</span>,n,l+i,r)) <span class="keyword">continue</span>;</span><br><span class="line">			s[i+<span class="number">1</span>]=j+<span class="string">&#x27;a&#x27;</span>,s[i+<span class="number">2</span>]=<span class="number">0</span>,<span class="built_in">puts</span>(s+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	link[<span class="number">0</span>]=<span class="number">-1</span>,<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>),n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">Extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,cnt) G[link[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">	cnt=<span class="number">0</span>,<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">rep</span>(_,<span class="number">1</span>,<span class="built_in">rd</span>()) <span class="built_in">Solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1051G%20-%20Distinctification/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1051G - Distinctification' date: 'Sat Aug 12 11:05:25 2023
categories: - oi-solutions'</p>
<h1 id="cf1051g---distinctification">CF1051G - Distinctification</h1>
<h3 id="题目大意">题目大意</h3>
<p>对于一个二元组集合 <span
class="math inline">\(\{(a_i,b_i)\}\)</span></p>
<p>每次可以进行操作</p>
<p>1.如果存在 <span class="math inline">\(a_i=a_j\)</span> ，可以花费
<span class="math inline">\(b_i\)</span> 代价 <span
class="math inline">\(a_i\)</span> 增加1</p>
<p>2.如果存在 <span class="math inline">\(a_i=a_{j}+1\)</span>
，可以花费 <span class="math inline">\(-b_i\)</span> 代价使 <span
class="math inline">\(a_i\)</span> 减少1</p>
<p>现在依次向集合插入 <span class="math inline">\(n\)</span>
个二元组，求在所有时刻，对于当前的集合进行操作</p>
<p>最终使得不存在 <span class="math inline">\(a_i=a_j\)</span>
时的最小花费（可以为负）</p>
<p><br></p>
<h3 id="分析">分析</h3>
<p>容易发现对于给定的 <span class="math inline">\(a_i\)</span>
集合，最终 <span class="math inline">\(a_i\)</span> 的集合唯一固定</p>
<p>具体的，每次插入一个数值 <span class="math inline">\(x\)</span>
，如果出现重复就会不停将 <span class="math inline">\(x\)</span>
向后推推推</p>
<p>而事实上答案为 <span class="math inline">\(\sum b_i\cdot
(a&#39;_i-a_i)\)</span> ，那么只需要最小化 <span
class="math inline">\(\sum b_ia&#39;_i\)</span></p>
<p>容易发现在任意时刻，如果 <span class="math inline">\([L,R]\)</span>
内所有 <span class="math inline">\(a_i\)</span>
都出现，就可以任意交换他们的 <span
class="math inline">\(b_i\)</span></p>
<p>那么最终状态中每一个 <span class="math inline">\(a_i\)</span>
连通块内，按照 <span class="math inline">\(b_i\)</span>
从大到小排序即可</p>
<p>每次插入一个元素维护连通块之间的合并以及求出 <span
class="math inline">\(\sum b_ia&#39;_i\)</span> 即可</p>
<p>可以用启发式合并/线段树合并维护</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span>+<span class="number">10</span>,M=N*<span class="number">19</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ls[M],rs[M],c[M],cnt;</span><br><span class="line">ll s[M],ans[M];</span><br><span class="line">ll Ans;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> F[N],rt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> F[x]==x?x:F[x]=<span class="built_in">Find</span>(F[x]); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Up</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	c[x]=c[ls[x]]+c[rs[x]],s[x]=s[ls[x]]+s[rs[x]];</span><br><span class="line">	ans[x]=ans[ls[x]]+ans[rs[x]]+c[rs[x]]*s[ls[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Upd</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p) p=++cnt;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123; c[p]=<span class="number">1</span>,s[p]=x; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	x&lt;=mid?<span class="built_in">Upd</span>(ls[p],l,mid,x):<span class="built_in">Upd</span>(rs[p],mid+<span class="number">1</span>,r,x);</span><br><span class="line">	<span class="built_in">Up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l=<span class="number">1</span>,<span class="type">int</span> r=n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	ls[x]=<span class="built_in">Union</span>(ls[x],ls[y],l,mid),rs[x]=<span class="built_in">Union</span>(rs[x],rs[y],mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Up</span>(x),x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	x=<span class="built_in">Find</span>(x);</span><br><span class="line">	Ans+=k*(x*s[rt[x]]+ans[rt[x]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>();</span><br><span class="line">		Ans-=<span class="number">1ll</span>*x*y;</span><br><span class="line">		<span class="type">int</span> f=<span class="built_in">Find</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(!f) f=F[x]=x;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">Add</span>(f,<span class="number">-1</span>),F[f+c[rt[f]]]=f;</span><br><span class="line">		<span class="built_in">Upd</span>(rt[f],<span class="number">1</span>,n,y);</span><br><span class="line">		<span class="keyword">while</span>(x=<span class="built_in">Find</span>(x),y=<span class="built_in">Find</span>(x<span class="number">-1</span>)) &#123;</span><br><span class="line">			<span class="built_in">Add</span>(y,<span class="number">-1</span>);</span><br><span class="line">			F[x]=x<span class="number">-1</span>;</span><br><span class="line">			rt[y]=<span class="built_in">Union</span>(rt[y],rt[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(x=<span class="built_in">Find</span>(x),y=<span class="built_in">Find</span>(x+c[rt[x]])) &#123;</span><br><span class="line">			<span class="built_in">Add</span>(y,<span class="number">-1</span>);</span><br><span class="line">			F[x+c[rt[x]]]=x;</span><br><span class="line">			rt[x]=<span class="built_in">Union</span>(rt[x],rt[y]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Add</span>(x,<span class="number">1</span>),<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1061E%20-%20Politics/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1061E - Politics' date: 'Sat Aug 12 11:05:25 2023
categories: - oi-solutions'</p>
<h1 id="cf1061e---politics">CF1061E - Politics</h1>
<h3 id="题目大意">题目大意</h3>
<p>给定两棵有根树 <span class="math inline">\(T_1,T_2\)</span>
，节点均从 <span class="math inline">\(1-n\)</span> 编号</p>
<p>对于节点 <span class="math inline">\(i\)</span> ，有权值 <span
class="math inline">\(a_i\)</span> ，每个节点可以被选择一次</p>
<p>对于 <span class="math inline">\(T_1,T_2\)</span> ，有 <span
class="math inline">\(q_1,q_2\)</span> 条限制，每条限制了一个子树 <span
class="math inline">\(k\)</span> 内恰好有 <span
class="math inline">\(x\)</span> 个点被选择</p>
<p>求最大化选择的权值之和，或者确定不存在方案</p>
<p><br></p>
<h3 id="分析">分析</h3>
<p>如果剥离树的结构考虑，让问题变成点集之和的限制</p>
<p>这是一个经典的无法处理的问题<del>，或许可以单纯形试试看</del></p>
<p>那么考虑树的结构如何处理</p>
<p>我们认为一个点被选择会向祖先链上的点总和+1，这是一个链状更新</p>
<p>可以用一棵内向树描述，再将限制加在边上，就能够得到一个简单的网络流模型</p>
<p>然而边权无法限制满流（除非上下界网络流），而现在问题不仅带权，还同时涉及两棵树</p>
<p>因此引入费用是必须的</p>
<h4 id="解决恰好为-x-的限制">解决恰好为 <span
class="math inline">\(x\)</span> 的限制</h4>
<p>考虑将有限制的边视作特殊，我们将这条边额外加上一个费用 <span
class="math inline">\(\infty\)</span> ，最后从答案中减去</p>
<p>如果最优解中无法流满这些边，答案将 <span
class="math inline">\(&lt;0\)</span></p>
<p><br></p>
<h4 id="解决两棵树">解决两棵树</h4>
<p>Naive的思路，我们需要强制两棵树上同编号的点入流相同</p>
<p><del>经过长时间弱智的思考</del>，这无法实现</p>
<p>于是想办法强制两个点入流<strong>不同</strong></p>
<p>容易发现，对于被选个数的限制可以对称转化为限制未选个数</p>
<p>从源点 <span class="math inline">\(S\)</span> 向 <span
class="math inline">\(i_0\)</span> 连一条流量为1的边， <span
class="math inline">\(i_0\)</span> 流向 <span
class="math inline">\(i_1\)</span> 表示选择 <span
class="math inline">\(i\)</span> ，流向 <span
class="math inline">\(i_2\)</span> 表示不选</p>
<p>将 <span class="math inline">\(T_1\)</span> 建成选择点的限制， <span
class="math inline">\(T_2\)</span> 建成不选点的限制即可</p>
<p><br></p>
<p>形式化的说，对于一个费用流，我们想要限制两条边 <span
class="math inline">\(flow_1=flow_2\)</span></p>
<p>即 <span class="math inline">\(flow_1-flow_2=0\)</span>
，这难以做到</p>
<p>但是我们可以限制 <span
class="math inline">\(flow_1+(-flow_2)=0\)</span> ，或者说</p>
<p><span class="math inline">\(flow_1+(w-flow_2)=w\)</span></p>
<p>并且将对于 <span class="math inline">\(flow_2\)</span> 的限制转化为对
<span class="math inline">\(w-flow_2\)</span> 的限制，此时额外建立一个点
<span class="math inline">\(t\)</span></p>
<p><span class="math inline">\(S\)</span> 向 <span
class="math inline">\(t\)</span> 连 <span
class="math inline">\((w,\infty)\)</span> ，强制向 <span
class="math inline">\(t\)</span> 流满 <span
class="math inline">\(w\)</span> 的流量，然后再从 <span
class="math inline">\(t\)</span> 向 <span
class="math inline">\(flow_1,w-flow_2\)</span> 分流即可</p>
<p><br></p>
<p><span class="math inline">\(\text{EK}\)</span> 费用流 <img
src="https://i.loli.net/2021/05/06/zQSNb6mCwdJqFs3.jpg"
alt="QQ图片20210506190147.jpg" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt; Pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod1(x) ((x&gt;=P)&amp;&amp;(x-=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Mod2(x) ((x&lt;0)&amp;&amp;(x+=P))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a,i##end=b;i&lt;=i##end;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drep(i,a,b) for(int i=a,i##end=b;i&gt;=i##end;--i)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmin</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&gt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cmax</span><span class="params">(T &amp;a,T b)</span></span>&#123; ((a&lt;b)&amp;&amp;(a=b)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> IO;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>=<span class="type">int</span>&gt; T <span class="built_in">rd</span>()&#123;</span><br><span class="line">	T s=<span class="number">0</span>; <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>())) f|=IO==<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">	<span class="keyword">do</span> s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+(IO^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(IO=<span class="built_in">getchar</span>()));</span><br><span class="line">	<span class="keyword">return</span> f?-s:s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1544</span>,INF=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,d;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt,w,c;</span><br><span class="line">&#125; e[N*<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u],w,c&#125;;</span><br><span class="line">	head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> c)</span></span>&#123; <span class="built_in">AddEdge</span>(u,v,w,c),<span class="built_in">AddEdge</span>(v,u,<span class="number">0</span>,-c); &#125;</span><br><span class="line"><span class="type">int</span> S=<span class="number">1</span>,T=<span class="number">2</span>,V=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line">	<span class="type">int</span> Rt,sz[N],lim[N],fa[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;pre dfs &quot;&lt;&lt;u&lt;&lt;endl;</span></span><br><span class="line">		sz[u]=<span class="number">1</span>,lim[u]=<span class="number">-1</span>,fa[u]=f;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> v:G[u]) <span class="keyword">if</span>(v!=f) &#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">			sz[u]+=sz[v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReadTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">			<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>();</span><br><span class="line">			G[u].<span class="built_in">pb</span>(v),G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(Rt,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReadLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">rep</span>(_,<span class="number">1</span>,<span class="built_in">rd</span>()) &#123;</span><br><span class="line">			<span class="type">int</span> u=<span class="built_in">rd</span>(),x=<span class="built_in">rd</span>();</span><br><span class="line">			<span class="comment">//cout&lt;&lt;&quot; $&quot;&lt;&lt;sz[u]&lt;&lt;endl;</span></span><br><span class="line">			<span class="keyword">if</span>(sz[u]&lt;x) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			lim[u]=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">		fa[Rt]=T-V;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">				<span class="built_in">Link</span>(T+i,V+i,<span class="number">1</span>,a[i]);</span><br><span class="line">				<span class="keyword">if</span>(~lim[i]) &#123;</span><br><span class="line">					ans-=<span class="number">1ll</span>*lim[i]*INF;</span><br><span class="line">					<span class="built_in">Link</span>(V+i,V+fa[i],lim[i],INF);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="built_in">Link</span>(V+i,V+fa[i],n,<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">				<span class="built_in">Link</span>(T+i,V+i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span>(~lim[i]) &#123;</span><br><span class="line">					ans-=<span class="number">1ll</span>*(sz[i]-lim[i])*INF;</span><br><span class="line">					<span class="built_in">Link</span>(V+i,V+fa[i],sz[i]-lim[i],INF);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="built_in">Link</span>(V+i,V+fa[i],n,<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		V+=n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; Tr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="type">int</span> vis[N],pre[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> queue &lt;<span class="type">int</span>&gt; que;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,V) dis[i]=<span class="number">-1e18</span>;</span><br><span class="line">	que.<span class="built_in">push</span>(S),dis[S]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> u=que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">		vis[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].to,c=e[i].c;</span><br><span class="line">			<span class="keyword">if</span>(dis[v]&gt;=dis[u]+c || !e[i].w) <span class="keyword">continue</span>;</span><br><span class="line">			dis[v]=dis[u]+e[i].c,pre[v]=i;</span><br><span class="line">			<span class="comment">//cout&lt;&lt;&quot;$ &quot;&lt;&lt;u&lt;&lt;&#x27; &#x27;&lt;&lt;v&lt;&lt;&#x27; &#x27;&lt;&lt;e[i].c&lt;&lt;&#x27; &#x27;&lt;&lt;e[i].w&lt;&lt;endl;</span></span><br><span class="line">			<span class="keyword">if</span>(!vis[v]) vis[v]=<span class="number">1</span>,que.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis[T]&gt;<span class="number">-1e18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EK</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">SPFA</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> w=INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u=T;pre[u];u=e[pre[u]^<span class="number">1</span>].to) <span class="built_in">cmin</span>(w,e[pre[u]].w);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u=T;pre[u];u=e[pre[u]^<span class="number">1</span>].to) e[pre[u]].w-=w,e[pre[u]^<span class="number">1</span>].w+=w;</span><br><span class="line">		ans+=w*dis[T];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),Tr[<span class="number">0</span>].Rt=<span class="built_in">rd</span>(),Tr[<span class="number">1</span>].Rt=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">Link</span>(S,V+i,<span class="number">1</span>,INF),ans-=INF;</span><br><span class="line">	V+=n;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>) Tr[i].<span class="built_in">ReadTree</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>) Tr[i].<span class="built_in">ReadLimit</span>(),Tr[i].<span class="built_in">Init</span>(i);</span><br><span class="line">	<span class="built_in">EK</span>();</span><br><span class="line">	<span class="keyword">if</span>(ans&lt;<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1067D%20-%20Computer%20Game/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1067D - Computer Game' date: 'Sat Aug 12 11:05:25 2023
categories: - oi-solutions'</p>
<h1 id="cf1067d---computer-game">CF1067D - Computer Game</h1>
<h3 id="题目大意">题目大意</h3>
<p>给定 <span class="math inline">\(n\)</span>
个操作，每个操作有1级和2级分别对应价值 <span
class="math inline">\(a_i,b_i (a_i&lt;b_i)\)</span> ，初始每个操作为
<span class="math inline">\(1\)</span> 级</p>
<p>每次操作 <span class="math inline">\(i\)</span> ，有 <span
class="math inline">\(p_i\)</span>
概率操作成功，这会获得价值，并且获得一次升级的机会</p>
<p>求 <span class="math inline">\(t\)</span> 次操作的期望最大权值和</p>
<p><br></p>
<h3 id="分析">分析</h3>
<p>容易发现，当你拿到一次升级后，一定就一直选择 <span
class="math inline">\(\max\{p_i\cdot b_i\}\)</span> 进行操作</p>
<p>并且每次期望获得这么多的权值，不妨设 <span
class="math inline">\(m=\max\{p_i\cdot b_i\}\)</span></p>
<p>需要决策的是拿到这个权值之前，选择哪一个操作</p>
<p>设 <span class="math inline">\(dp_i\)</span> 表示有 <span
class="math inline">\(i\)</span> 次操作机会时的期望答案，则得到 <span
class="math inline">\(dp\)</span> 转移式子</p>
<p><span class="math inline">\(\displaystyle dp_i=\max_{j\leq n}\{
p_j((i-1)m+a_j)+(1-p_j)dp_{i-1} \}\)</span></p>
<p>考虑这是一个斜率优化的形式，我们做一下变形</p>
<p><span class="math inline">\(dp_i=\max\{ p_j((i-1)m-dp_{i-1})
+dp_{i-1}+p_ja_j\}\)</span></p>
<p>可以看到斜率优化与 <span
class="math inline">\((i-1)m-dp_{i-1}\)</span> 有关，设 <span
class="math inline">\(g_i=im-dp_{i}\)</span></p>
<p>则问题可以转化为求 <span
class="math inline">\((g_t)_{\min}\)</span></p>
<p>转化之后得到 <span class="math inline">\(g_i\)</span> 的转移式</p>
<p><span class="math inline">\(\displaystyle g_{i}=\min_{j\leq n}
\{g_{i-1} (1-p_j)+m-a_jp_j\}\)</span></p>
<p>容易发现这样的转移相较于 <span class="math inline">\(dp_i\)</span>
，脱离了 <span class="math inline">\(im\)</span> 的问题</p>
<p>不妨对于 <span class="math inline">\((1-p_j,m-a_jp_j)\)</span>
建立凸包，则转移可以斜率优化</p>
<p>现在考虑 <span class="math inline">\(g_i\)</span>
的单调性，根据定义式我们可以感性地理解 <span
class="math inline">\(g_i\)</span> 是递增的（因为 <span
class="math inline">\(dp_i\)</span> 增率不可能超过 <span
class="math inline">\(m\)</span> ）</p>
<p><del>（事实上我并不知道怎么根据转移式说明它是单调的）</del></p>
<p>既然是 <span class="math inline">\(g_i\)</span>
是单调，那么转移在凸包上的位置也是单调的，因此可以直接在凸包上移动决策点</p>
<p>倍增|二分完成操作</p>
<p>复杂度为 <span class="math inline">\(O(n(\log n+\log t))\)</span> 或
<span class="math inline">\(O(n(\log n+\log^2 t))\)</span></p>
<h3 id="吐槽">吐槽</h3>
<p>Codeforces上写double ,long double真的磨人</p>
<p>还有一群疯子构造数据把两个点的 <span
class="math inline">\(x_i,y_i\)</span> 相差 <span
class="math inline">\(10^{-9}\)</span></p>
<p><del>什么玩意儿</del>，搞得我把 <span
class="math inline">\(\text{eps}\)</span> 开成 <span
class="math inline">\(10^{-20}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; ll k;</span><br><span class="line">db m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	db x,y;</span><br><span class="line">	<span class="built_in">Node</span>(db x=<span class="number">0</span>,db y=<span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node __) <span class="type">const</span> &#123; <span class="keyword">return</span> x&lt;__.x-eps || (<span class="built_in">fabs</span>(x-__.x)&lt;eps &amp;&amp; y&gt;__.y); &#125;</span><br><span class="line">	Node <span class="keyword">operator</span> - (<span class="type">const</span> Node _) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">Node</span>(x-_.x,y-_.y); &#125;</span><br><span class="line">	db <span class="keyword">operator</span> ^ (<span class="type">const</span> Node _) <span class="type">const</span> &#123; <span class="keyword">return</span> x*_.y-y*_.x; &#125;</span><br><span class="line">	db <span class="keyword">operator</span> [] (<span class="type">const</span> db k)&#123; <span class="keyword">return</span> k*x+y; &#125;</span><br><span class="line">	Node <span class="keyword">operator</span> * (<span class="type">const</span> Node _) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Node</span>(x*_.x,_.x*y+_.y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; A[N],S[N],Pow[<span class="number">35</span>];</span><br><span class="line"><span class="function">db <span class="title">Cross</span><span class="params">(Node a,Node b)</span></span>&#123; <span class="keyword">return</span> (b.y-a.y)/(a.x-b.x); &#125;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>&lt;ll&gt;();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		db a=<span class="built_in">rd</span>(),b=<span class="built_in">rd</span>(),p;<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;p);</span><br><span class="line">		<span class="built_in">cmax</span>(m,p*b),A[i]=<span class="built_in">Node</span>(<span class="number">1</span>-p,a*p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) A[i].y=m-A[i].y;</span><br><span class="line">	<span class="built_in">sort</span>(A+<span class="number">1</span>,A+n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		<span class="keyword">while</span>(T&gt;<span class="number">1</span> &amp;&amp; ((A[i]-S[T])^(S[T<span class="number">-1</span>]-S[T]))&lt;eps) T--;</span><br><span class="line">		S[++T]=A[i];</span><br><span class="line">	&#125;</span><br><span class="line">	db g=<span class="number">0</span>,s=k*m;</span><br><span class="line">	S[<span class="number">0</span>].y=<span class="number">1e40</span>;</span><br><span class="line">	<span class="keyword">while</span>(k) &#123;</span><br><span class="line">		<span class="keyword">while</span>(T&gt;<span class="number">1</span> &amp;&amp; S[T<span class="number">-1</span>][g]&lt;=S[T][g]+eps) T--;</span><br><span class="line">		Pow[<span class="number">0</span>]=S[T];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1ll</span>&lt;&lt;i)&lt;=k;++i) Pow[i]=Pow[i<span class="number">-1</span>]*Pow[i<span class="number">-1</span>];</span><br><span class="line">		<span class="built_in">drep</span>(i,<span class="number">34</span>,<span class="number">0</span>) <span class="keyword">if</span>((<span class="number">1ll</span>&lt;&lt;i)&lt;=k &amp;&amp; S[T<span class="number">-1</span>][Pow[i][g]]&gt;=S[T][Pow[i][g]]+eps) k-=<span class="number">1ll</span>&lt;&lt;i,g=Pow[i][g];</span><br><span class="line">		<span class="keyword">if</span>(k &amp;&amp; S[T<span class="number">-1</span>][g]&gt;=S[T][g]+eps) k--,g=Pow[<span class="number">0</span>][g];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>,s-g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1082F%20-%20Speed%20Dial/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1082F - Speed Dial' date: 'Sat Aug 12 11:05:25 2023
categories: - oi-solutions'</p>
<h1 id="cf1082f---speed-dial">CF1082F - Speed Dial</h1>
<h3 id="题目大意">题目大意</h3>
<p>给定 <span class="math inline">\(n\)</span>
个电话号码，你可以随意生成 <span class="math inline">\(k\)</span>
个快捷键，每个快捷键是一个数字串</p>
<p>最终拨号方式：</p>
<p>选择 <strong>至多一个</strong>
快捷键按下，对于剩余部分手动补全，且不允许退格</p>
<p>每个电话号码有拨打次数，最小化手动补全部分的长度总和</p>
<p><br></p>
<h3 id="分析">分析</h3>
<p>如果每次选定一个集合使其公用一个快捷键，那么其长度必然是集合中所有串的
<span class="math inline">\(\text{LCP}\)</span></p>
<p>假设确定了一个 <span class="math inline">\(\text{LCP}\)</span>
，那么对应的串集合容易发现就是 <span
class="math inline">\(\text{trie}\)</span> 树上的一个子树</p>
<p>于是先将所有串加入 <span class="math inline">\(\text{trie}\)</span>
树，此时问题转化为</p>
<p>选择至多 <span class="math inline">\(k\)</span> 个 <span
class="math inline">\(\text{LCP}\)</span>
（默认根节点选了且没有代价），使得每个电话号码到其祖先中最深 <span
class="math inline">\(\text{LCP}\)</span> 的距离之和最小</p>
<p>由于有拨打次数的限制，且其数值相对较大，难以存入dp状态</p>
<p>于是想到在祖先钦定 <span class="math inline">\(\text{LCP}\)</span>
，然后从子树取值</p>
<p>令 <span class="math inline">\(dp_{u,i,j}\)</span> 表示计算 <span
class="math inline">\(u\)</span> 子树内的答案，已经钦定祖先中最深的
<span class="math inline">\(\text{LCP}\)</span> 长度为 <span
class="math inline">\(i\)</span> ，且在子树内又钦定了 <span
class="math inline">\(j\)</span> 个 <span
class="math inline">\(\text{LCP}\)</span></p>
<p>合并子树时对于每个 <span class="math inline">\(i\)</span> ，背包合并
<span class="math inline">\(j\)</span> ，决策 <span
class="math inline">\(u\)</span> 自己是否选为 <span
class="math inline">\(\text{LCP}\)</span> 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> trie[N][<span class="number">10</span>],cnt,c[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> dp[N][N][<span class="number">12</span>];</span><br><span class="line"><span class="type">int</span> F[N][<span class="number">12</span>],G[<span class="number">12</span>],dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:trie[u]) <span class="keyword">if</span>(v) dep[v]=dep[u]+<span class="number">1</span>,<span class="built_in">dfs</span>(v);</span><br><span class="line">	<span class="built_in">memset</span>(F,<span class="number">63</span>,<span class="keyword">sizeof</span> F);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,dep[u]) F[i][<span class="number">0</span>]=c[u]*(dep[u]-i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:trie[u]) <span class="keyword">if</span>(v) &#123;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,dep[u]) &#123;</span><br><span class="line">			<span class="built_in">rep</span>(k,<span class="number">0</span>,m) G[k]=F[j][k],F[j][k]=INF;</span><br><span class="line">			<span class="built_in">rep</span>(k,<span class="number">0</span>,m) <span class="built_in">rep</span>(d,<span class="number">0</span>,m-k) <span class="built_in">cmin</span>(F[j][k+d],G[k]+dp[v][j][d]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(d,<span class="number">0</span>,dep[u]) &#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,m) dp[u][d][i]=INF;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,m) &#123;</span><br><span class="line">			<span class="built_in">cmin</span>(dp[u][d][i+<span class="number">1</span>],F[dep[u]][i]);</span><br><span class="line">			<span class="built_in">cmin</span>(dp[u][d][i],F[d][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;s[j];++j) &#123;</span><br><span class="line">			<span class="type">int</span> &amp;v=trie[u][s[j]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">			<span class="keyword">if</span>(!v) v=++cnt;</span><br><span class="line">			u=v;</span><br><span class="line">		&#125;</span><br><span class="line">		c[u]+=<span class="built_in">rd</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> ans=INF;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,m) <span class="built_in">cmin</span>(ans,dp[<span class="number">0</span>][<span class="number">0</span>][i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1111E%20-%20Tree/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1111E - Tree' date: 'Sat Aug 12 11:05:25 2023 categories: -
oi-solutions'</p>
<h1 id="cf1111e---tree">CF1111E - Tree</h1>
<h3 id="题目大意">题目大意</h3>
<p>给定一棵无根树 <span class="math inline">\(T\)</span> ， <span
class="math inline">\(q\)</span> 次查询每次查询一个给定一个根 <span
class="math inline">\(r\)</span> ，点集 <span
class="math inline">\(S\)</span> 和限制 <span
class="math inline">\(m\)</span></p>
<p>求将 <span class="math inline">\(S\)</span> 分成不超过 <span
class="math inline">\(m\)</span>
个非空集合，使得最终每个集合内不存在两点为祖先关系</p>
<p><br></p>
<h3 id="分析">分析</h3>
<p>容易发现题目是一个给定部分点集的树形 <span
class="math inline">\(dp\)</span> ，因此需要用虚树来处理</p>
<p>将 <span class="math inline">\(r\)</span> 也加入虚树，从 <span
class="math inline">\(r\)</span> 开始 <span
class="math inline">\(\text{dfs}\)</span> 即确定了根为 <span
class="math inline">\(r\)</span></p>
<h3 id="dp部分">dp部分</h3>
<p>一种思路是树形背包，计算子树内分为 <span
class="math inline">\(i\)</span> 个集合的方案数，枚举在 <span
class="math inline">\(\text{LCA}\)</span> 处合并两个集合</p>
<p>但是由于要枚举合并的个数，难以写出优秀的复杂度</p>
<p>由于一条祖先链上点之间的集合独立，容易描述，因此可以考虑 <span
class="math inline">\(\text{dfs}\)</span> 序dp</p>
<p>按照 <span class="math inline">\(\text{dfs}\)</span> 依次加入每一个点
<span class="math inline">\(u\)</span> ，令 <span
class="math inline">\(dp_i\)</span> 表示当前有 <span
class="math inline">\(i\)</span> 个集合的方案数</p>
<p>则在 <span class="math inline">\(i\)</span> 个集合中包含 <span
class="math inline">\(dep_u\)</span> 个集合 <span
class="math inline">\(u\)</span> 无法加入</p>
<p>枚举 <span class="math inline">\(i\)</span> ，加入一个点 <span
class="math inline">\(O(m)\)</span> 转移，滚动数组即可</p>
<p>复杂度为 <span class="math inline">\(O(n\log n+\sum |S|\cdot
m)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> L[N],top[N],son[N],sz[N],dfn,fa[N],dep[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">&#125; e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	sz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt) &#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v==fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">		dep[v]=dep[fa[v]=u]+<span class="number">1</span>,<span class="built_in">dfs</span>(v);</span><br><span class="line">		<span class="keyword">if</span>(sz[v]&gt;sz[son[u]]) son[u]=v;</span><br><span class="line">		sz[u]+=sz[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	top[u]=t,L[u]=++dfn;</span><br><span class="line">	<span class="keyword">if</span>(son[u]) <span class="built_in">dfs</span>(son[u],t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt) &#123;</span><br><span class="line">		<span class="type">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v==son[u] || v==fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v,v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y]) dep[top[x]]&gt;dep[top[y]]?x=fa[top[x]]:y=fa[top[y]];</span><br><span class="line">	<span class="keyword">return</span> dep[x]&lt;dep[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> stk[N],T;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123; G[u].<span class="built_in">pb</span>(v),G[v].<span class="built_in">pb</span>(u); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ins</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">void</span>(stk[++T]=u);</span><br><span class="line">	<span class="type">int</span> lca=<span class="built_in">LCA</span>(u,stk[T]);</span><br><span class="line">	<span class="keyword">if</span>(lca==stk[T]) <span class="keyword">return</span> <span class="built_in">void</span>(stk[++T]=u);</span><br><span class="line">	<span class="keyword">while</span>(T&gt;<span class="number">1</span> &amp;&amp; L[stk[T<span class="number">-1</span>]]&gt;=L[lca]) <span class="built_in">Link</span>(stk[T],stk[T<span class="number">-1</span>]),T--;</span><br><span class="line">	<span class="keyword">if</span>(stk[T]!=lca) <span class="built_in">Link</span>(stk[T],lca),stk[T]=lca;</span><br><span class="line">	stk[++T]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[N],mk[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">310</span>],a[N],c,rt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	dis[u]=dis[f]+mk[u];</span><br><span class="line">	<span class="keyword">if</span>(mk[u]) <span class="built_in">drep</span>(i,m,<span class="number">0</span>) dp[i]=((i?dp[i<span class="number">-1</span>]:<span class="number">0</span>)+<span class="number">1ll</span>*(i-dis[f])*dp[i])%P;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:G[u]) <span class="keyword">if</span>(v!=f) <span class="built_in">dfs_dp</span>(v,u);</span><br><span class="line">	mk[u]=<span class="number">0</span>,G[u].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">AddEdge</span>(u,v),<span class="built_in">AddEdge</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>),<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(_,<span class="number">1</span>,m) &#123;</span><br><span class="line">		c=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),rt=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,c) mk[a[i]=<span class="built_in">rd</span>()]=<span class="number">1</span>;</span><br><span class="line">		a[++c]=<span class="number">1</span>,a[++c]=rt;</span><br><span class="line">		<span class="built_in">sort</span>(a+<span class="number">1</span>,a+c+<span class="number">1</span>,[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123; <span class="keyword">return</span> L[x]&lt;L[y]; &#125;);</span><br><span class="line">		T=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,c) <span class="keyword">if</span>(a[i]!=a[i<span class="number">-1</span>]) <span class="built_in">Ins</span>(a[i]);</span><br><span class="line">		<span class="keyword">while</span>(T&gt;<span class="number">1</span>) <span class="built_in">Link</span>(stk[T<span class="number">-1</span>],stk[T]),T--;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,m) dp[i]=<span class="number">0</span>;</span><br><span class="line">		dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs_dp</span>(rt,<span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,m) ans+=dp[i],<span class="built_in">Mod1</span>(ans);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1119F%20-%20Niyaz%20and%20Small%20Degrees/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1119F - Niyaz and Small Degrees' date: 'Sat Aug 12 11:05:25
2023 categories: - oi-solutions'</p>
<h1 id="cf1119f---niyaz-and-small-degrees">CF1119F - Niyaz and Small
Degrees</h1>
<h2 id="题目大意">题目大意</h2>
<p>给定一棵带权树，对于每个 <span
class="math inline">\(k\in[0,n-1]\)</span></p>
<p>求出删除一个权值最小的边集使得没有一个点度数 <span
class="math inline">\(&gt;k\)</span></p>
<p><br></p>
<h2 id="分析">分析</h2>
<h3 id="单个-k">单个 <span class="math inline">\(k\)</span></h3>
<p>考虑对于单个 <span class="math inline">\(k\)</span>
的计算，可以有如下 <span class="math inline">\(O(n)\)</span> 的 <span
class="math inline">\(dp\)</span> 做法</p>
<p>令 <span class="math inline">\(dp_{u,0/1}\)</span> 表示对于 <span
class="math inline">\(u\)</span> 子树内的点已经确定合法， <span
class="math inline">\(0/1\)</span> 表示连向父亲的边是否断掉</p>
<p>实际上我们需要在连向儿子的边中选择若干条断掉</p>
<p>也就是取若干 <span class="math inline">\(v\in son_u,dp_{v,1}\)</span>
和若干 <span class="math inline">\(dp_{v,0}\)</span></p>
<p>实际上只需要考虑 <span
class="math inline">\(dp_{v,1}-dp_{v,0}\)</span> 差值的前 <span
class="math inline">\(d\)</span> 小，其中 <span
class="math inline">\(d=deg_u-k(-1)\)</span></p>
<p>用<code>std::nth_element</code>即可实现 <span
class="math inline">\(O(n)\)</span> 计算</p>
<p><br></p>
<h3 id="所有-k">所有 <span class="math inline">\(k\)</span></h3>
<p>考虑对于 <span class="math inline">\(k\)</span> ，只有 <span
class="math inline">\(deg_u&gt;k\)</span> 的 <span
class="math inline">\(u\)</span> 才会考虑对于它周围的边删除</p>
<p>我们称对于 <span class="math inline">\(k\)</span> 这样的节点 <span
class="math inline">\(u\)</span> 为关键点，其集合为 <span
class="math inline">\(S_k\)</span></p>
<p>换句话说， <span class="math inline">\(u\)</span> 只有在 <span
class="math inline">\(k\in[0,deg_u-1]\)</span> 的 <span
class="math inline">\(deg_u\)</span> 的 <span
class="math inline">\(k\)</span> 中被计算答案</p>
<p>而又知道 <span class="math inline">\(\sum deg_u=2n-2\)</span>
，故对于所有 <span class="math inline">\(k\)</span>
考虑关键点的数量之和为 <span class="math inline">\(O(n)\)</span></p>
<p>但是实际实现上，因为这样的 <span class="math inline">\(u\)</span>
构成若干联通子图，且那些与关键点所连的非关键点需要处理边的贡献</p>
<p>显然一个非关键点 <span
class="math inline">\(dp_{v,0}=0,dp_{v,1}=w_v\)</span> ， <span
class="math inline">\(w_v\)</span> 为父边权值</p>
<p>我们需要在 <span class="math inline">\(\{w_v|v\in
son_u-S_k\}\)</span> 和 <span
class="math inline">\(\{dp_{v,1}-dp_{v,0}|v\in son_u\cap S_k\}\)</span>
中取前 <span class="math inline">\(d\)</span> 小，可以用线段树 <span
class="math inline">\(O(n\log n)\)</span> 维护</p>
<p>如果使用基数排序+链表+懒标记做删除和 <span
class="math inline">\(k\)</span> 大操作，查询 <span
class="math inline">\(k\)</span> 大部分复杂度为 <span
class="math inline">\(O(n)\)</span> ，但是还是要sort <span
class="math inline">\(dp_{v,1}-dp_{v,0}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2.5e5</span>+<span class="number">10</span>,U=<span class="number">1e6</span>,M=N*<span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> A[N],C,D[N];</span><br><span class="line">vector &lt;Pii&gt; E[N],G[N];</span><br><span class="line"><span class="type">int</span> I[N],V[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt[N],ls[M],rs[M],c[M],cnt; ll s[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Upd</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p) p=++cnt;</span><br><span class="line">	s[p]+=x*y,c[p]+=y;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	x&lt;=mid?<span class="built_in">Upd</span>(ls[p],l,mid,x,y):<span class="built_in">Upd</span>(rs[p],mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Que</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c[p]&lt;k) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line">	<span class="keyword">if</span>(!k || l==r) <span class="keyword">return</span> l*k;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(c[ls[p]]&gt;=k) <span class="keyword">return</span> <span class="built_in">Que</span>(ls[p],l,mid,k);</span><br><span class="line">	<span class="keyword">return</span> s[ls[p]]+<span class="built_in">Que</span>(rs[p],mid+<span class="number">1</span>,r,k-c[ls[p]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	dp[u][<span class="number">0</span>]=dp[u][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	vector &lt;ll&gt; val;</span><br><span class="line">	<span class="type">int</span> c=<span class="number">0</span>; ll s=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(Pii t:G[u]) &#123;</span><br><span class="line">		<span class="type">int</span> v=t.first,w=t.second;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">		dp[v][<span class="number">1</span>]+=w,s+=dp[v][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span>(dp[v][<span class="number">1</span>]&lt;=dp[v][<span class="number">0</span>]) c++,s+=dp[v][<span class="number">1</span>]-dp[v][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> val.<span class="built_in">pb</span>(dp[v][<span class="number">1</span>]-dp[v][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(val.<span class="built_in">begin</span>(),val.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// Get the sum of first k elements</span></span><br><span class="line">	<span class="keyword">auto</span> F=[&amp;](<span class="type">int</span> k) &#123;</span><br><span class="line">		ll ans=<span class="built_in">Que</span>(rt[u],<span class="number">1</span>,U,k),s=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(ll i:val) &#123;</span><br><span class="line">			<span class="keyword">if</span>(--k&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			<span class="built_in">cmin</span>(ans,(s+=i)+<span class="built_in">Que</span>(rt[u],<span class="number">1</span>,U,k));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;;</span><br><span class="line">	dp[u][<span class="number">0</span>]=s+<span class="built_in">F</span>(<span class="built_in">max</span>(<span class="number">0</span>,D[u]-c-m));</span><br><span class="line">	dp[u][<span class="number">1</span>]=s+<span class="built_in">F</span>(<span class="built_in">max</span>(<span class="number">0</span>,D[u]-c<span class="number">-1</span>-m));</span><br><span class="line">	<span class="comment">//cout&lt;&lt;&quot;Dfs &quot;&lt;&lt;u&lt;&lt;&#x27; &#x27;&lt;&lt;dp[u][0]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[u][1]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,n) &#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>(),w=<span class="built_in">rd</span>();</span><br><span class="line">		ans[<span class="number">0</span>]+=w;</span><br><span class="line">		E[u].<span class="built_in">pb</span>(<span class="built_in">mp</span>(v,w)),E[v].<span class="built_in">pb</span>(<span class="built_in">mp</span>(u,w));</span><br><span class="line">		<span class="built_in">Upd</span>(rt[u],<span class="number">1</span>,U,w,<span class="number">1</span>),<span class="built_in">Upd</span>(rt[v],<span class="number">1</span>,U,w,<span class="number">1</span>);</span><br><span class="line">		D[u]++,D[v]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) I[i]=i;</span><br><span class="line">	<span class="built_in">sort</span>(I+<span class="number">1</span>,I+n+<span class="number">1</span>,[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123; <span class="keyword">return</span> D[x]&gt;D[y]; &#125;);</span><br><span class="line">	<span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(m=n<span class="number">-1</span>;m;m--) &#123;</span><br><span class="line">		<span class="comment">//printf(&quot;Solving %d \n&quot;,m);</span></span><br><span class="line">		<span class="keyword">while</span>(p &amp;&amp; D[I[p]]&gt;m) &#123;</span><br><span class="line">			<span class="type">int</span> u=I[p++];</span><br><span class="line">			V[A[++C]=u]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(Pii v:E[u]) <span class="keyword">if</span>(V[v.first]) &#123;</span><br><span class="line">				<span class="built_in">Upd</span>(rt[u],<span class="number">1</span>,U,v.second,<span class="number">-1</span>),<span class="built_in">Upd</span>(rt[v.first],<span class="number">1</span>,U,v.second,<span class="number">-1</span>);</span><br><span class="line">				G[u].<span class="built_in">pb</span>(v),G[v.first].<span class="built_in">pb</span>(<span class="built_in">mp</span>(u,v.second));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,C) vis[A[i]]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,C) <span class="keyword">if</span>(!vis[A[i]]) <span class="built_in">dfs</span>(A[i]),ans[m]+=dp[A[i]][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1175G%20-%20Yet%20Another%20Partiton%20Problem/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1175G - Yet Another Partiton Problem' date: 'Sat Aug 12
11:05:25 2023 categories: - oi-solutions'</p>
<h1 id="cf1175g---yet-another-partiton-problem">CF1175G - Yet Another
Partiton Problem</h1>
<h3 id="题目大意">题目大意</h3>
<p>给定序列 <span class="math inline">\(a_i\)</span> ，现在将其分成
<span class="math inline">\(k\)</span> 段，每段 <span
class="math inline">\([l,r]\)</span> 的权值定义为 <span
class="math inline">\((r-l+1)\max\{a_{l..r}\}\)</span></p>
<p>求最小化权值总和</p>
<p><br></p>
<h3 id="分析">分析</h3>
<p>显然有 <span class="math inline">\(\mathbb{Naive}\)</span> 的 <span
class="math inline">\(dp\)</span></p>
<p><span class="math inline">\(dp_{i,j}\)</span> 表示前 <span
class="math inline">\(i\)</span> 个分了 <span
class="math inline">\(j\)</span> 段的答案，直接做复杂度为 <span
class="math inline">\(O(n^2k)\)</span></p>
<p>优化它有几种常见思路：</p>
<p>1.贪心简化决策</p>
<p>设每个段最大值 <span class="math inline">\(b_i\)</span>
，则一个段不能向左边扩展的条件是</p>
<p>两端的 <span class="math inline">\(b_{i-1}&lt;b_i\)</span>
（扩展会亏），或者 <span class="math inline">\(a_{l_i-1}&gt;b_i\)</span>
（扩展会改变 <span class="math inline">\(b_i\)</span> ）</p>
<p>这样能稍微限制一下转移，然而并不好优化</p>
<p>2.决策单调性</p>
<p>枚举区间进行决策的问题通常具有单调性</p>
<p>于是尝试通过分治决策单调性优化到 <span class="math inline">\(O(nk\log
n)\)</span></p>
<p><del>然而已经被垃圾数据击毙</del> 尝试证明这是假的</p>
<p>3.斜率优化</p>
<p>考虑确定 <span class="math inline">\(\max a_i\)</span> 之后，两侧
<span class="math inline">\(r-l+1\)</span>
就是一个斜率优化的转移形式</p>
<p>考虑如何实现这个斜率优化</p>
<p>首先将 <span class="math inline">\(dp_{i,j}\)</span>
两个维护交换，按照分段数一层层进行转移</p>
<p>每一层，可以考虑在 <span class="math inline">\(a_i\)</span>
的笛卡尔树上进行转移</p>
<p>每次考虑所有跨过当前节点的转移区间</p>
<p>那么就要支持：</p>
<p>1.查询左子树 <span class="math inline">\(dp_l-l \cdot a_u\)</span>
的最小值</p>
<p>2.更新右子树 <span class="math inline">\(dp&#39;_r+r\cdot
a_u\)</span> 的最小值</p>
<p><br></p>
<h4 id="option1">option1</h4>
<p>为了实现1操作，容易想到从子树中合并凸包，或者直接进行区间凸包查询</p>
<p>合并凸包的问题可以暴力李超树合并维护</p>
<p>但事实上区间凸包是可以维护的，方法如下</p>
<p>1.维护一个静态线段树， <span class="math inline">\(O(n\log
n)\)</span> 归并预处理凸包</p>
<p>2.查询 <span class="math inline">\(a_u\)</span>
递增，具有单调性，可以在每个被查询节点上处理一个指针</p>
<p>复杂度为就是均摊 <span class="math inline">\(O(n\log n)\)</span></p>
<p><br></p>
<h4 id="option2">option2</h4>
<p>子树更新答案，可以通过可持久化李超树|李超树区间修改实现</p>
<p>复杂度分别为 <span class="math inline">\(O(n\log
n),O(n\log^2n)\)</span> ，鉴于区间修改常数不满，差别不会太大</p>
<p>但实际上也可以通过朴素凸包实现：</p>
<p>从根开始dfs，每次插入一个 <span class="math inline">\(x+y \cdot
i\)</span> 的线段形式</p>
<p><span class="math inline">\(y\)</span>
是递增的，插入具有单调性，可以维护一个栈凸包</p>
<p>每次二分弹掉节点，插入自己</p>
<p>（不能直接弹，因为要支持回撤，会使得原先是均摊 <span
class="math inline">\(O(n)\)</span> 的弹栈操作退化为 <span
class="math inline">\(O(n^2)\)</span> ）</p>
<p>查询也可以通过二分解决（这实际上是一个经典树上斜率优化问题）</p>
<p><br></p>
<p><br></p>
<p>我当然写了李超树啦</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>,U=<span class="number">2e4</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,A[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	ll k,b;</span><br><span class="line">	<span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Node</span>(ll k,ll b):<span class="built_in">k</span>(k),<span class="built_in">b</span>(b)&#123;&#125;</span><br><span class="line">	ll <span class="keyword">operator</span> [] (ll x) <span class="type">const</span> &#123; <span class="keyword">return</span> k*x+b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> M=N*<span class="number">20</span>;</span><br><span class="line">	Node s[M];</span><br><span class="line">	<span class="type">int</span> ls[M],rs[M],cnt;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> u=++cnt;</span><br><span class="line">		ls[u]=rs[u]=<span class="number">0</span>,s[u]=<span class="built_in">Node</span>(INF,INF);</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Upd</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr,Node x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x.k==INF) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(!p) p=<span class="built_in">New</span>();</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;</span><br><span class="line">			<span class="keyword">if</span>(x[mid]&lt;s[p][mid]) <span class="built_in">swap</span>(s[p],x);</span><br><span class="line">			<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span>(x[l]&lt;s[p][l]) <span class="built_in">Upd</span>(ls[p],l,mid,ql,qr,x);</span><br><span class="line">			<span class="keyword">if</span>(x[r]&lt;s[p][r]) <span class="built_in">Upd</span>(rs[p],mid+<span class="number">1</span>,r,ql,qr,x);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ql&lt;=mid) <span class="built_in">Upd</span>(ls[p],l,mid,ql,qr,x);</span><br><span class="line">		<span class="keyword">if</span>(qr&gt;mid) <span class="built_in">Upd</span>(rs[p],mid+<span class="number">1</span>,r,ql,qr,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">Que</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!p) <span class="keyword">return</span> INF;	</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> s[p][x];</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(s[p][x],x&lt;=mid?<span class="built_in">Que</span>(ls[p],l,mid,x):<span class="built_in">Que</span>(rs[p],mid+<span class="number">1</span>,r,x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x|y;</span><br><span class="line">		<span class="built_in">Upd</span>(x,l,r,l,r,s[y]);</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		ls[x]=<span class="built_in">Union</span>(ls[x],ls[y],l,mid),rs[x]=<span class="built_in">Union</span>(rs[x],rs[y],mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; X,Y;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ls[N],rs[N],stk[N],top,mk[N];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt[N],Rt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">Solve</span>(k,ls[u],l,u<span class="number">-1</span>),<span class="built_in">Solve</span>(k,rs[u],u+<span class="number">1</span>,r);</span><br><span class="line">	rt[u]=rt[ls[u]];</span><br><span class="line">	<span class="keyword">if</span>(u&gt;<span class="number">1</span>) X.<span class="built_in">Upd</span>(rt[u],<span class="number">1</span>,U,<span class="number">1</span>,U,<span class="built_in">Node</span>(-(u<span class="number">-1</span>),dp[k][u<span class="number">-1</span>]));</span><br><span class="line">	<span class="type">int</span> res=X.<span class="built_in">Que</span>(rt[u],<span class="number">1</span>,U,A[u]);</span><br><span class="line">	Y.<span class="built_in">Upd</span>(Rt,<span class="number">1</span>,n,u,r,<span class="built_in">Node</span>(A[u],res));</span><br><span class="line">	rt[u]=X.<span class="built_in">Union</span>(rt[u],rt[rs[u]],<span class="number">1</span>,U);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	X.s[<span class="number">0</span>]=Y.s[<span class="number">0</span>]=<span class="built_in">Node</span>(INF,INF);</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) &#123;</span><br><span class="line">		A[i]=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="keyword">while</span>(top &amp;&amp; A[stk[top]]&lt;A[i]) ls[i]=stk[top--];</span><br><span class="line">		<span class="keyword">if</span>(top) rs[stk[top]]=i;</span><br><span class="line">		stk[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) mk[ls[i]]=mk[rs[i]]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> rt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!mk[i]) rt=i;</span><br><span class="line">	<span class="type">int</span> ma=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) <span class="built_in">cmax</span>(ma,A[i]),dp[<span class="number">1</span>][i]=ma*i;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) &#123;</span><br><span class="line">		X.cnt=<span class="number">0</span>,Y.cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">Solve</span>(i,rt,<span class="number">1</span>,n);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,n) dp[i+<span class="number">1</span>][j]=Y.<span class="built_in">Que</span>(<span class="number">1</span>,<span class="number">1</span>,n,j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[m][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1187G%20-%20Gang%20Up/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1187G - Gang Up' date: 'Sat Aug 12 11:05:25 2023
categories: - oi-solutions'</p>
<h1 id="cf1187g---gang-up">CF1187G - Gang Up</h1>
<h3 id="题目大意">题目大意</h3>
<p>有 <span class="math inline">\(k\)</span>
个人在一张无向图上往1走，可以选择在原地不动或者走一条边</p>
<p>一个人在 <span class="math inline">\(x\)</span>
时间到达目的地的代价是 <span class="math inline">\(c\cdot x\)</span> ，
<span class="math inline">\(c\)</span> 是常数</p>
<p>一条边同一时间被 <span class="math inline">\(x\)</span>
个人经过的代价是 <span class="math inline">\(x^2\cdot d\)</span> ，
<span class="math inline">\(d\)</span> 是常数</p>
<p>最小化代价</p>
<p><br></p>
<h3 id="分析">分析</h3>
<p>无法贪心，无法最短路的题目，那就先试试网络流</p>
<p>考虑将时间和位置压在一起建立节点，时间 <span
class="math inline">\(\leq n+k\)</span></p>
<p><span class="math inline">\((t,u)\rightarrow (t+1,u)\)</span></p>
<p><span class="math inline">\((t,u)\rightarrow (t+1,v)\)</span></p>
<p>在原地保持的边代价为 <span class="math inline">\(c\)</span> ，流量
<span class="math inline">\(\infty\)</span></p>
<p>在两点间移动的代价由于与个数有关，可以建立 <span
class="math inline">\(k\)</span> 条边</p>
<p>每条代价是 <span
class="math inline">\(d(i^2-(i-1)^2)+c=c+(2i-1)d\)</span></p>
<p>得到一个 <span class="math inline">\(O((n+k)n)\)</span> 点数 <span
class="math inline">\(O((n+k)m\cdot k)\)</span> 边数的图</p>
<p>然后可以考虑依次将每个人加入流量</p>
<p>但是实际上，并不需要显式地将所有边连出来跑网络流</p>
<p>每次加入一个点看做一个带回撤的最短路问题，有效的边只有 <span
class="math inline">\((n+k)m\)</span> 条</p>
<p>因此复杂度为 <span class="math inline">\(O(k\cdot
\text{SPFA}((n+k)n,(n+k)m))\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k,C,D;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">&#125; e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++ecnt]=(Edge)&#123;v,head[u]&#125;;</span><br><span class="line">	head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[N][N],pre[N][N],inq[N][N],G[N][N],W[N][N];</span><br><span class="line"><span class="type">static</span> queue &lt;Pii&gt; que;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Upd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> d,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dis[x][y]&gt;d) &#123;</span><br><span class="line">		dis[x][y]=d,pre[x][y]=p;</span><br><span class="line">		<span class="keyword">if</span>(!inq[x][y]) inq[x][y]=<span class="number">1</span>,que.<span class="built_in">push</span>(<span class="built_in">mp</span>(x,y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>(),C=<span class="built_in">rd</span>(),D=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,k) a[i]=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="built_in">AddEdge</span>(u,v),<span class="built_in">AddEdge</span>(v,u);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,n+k) G[j][i*<span class="number">2</span>]=G[j][i*<span class="number">2</span>+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(_,<span class="number">1</span>,k) &#123;</span><br><span class="line">		<span class="type">int</span> u=a[_];</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,n+k) <span class="built_in">rep</span>(j,<span class="number">1</span>,n) dis[i][j]=INF;</span><br><span class="line">		dis[<span class="number">1</span>][u]=<span class="number">0</span>,que.<span class="built_in">push</span>(<span class="built_in">mp</span>(<span class="number">1</span>,u));</span><br><span class="line">		<span class="type">int</span> tu=<span class="number">1</span>,ti=<span class="number">-1</span>,mi=<span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="type">int</span> t=que.<span class="built_in">front</span>().first,u=que.<span class="built_in">front</span>().second; que.<span class="built_in">pop</span>();</span><br><span class="line">			inq[t][u]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(u==<span class="number">1</span> &amp;&amp; dis[t][u]&lt;mi) mi=dis[t][u],ti=t,tu=u;</span><br><span class="line">			<span class="keyword">if</span>(t&gt;<span class="number">1</span> &amp;&amp; W[t<span class="number">-1</span>][u]) <span class="built_in">Upd</span>(t<span class="number">-1</span>,u,dis[t][u]-C,<span class="number">1001</span>);</span><br><span class="line">			<span class="keyword">if</span>(t&lt;n+k) <span class="built_in">Upd</span>(t+<span class="number">1</span>,u,dis[t][u]+C,<span class="number">1002</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt) &#123;</span><br><span class="line">				<span class="type">int</span> v=e[i].to;</span><br><span class="line">				<span class="keyword">if</span>(G[t<span class="number">-1</span>][i^<span class="number">1</span>]&gt;<span class="number">1</span>) <span class="built_in">Upd</span>(t<span class="number">-1</span>,v,dis[t][u]-(G[t<span class="number">-1</span>][i^<span class="number">1</span>]<span class="number">-2</span>)*D-C,-(i^<span class="number">1</span>));</span><br><span class="line">				<span class="keyword">if</span>(t&lt;n+k) <span class="built_in">Upd</span>(t+<span class="number">1</span>,v,dis[t][u]+G[t][i]*D+C,i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=mi;</span><br><span class="line">		<span class="keyword">while</span>(tu!=u || ti!=<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> t=pre[ti][tu];</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="number">1001</span>) --W[ti++][tu];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">1002</span>) W[--ti][tu]++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(t&lt;<span class="number">0</span>) G[ti][-t]-=<span class="number">2</span>,tu=e[-t].to,ti++;</span><br><span class="line">			<span class="keyword">else</span> G[ti<span class="number">-1</span>][t]+=<span class="number">2</span>,tu=e[t^<span class="number">1</span>].to,ti--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1146G%20-%20Satanic%20Panic/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1146G - Satanic Panic' date: 'Sat Aug 12 11:05:25 2023
categories: - oi-solutions'</p>
<h1 id="cf1146g---satanic-panic">CF1146G - Satanic Panic</h1>
<h3 id="题目大意">题目大意</h3>
<p>给定平面上 <span class="math inline">\(n\)</span>
个点，求能够构成五角星的五元组数目</p>
<p><br></p>
<h3 id="分析">分析</h3>
<p>实际上就是求五元凸包数目，下面直接考虑 <span
class="math inline">\(k\)</span> 元的形式</p>
<p>考虑凸包的两种判定方法：</p>
<p>1.所有转角 <span class="math inline">\(&lt;\pi\)</span></p>
<p>然而这并不好实现</p>
<p>2.一个凸包可以根据 <span class="math inline">\(x_i\)</span>
最大、最小的两个点分成上下两部分，上下分别判断转角 <span
class="math inline">\(&lt;\pi\)</span></p>
<p>（可以通过随机旋转规避 <span class="math inline">\(x_i\)</span>
相同的情况）</p>
<p><del>（这题 <span class="math inline">\(k\)</span>
较小，或许可以上下暴力枚举？）</del></p>
<p>一般的情况，枚举 <span class="math inline">\(x_i\)</span> 最小的点
<span class="math inline">\(A\)</span></p>
<p>然后令 <span class="math inline">\(dp_{i,j}\)</span>
表示当前凸包最后一条折线为 <span class="math inline">\((i,j)\)</span>
，然后不断接新点</p>
<p>最后合并上下两个凸包</p>
<p>直接实现，单次 <span class="math inline">\(dp\)</span> 状态 <span
class="math inline">\(O(n^2k)\)</span> ，转移 <span
class="math inline">\(O(n)\)</span> ，复杂度为 <span
class="math inline">\(O(n^4k)\)</span></p>
<p>优化：</p>
<p>设 <span class="math inline">\((i,j)\rightarrow (j,k)\)</span>
，可以先确定 <span class="math inline">\(j\)</span></p>
<p>然后按照转角顺序枚举 <span class="math inline">\(k\)</span>
，双指针完成所有 <span class="math inline">\(k\)</span> 的转移</p>
<p>如果预处理每个点出发的转角序，则预处理 <span
class="math inline">\(O(n^2\log n)\)</span> ，总复杂度为 <span
class="math inline">\(O(n^3k)\)</span></p>
<p><del>(Code消失了)</del></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1201E2%20-%20Knightmare%20(hard)/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1201E2 - Knightmare (hard)' date: 'Sat Aug 12 11:05:25 2023
categories: - oi-solutions'</p>
<h1 id="cf1201e2---knightmare-hard">CF1201E2 - Knightmare (hard)</h1>
<h3 id="题目大意">题目大意</h3>
<p><span class="math inline">\(n\times m(2|n,2|m)\)</span>
的棋盘上有两个 马 <del>(Knight是国际象棋)</del> 分别位于 <span
class="math inline">\(S_1=(x_1,y_1),S_2=(x_2,y_2)\)</span></p>
<p>他们分别要到达 <span
class="math inline">\(T_1=(\frac{n}{2},\frac{m}{2}),T_2=(\frac{n}{2}+1,\frac{m}{2})\)</span></p>
<p>一方胜利的情况是：</p>
<p>1.吃掉另一方</p>
<p>2.到达自己的目标位置，且这个位置不能被另一方吃掉</p>
<p>你可以选定操作先手还是后手，要求和交互器交互，并且在<strong>350</strong>步内取胜</p>
<p><br></p>
<h3 id="分析">分析</h3>
<p>首先是一个重要的性质：<strong>双方必然有一方永远无法吃掉另一方</strong></p>
<p>考虑象棋的移动，每次 <span class="math inline">\((x\pm 1,y\pm
2)\)</span> 或者 <span class="math inline">\((x\pm 2,y\pm
1)\)</span></p>
<p>每次操作，必然导致 <span class="math inline">\(x+y\mod 2\)</span>
改变，在双方轮流操作的过程中</p>
<p>必然有一方走的时候永远无法和另一方同奇偶，也就是无法吃掉另一方</p>
<p><br></p>
<p>在此基础上，考虑几种情况</p>
<p>设 <span class="math inline">\(D(a,b)\)</span> 为 <span
class="math inline">\(a,b\)</span> 两点的距离， <span
class="math inline">\(f\)</span> 为先手是否永远不会被吃</p>
<p>1.先手可以在不被后手吃掉的情况下到达目标，且先于后手</p>
<p>先于后手即 <span class="math inline">\(D(S_1,T_1)\leq
D(S_2,T_2)\)</span></p>
<p>先手不被后手吃掉的情况</p>
<ol type="1">
<li><p><span class="math inline">\(f\)</span> ： 显然</p></li>
<li><p><span class="math inline">\(D(S_1,T_1)&lt;D(S_2,T_1)\)</span>
：</p></li>
</ol>
<p>此时，假设后手存在一个吃掉先手的策略</p>
<p>那么后手经过这个吃掉先手的点到达 <span
class="math inline">\(T_1\)</span> 的最短路一定和先手相同，故矛盾</p>
<p><br></p>
<p>2.后手可以在不被先手吃掉的情况下到达目标，且先于先手</p>
<p><span class="math inline">\(D(S_1,T_1)&gt;D(S_2,T_2)\)</span></p>
<p>对称情况</p>
<ol type="1">
<li><p><span class="math inline">\(not\  f\)</span></p></li>
<li><p><span
class="math inline">\(D(S_2,T_2)&lt;D(S_1,T_2)-1\)</span></p></li>
</ol>
<p>以上两种情况均直接冲最短路到达目标</p>
<p><br></p>
<p>3.双方均无法安全直接抵达目标</p>
<p>此时，考虑选择不会被吃的一方操作</p>
<p>由于自己是无敌的，可以考虑先猛扑对方的终点</p>
<p>3.1 <span class="math inline">\(f=true\)</span> ，选择先手</p>
<p>先走到 <span class="math inline">\(T_2\)</span>
堵住后手，然后可以绕三步到达 <span
class="math inline">\(T_1\)</span></p>
<p>先手占据 <span class="math inline">\(T_2\)</span> 时，后手无法到达
<span class="math inline">\(T_2\)</span></p>
<p>走第一步时，由于先手限制着，后手无法进入 <span
class="math inline">\(T_2\)</span></p>
<p>走第二步时，根据奇偶性分析，后手无法到达 <span
class="math inline">\(T_2\)</span> 的奇偶性</p>
<p>第三步到达目标</p>
<p>3.2 <span class="math inline">\(f=false\)</span> ，同理</p>
<h3 id="实现">实现</h3>
<p>可以好好封装一下</p>
<p><del>我曾经以为不用读入</del></p>
<p>由于交互器下面读入的参数可能会让交互器走智障操作</p>
<p>如果能吃掉对方，一定要直接吃掉</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>,INF=<span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[]=&#123;<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,opt;</span><br><span class="line"><span class="type">int</span> x=<span class="number">-2</span>,y=<span class="number">-2</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span>&#123; </span><br><span class="line">	x=<span class="built_in">rd</span>(),y=<span class="built_in">rd</span>(); </span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CB</span><span class="params">()</span></span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;BLACK&quot;</span>),<span class="built_in">fflush</span>(stdout),<span class="built_in">input</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CW</span><span class="params">()</span></span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;WHITE&quot;</span>),<span class="built_in">fflush</span>(stdout); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bfser</span>&#123;</span><br><span class="line">	<span class="type">int</span> dis[N][N],pre[N][N];</span><br><span class="line">	<span class="type">int</span> QX[N*N],QY[N*N],L,R;</span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Reach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> a=<span class="built_in">abs</span>(u-x),b=<span class="built_in">abs</span>(y-v);</span><br><span class="line">		<span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">		<span class="keyword">return</span> a==<span class="number">1</span> &amp;&amp; b==<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		u=x,v=y;</span><br><span class="line">		QX[L=R=<span class="number">1</span>]=x,QY[<span class="number">1</span>]=y,pre[x][y]=<span class="number">-1</span>,dis[x][y]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;L&lt;=R;) &#123;</span><br><span class="line">			x=QX[L],y=QY[L++];</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">7</span>) &#123;</span><br><span class="line">				<span class="type">int</span> x1=x+dx[i],y1=y+dy[i];</span><br><span class="line">				<span class="keyword">if</span>(x1&lt;<span class="number">1</span> || y1&lt;<span class="number">1</span> || x1&gt;n || y1&gt;m || dis[x1][y1]) <span class="keyword">continue</span>;</span><br><span class="line">				dis[x1][y1]=dis[x][y]+<span class="number">1</span>,QX[++R]=x1,QY[R]=y1,pre[x1][y1]=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Go</span><span class="params">(<span class="type">int</span> d,<span class="type">int</span> k=<span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">Reach</span>()) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,y),<span class="built_in">fflush</span>(stdout),<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,u+=dx[d],v+=dy[d]),<span class="built_in">fflush</span>(stdout);</span><br><span class="line">		<span class="keyword">if</span>(k) <span class="built_in">input</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Go</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		vector &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">		<span class="keyword">while</span>(~pre[x][y]) &#123;</span><br><span class="line">			<span class="type">int</span> t=pre[x][y];</span><br><span class="line">			s.<span class="built_in">pb</span>(t),x-=dx[t],y-=dy[t];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">drep</span>(i,s.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>) <span class="built_in">Go</span>(s[i],k+i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; B,W;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="type">int</span> x1=<span class="built_in">rd</span>(),y1=<span class="built_in">rd</span>(),x2=<span class="built_in">rd</span>(),y2=<span class="built_in">rd</span>();</span><br><span class="line">	W.<span class="built_in">Bfs</span>(x1,y1),B.<span class="built_in">Bfs</span>(x2,y2);</span><br><span class="line">	<span class="type">int</span> f=((x1+y1)&amp;<span class="number">1</span>)!=((x2+y2)&amp;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(W.dis[n/<span class="number">2</span>][m/<span class="number">2</span>]&lt;=B.dis[n/<span class="number">2</span>+<span class="number">1</span>][m/<span class="number">2</span>] &amp;&amp; (f || W.dis[n/<span class="number">2</span>][m/<span class="number">2</span>]&lt;B.dis[n/<span class="number">2</span>][m/<span class="number">2</span>])) &#123;</span><br><span class="line">		<span class="built_in">CW</span>(),x=x2,y=y2,W.<span class="built_in">Go</span>(n/<span class="number">2</span>,m/<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(B.dis[n/<span class="number">2</span>+<span class="number">1</span>][m/<span class="number">2</span>]&lt;W.dis[n/<span class="number">2</span>][m/<span class="number">2</span>] &amp;&amp; (B.dis[n/<span class="number">2</span>+<span class="number">1</span>][m/<span class="number">2</span>]&lt;W.dis[n/<span class="number">2</span>+<span class="number">1</span>][m/<span class="number">2</span>]<span class="number">-1</span> || !f)) &#123;</span><br><span class="line">		<span class="built_in">CB</span>(),B.<span class="built_in">Go</span>(n/<span class="number">2</span>+<span class="number">1</span>,m/<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(f) &#123;</span><br><span class="line">		<span class="built_in">CW</span>(),x=x2,y=y2,W.<span class="built_in">Go</span>(n/<span class="number">2</span>+<span class="number">1</span>,m/<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">		W.<span class="built_in">Go</span>(<span class="number">2</span>),W.<span class="built_in">Go</span>(<span class="number">5</span>),W.<span class="built_in">Go</span>(<span class="number">7</span>,<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">CB</span>(),B.<span class="built_in">Go</span>(n/<span class="number">2</span>,m/<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">		B.<span class="built_in">Go</span>(<span class="number">0</span>),B.<span class="built_in">Go</span>(<span class="number">7</span>),B.<span class="built_in">Go</span>(<span class="number">5</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1217F%20-%20Forced%20Online%20Queries%20Problem/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1217F - Forced Online Queries Problem' date: 'Sat Aug 12
11:05:25 2023 categories: - oi-solutions'</p>
<h1 id="cf1217f---forced-online-queries-problem">CF1217F - Forced Online
Queries Problem</h1>
<h3 id="题目大意">题目大意</h3>
<p><span class="math inline">\(n\)</span> 个点无向图， <span
class="math inline">\(m\)</span>
次操作，每次加入/删除一条边，或者查询两个点连通性</p>
<p><span class="math inline">\(lst\)</span> 为上次查询的连通性情况，即
<span class="math inline">\(lst=\{0,1\}\)</span></p>
<p>加密方式为 <span class="math inline">\(x=(x&#39;+lst-1)\mod
n+1\)</span></p>
<p><br></p>
<h3 id="吐槽">吐槽</h3>
<p><del>如果你管这叫Forced Online？</del></p>
<p><br></p>
<h3 id="分析">分析</h3>
<h3 id="无强制在线">无强制在线</h3>
<p>如果没有这个假的强制在线，考虑用线段树分治解决</p>
<p>预处理每条边出现的时间区间 <span class="math inline">\([L,R]\)</span>
，加入线段树，用按秩合并并查集维护加边和回撤即可</p>
<p><br></p>
<h3 id="伪强制在线">伪强制在线</h3>
<p>依然是预处理每条边的时间区间</p>
<p>虽然我们无法确定一条边<strong>存在</strong>的时间区间</p>
<p>但是我们可以确定一条边<strong>可能存在，或者说可能被修改</strong>的时间区间</p>
<p>一次修改对应两条可能的边，对于两种可能都加入两条边对应的时间节点</p>
<p>每次加边修改指定边，对于涉及的两条边，修改之后判断是否存在</p>
<p>然后对于存在的边，将这条边从现在开始到
<strong>下一个时间节点</strong> 出现之间都插入即可</p>
<p>注意这个线段树分治是"半在线"的，即要一边处理操作一边插入修改</p>
<p>由于修改的区间和目前遍历的区间不交，所以容易实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,c;</span><br><span class="line">map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; M[N],I[N];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; T[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> P[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> stk[N],top,S[N],F[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(F[x]!=x) x=x[F][F];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	x=<span class="built_in">Find</span>(x),y=<span class="built_in">Find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(S[x]&gt;S[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	F[x]=y,S[y]+=S[x],stk[++top]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Back</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=stk[top--];</span><br><span class="line">	S[F[x]]-=S[x],F[x]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector &lt;Pii&gt; G[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr,Pii x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql&gt;qr) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) <span class="keyword">return</span> G[p].<span class="built_in">pb</span>(x);</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid) <span class="built_in">Add</span>(p&lt;&lt;<span class="number">1</span>,l,mid,ql,qr,x);</span><br><span class="line">	<span class="keyword">if</span>(qr&gt;mid) <span class="built_in">Add</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,ql,qr,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> opt[N],A[N],B[N],lst;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp=top;</span><br><span class="line">	<span class="keyword">for</span>(Pii t:G[p]) <span class="built_in">Union</span>(t.first,t.second);</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		<span class="type">int</span> x=(A[l]+lst<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> y=(B[l]+lst<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="keyword">if</span>(opt[l]==<span class="number">1</span>) &#123;</span><br><span class="line">			M[x][y]^=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="type">int</span> x=(A[l]+i<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">				<span class="type">int</span> y=(B[l]+i<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">				<span class="type">int</span> id=I[x][y];</span><br><span class="line">				P[id]++;</span><br><span class="line">				<span class="keyword">if</span>(M[x][y]) <span class="built_in">Add</span>(<span class="number">1</span>,<span class="number">1</span>,m,l+<span class="number">1</span>,T[id][P[id]]<span class="number">-1</span>,<span class="built_in">mp</span>(x,y));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			lst=<span class="built_in">Find</span>(x)==<span class="built_in">Find</span>(y);</span><br><span class="line">			<span class="built_in">putchar</span>(lst+<span class="number">48</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">Solve</span>(p&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">Solve</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(top&gt;tmp) <span class="built_in">Back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) F[i]=i,S[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		opt[i]=<span class="built_in">rd</span>(),A[i]=<span class="built_in">rd</span>(),B[i]=<span class="built_in">rd</span>();</span><br><span class="line">		<span class="keyword">if</span>(opt[i]==<span class="number">1</span>) <span class="built_in">rep</span>(lst,<span class="number">0</span>,<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> x=(A[i]+lst<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> y=(B[i]+lst<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">			<span class="keyword">if</span>(!I[x][y]) I[x][y]=++c;</span><br><span class="line">			T[I[x][y]].<span class="built_in">pb</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,c) T[i].<span class="built_in">pb</span>(m+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">Solve</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1221G%20-%20Graph%20And%20Numbers/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1221G - Graph And Numbers' date: 'Sat Aug 12 11:05:25 2023
categories: - oi-solutions'</p>
<h1 id="cf1221g---graph-and-numbers">CF1221G - Graph And Numbers</h1>
<h3 id="题目大意">题目大意</h3>
<p>给定一个 <span class="math inline">\(n\)</span> 点 <span
class="math inline">\(m\)</span> 边的无向图， <span
class="math inline">\(n\leq 40\)</span></p>
<p>求给所有点01染色，满足</p>
<p>至少存在一条边两边的点均为0</p>
<p>至少存在一条边两边的点一个为0，一个为1</p>
<p>至少存在一条边两边的点均为1</p>
<p>的方案数</p>
<p><br></p>
<h3 id="分析">分析</h3>
<p><strong>至少存在</strong> 问题并不好处理，由于限制有3个，可以通过
<span class="math inline">\(2^3\)</span> 种情况容斥得到</p>
<p>设三种边类型为0,1,2</p>
<p>即计算</p>
<p>1.不存在0</p>
<p>2.不存在1</p>
<p>3.不存在2</p>
<p>4.不存在01</p>
<p>5.不存在02</p>
<p>6.不存在12</p>
<p>7.不存在012</p>
<h3 id="逐个击破">逐个击破</h3>
<p>2.即计算所有边连接两个点染色相同方案数，统计连通块即可</p>
<p>4/6即统计所有点两边都是1/0的方案数</p>
<p>5即统计所有边两端点颜色不同的方案数，即二分图染色数</p>
<p>7.即m=0</p>
<p>1,3类似，可以归纳为每条边两端的点至少有一个为1</p>
<p><del>似乎有点类似一般图独立集个数的求解</del></p>
<p>由于 <span class="math inline">\(n\leq 40\)</span> ，考虑 <span
class="math inline">\(\text{meet in the middle}\)</span> 做</p>
<p>枚举半边，判断集合内部是否有非法边，然后根据集合之间的非法边以及自己集合内部为0的点</p>
<p>确定另一个集合必须选择为1的点集</p>
<p>因此需要一个父集前缀和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">45</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> G[N][N];</span><br><span class="line">ll E[N]; <span class="comment">// 这东西居然要开long long</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Solve0</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> S[<span class="number">1</span>&lt;&lt;<span class="number">20</span>];</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> m=n/<span class="number">2</span>,A=(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>) &#123;</span><br><span class="line">		ll T=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,m<span class="number">-1</span>) <span class="keyword">if</span>(~i&amp;(<span class="number">1</span>&lt;&lt;j)) T|=E[j];</span><br><span class="line">		S[i]=(~i&amp;T&amp;A)==<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 父集前缀和</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=A;i&lt;&lt;=<span class="number">1</span>) <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=A;l+=i*<span class="number">2</span>) <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;l+i;++j) S[j]+=S[j+i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;(n-m))<span class="number">-1</span>) &#123;</span><br><span class="line">		ll T=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,n-m<span class="number">-1</span>) <span class="keyword">if</span>(~i&amp;(<span class="number">1</span>&lt;&lt;j)) T|=E[j+m];</span><br><span class="line">		<span class="keyword">if</span>((T&gt;&gt;m)&amp;~i) <span class="keyword">continue</span>;</span><br><span class="line">		T&amp;=A,ans+=S[T];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> vis[N];</span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> u) &#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[u]) <span class="keyword">return</span>;</span><br><span class="line">		vis[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(G[u][i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(!vis[i]) <span class="built_in">dfs</span>(i),ans&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Solve01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(!E[i]) ans&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Solve02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> vis[N],fl=<span class="number">1</span>;</span><br><span class="line">	function &lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs=[&amp;](<span class="type">int</span> u,<span class="type">int</span> c) &#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[u]!=c) fl=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[u]=c;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(G[u][i]) <span class="built_in">dfs</span>(i,<span class="number">3</span>-c);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(!vis[i]) <span class="built_in">dfs</span>(i,<span class="number">1</span>),ans&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> fl*ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,m) &#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">rd</span>()<span class="number">-1</span>,y=<span class="built_in">rd</span>()<span class="number">-1</span>;</span><br><span class="line">		G[x][y]=G[y][x]=<span class="number">1</span>;</span><br><span class="line">		E[x]|=<span class="number">1ll</span>&lt;&lt;y,E[y]|=<span class="number">1ll</span>&lt;&lt;x;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">1ll</span>&lt;&lt;n;</span><br><span class="line">	ans-=<span class="number">2</span>*<span class="built_in">Solve0</span>(),ans-=<span class="built_in">Solve1</span>();</span><br><span class="line">	ans+=<span class="number">2</span>*<span class="built_in">Solve01</span>()+<span class="built_in">Solve02</span>();</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">0</span>) ans-=<span class="number">1ll</span>&lt;&lt;n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/oi-solutions/CodeForces/CF1236F%20-%20Alice%20and%20the%20Cactus/</url>
    <content><![CDATA[<hr />
<p>title: 'CF1236F - Alice and the Cactus' date: 'Sat Aug 12 11:05:25
2023 categories: - oi-solutions'</p>
<h1 id="cf1236f---alice-and-the-cactus">CF1236F - Alice and the
Cactus</h1>
<h3 id="题目大意">题目大意</h3>
<p>给定一棵仙人掌，现在每个点有 <span
class="math inline">\(\frac{1}{2}\)</span> 概率被删除</p>
<p>设删除后剩余连通块数为 <span class="math inline">\(\Chi\)</span> ，求
<span class="math inline">\(D(\Chi)\)</span> （ <span
class="math inline">\(D\)</span> 为方差）</p>
<p><br></p>
<h3 id="分析">分析</h3>
<p>由简单结论 <span
class="math inline">\(D(\Chi)=E(\Chi^2)-E^2(\Chi)\)</span></p>
<p>考虑计算 <span class="math inline">\(E(\Chi ^2),E(\Chi)\)</span>
，也就是计算所有情况下 <span class="math inline">\(\Chi^2,\Chi\)</span>
之和</p>
<p>实际上对于计算 <span class="math inline">\(E(\Chi^k)\)</span>
的情况，可以记录 <span
class="math inline">\(E(\Chi^i),i\in[0,k]\)</span> 所有的答案</p>
<p>然后在仙人掌上 <span class="math inline">\(dp\)</span> ，每次合并两个
<span class="math inline">\(dp\)</span> 时对于 <span
class="math inline">\((\Chi+\Chi&#39;)^i\)</span> 做二项展开计算答案</p>
<p>环上 <span class="math inline">\(dp\)</span>
记录开头和结尾的一些状态即可</p>
<p>如果分裂出一个连通块，就对于当前 <span
class="math inline">\(\Chi^i\rightarrow (\Chi+1)^i\)</span>
，同样是二项展开</p>
<p>具体不再赘述</p>
<p>复杂度为 <span class="math inline">\(O(n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y),<span class="built_in">z</span>(z)&#123;&#125;</span><br><span class="line">    Node <span class="keyword">operator</span> * (<span class="type">const</span> Node t) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Node</span>(<span class="number">1ll</span>*x*t.x%P,</span><br><span class="line">                (<span class="number">1ll</span>*y*t.x+<span class="number">1ll</span>*t.y*x)%P,</span><br><span class="line">                (<span class="number">1ll</span>*z*t.x+<span class="number">1ll</span>*t.z*x+<span class="number">2ll</span>*y*t.y)%P);</span><br><span class="line">    &#125;</span><br><span class="line">    Node <span class="keyword">operator</span> + (<span class="type">const</span> Node t) <span class="type">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Node</span>((x+t.x)%P,(y+t.y)%P,(z+t.z)%P);</span><br><span class="line">    &#125;</span><br><span class="line">    Node <span class="keyword">operator</span> + (<span class="type">const</span> <span class="type">int</span> t) <span class="type">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Node</span>(x,(y+<span class="number">1ll</span>*t*x)%P,(z+<span class="number">2ll</span>*y*t+<span class="number">1ll</span>*x*t%P*t%P)%P);</span><br><span class="line">    &#125;</span><br><span class="line">    Node <span class="keyword">operator</span> * (<span class="type">const</span> <span class="type">int</span> t) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Node</span>(<span class="number">1ll</span>*x*t%P,<span class="number">1ll</span>*y*t%P,<span class="number">1ll</span>*z*t%P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; dp[N][<span class="number">2</span>],f[N][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,nxt;</span><br><span class="line">&#125; e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++ecnt]=(Edge)&#123;v,head[u]&#125;;</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> low[N],t[N],dfn,stk[N],top;</span><br><span class="line"><span class="type">int</span> A[N],C;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    low[u]=t[u]=++dfn,stk[++top]=u;</span><br><span class="line">    dp[u][<span class="number">0</span>]=<span class="built_in">Node</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>),dp[u][<span class="number">1</span>]=<span class="built_in">Node</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(t[v]) &#123;</span><br><span class="line">            <span class="built_in">cmin</span>(low[u],t[v]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(v),<span class="built_in">cmin</span>(low[u],low[v]);</span><br><span class="line">        <span class="keyword">if</span>(low[v]&lt;t[u]) <span class="keyword">continue</span>;</span><br><span class="line">        A[C=<span class="number">1</span>]=u;</span><br><span class="line">        <span class="keyword">while</span>(t[stk[top]]&gt;=t[v]) A[++C]=stk[top--];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,C) <span class="built_in">rep</span>(a,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">rep</span>(b,<span class="number">0</span>,<span class="number">2</span>) f[i][a][b]=<span class="built_in">Node</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=dp[u][<span class="number">0</span>], f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">2</span>]=dp[u][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">2</span>,C) &#123;</span><br><span class="line">            <span class="built_in">rep</span>(a,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">rep</span>(b,<span class="number">0</span>,<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">rep</span>(c,<span class="number">0</span>,<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> d=c==<span class="number">1</span> &amp;&amp; b==<span